{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://pro.stonepark.fun","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-03-24T20:16:39.220Z","updated":"2019-03-24T18:02:29.000Z","comments":false,"path":"/404.html","permalink":"http://pro.stonepark.fun//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-03-24T20:15:43.658Z","updated":"2019-03-24T18:02:29.000Z","comments":false,"path":"about/index.html","permalink":"http://pro.stonepark.fun/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2019-03-24T20:15:32.127Z","updated":"2019-03-24T18:02:29.000Z","comments":false,"path":"categories/index.html","permalink":"http://pro.stonepark.fun/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-03-24T20:15:36.940Z","updated":"2019-03-24T18:02:29.000Z","comments":false,"path":"books/index.html","permalink":"http://pro.stonepark.fun/books/index.html","excerpt":"","text":""},{"title":"链接","date":"2019-03-24T20:14:22.805Z","updated":"2019-03-24T20:14:22.805Z","comments":false,"path":"links/index.html","permalink":"http://pro.stonepark.fun/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-03-24T20:15:23.065Z","updated":"2019-03-24T18:02:29.000Z","comments":false,"path":"repository/index.html","permalink":"http://pro.stonepark.fun/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-24T20:15:27.476Z","updated":"2019-03-24T18:02:29.000Z","comments":false,"path":"tags/index.html","permalink":"http://pro.stonepark.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"String.prototype.split()","slug":"String-prototype-split","date":"2019-02-21T20:16:48.000Z","updated":"2019-02-21T20:28:26.000Z","comments":true,"path":"2019/02/22/String-prototype-split/","link":"","permalink":"http://pro.stonepark.fun/2019/02/22/String-prototype-split/","excerpt":"","text":"String.prototype.split()[TOC] 捕获括号（Capturing parentheses）如果 separator 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。1234var myString = \"Hello 1 word. Sentence number 2.\";var splits = myString.split(/(\\d)/);console.log(splits); 上例输出：1[ &quot;Hello &quot;, &quot;1&quot;, &quot; word. Sentence number &quot;, &quot;2&quot;, &quot;.&quot; ] 移出字符串中的空格下例中，split() 方法会查找“0 或多个空白符接着的分号，再接着 0 或多个空白符”模式的字符串，找到后，就将空白符从字符串中移除，nameList 是 split 的返回数组。 12345678var names = \"Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand \";console.log(names);var re = /\\s*(?:;|$)\\s*/;var nameList = names.split(re);console.log(nameList); 上例输出两行，第一行输出原始字符串，第二行输出结果数组。12Harry Trump ;Fred Barney; Helen Rigby ; Bill Abel ;Chris Hand [ &quot;Harry Trump&quot;, &quot;Fred Barney&quot;, &quot;Helen Rigby&quot;, &quot;Bill Abel&quot;, &quot;Chris Hand&quot;, &quot;&quot; ]","categories":[{"name":"javascript","slug":"javascript","permalink":"http://pro.stonepark.fun/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://pro.stonepark.fun/tags/javascript/"}]},{"title":"module.exports与exports，export与export default之间的关系和区别","slug":"module-exports与exports，export与export-default之间的关系和区别","date":"2019-01-04T09:44:16.000Z","updated":"2019-01-04T09:52:26.000Z","comments":true,"path":"2019/01/04/module-exports与exports，export与export-default之间的关系和区别/","link":"","permalink":"http://pro.stonepark.fun/2019/01/04/module-exports与exports，export与export-default之间的关系和区别/","excerpt":"","text":"转载: https://www.cnblogs.com/fayin/p/6831071.html 首先我们要明白一个前提，CommonJS模块规范和ES6模块规范完全是两种不同的概念。 CommonJS模块规范Node应用由模块组成，采用CommonJS模块规范。 根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。123456var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 1234var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 exports 与 module.exports为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。1var exports = module.exports; 于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 ES6模块规范不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123;firstName, lastName, year&#125;; 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; export default 命令使用export default命令，为模块指定默认输出。1234// export-default.jsexport default function () &#123; console.log('foo');&#125; 相关链接：CommonJS规范，http://javascript.ruanyifeng.com/nodejs/module.htmlES6 Module 的语法，http://es6.ruanyifeng.com/#docs/module","categories":[{"name":"node","slug":"node","permalink":"http://pro.stonepark.fun/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"http://pro.stonepark.fun/tags/node/"}]},{"title":"javascript-内存管理-循环引用处理","slug":"javascript-内存管理-循环引用处理","date":"2018-04-05T02:18:29.000Z","updated":"2018-06-08T12:42:49.000Z","comments":true,"path":"2018/04/05/javascript-内存管理-循环引用处理/","link":"","permalink":"http://pro.stonepark.fun/2018/04/05/javascript-内存管理-循环引用处理/","excerpt":"","text":"javascript 循环引用参考:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management 简介像C语言这样的高级语言一般都有低级的内存管理接口，比如 malloc()和free()。另一方面，JavaScript创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 后一个过程称为垃圾回收。这个“自动”是混乱的根源，并让JavaScript（和其他高级语言）开发者感觉他们可以不关心内存管理。 这是错误的。 内存生命周期不管什么程序语言，内存生命周期基本是一致的： 分配你所需要的内存使用分配到的内存（读、写）不需要时将其释放\\归还在所有语言中第一和第二部分都很清晰。最后一步在底层语言中很清晰，但是在像JavaScript 等上层语言中，这一步是隐藏的、透明的。 JavaScript 的内存分配 值的初始化为了不让程序员费心分配内存，JavaScript 在定义变量时就完成了内存分配。 12345678910111213141516171819var n = 123; // 给数值变量分配内存var s = \"azerty\"; // 给字符串分配内存var o = &#123; a: 1, b: null&#125;; // 给对象及其包含的值分配内存// 给数组及其包含的值分配内存（就像对象一样）var a = [1, null, \"abra\"]; function f(a)&#123; return a + 2;&#125; // 给函数（可调用的对象）分配内存// 函数表达式也能分配一个对象someElement.addEventListener('click', function()&#123; someElement.style.backgroundColor = 'blue';&#125;, false); 通过函数调用分配内存有些函数调用结果是分配对象内存： 123var d = new Date(); // 分配一个 Date 对象var e = document.createElement('div'); // 分配一个 DOM 元素 有些方法分配新变量或者新对象： 12345678910var s = \"azerty\";var s2 = s.substr(0, 3); // s2 是一个新的字符串// 因为字符串是不变量，// JavaScript 可能决定不分配内存，// 只是存储了 [0-3] 的范围。var a = [\"ouais ouais\", \"nan nan\"];var a2 = [\"generation\", \"nan nan\"];var a3 = a.concat(a2); // 新数组有四个元素，是 a 连接 a2 的结果 使用值使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。 当内存不再需要使用时释放大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“所分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。 高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。 垃圾回收如上文所述自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。本节将解释必要的概念，了解主要的垃圾回收算法和它们的局限性。 引用垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。 引用计数垃圾收集这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 示例 12345678910111213141516171819202122var o = &#123; a: &#123; b:2 &#125;&#125;; // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o// 很显然，没有一个可以被垃圾收集var o2 = o; // o2变量是第二个对“这个对象”的引用o = 1; // 现在，“这个对象”的原始引用o被o2替换了var oa = o2.a; // 引用“这个对象”的a属性// 现在，“这个对象”有两个引用了，一个是o2，一个是oao2 = \"yo\"; // 最初的对象现在已经是零引用了 // 他可以被垃圾回收了 // 然而它的属性a的对象还在被oa引用，所以还不能回收oa = null; // a属性的那个对象现在也是零引用了 // 它可以被垃圾回收了 限制：循环引用该算法有个限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收 12345678910function f()&#123; var o = &#123;&#125;; var o2 = &#123;&#125;; o.a = o2; // o 引用 o2 o2.a = o; // o2 引用 o return \"azerty\";&#125;f(); 实际例子IE 6, 7 使用引用计数方式对 DOM 对象进行垃圾回收。该方式常常造成对象被循环引用时内存发生泄漏： 123456var div;window.onload = function()&#123; div = document.getElementById(\"myDivElement\"); div.circularReference = div; div.lotsOfData = new Array(10000).join(\"*\");&#125;; 在上面的例子里，myDivElement 这个 DOM 元素里的 circularReference 属性引用了 myDivElement，造成了循环引用。如果该属性没有显示移除或者设为 null，引用计数式垃圾收集器将总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了。如果这个 DOM 元素拥有大量的数据 (如上的 lotsOfData 属性)，而这个数据占用的内存将永远不会被释放 标记-清除算法这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。 这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。 循环引用不再是问题了在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。 限制: 那些无法从根对象查询到的对象都将被清除尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。 javascript中的循环引用对象处理参考:https://blog.csdn.net/java_zys/article/details/51258997 先说明一下什么是循环引用对象： 1234var a=&#123;\"name\":\"zzz\"&#125;;var b=&#123;\"name\":\"vvv\"&#125;;a.child=b;b.parent=a; 这里的a和b都是一个循环引用对象。 循环引用对象本来没有什么问题，序列化的时候才会发生问题，比如调用JSON.stringify()对该类对象进行序列化，就会报错: Converting circular structure to JSON. 而序列化需求很常见，比如发起一个ajax请求提交一个对象就需要对对象进行序列化。 针对这种问题的一种解决方案是去除这种循环引用，Douglas Crockford写了一个JSON的扩展包，里面的cycle.js刚好就是用来解决此类问题。例如： 1var c = JSON.decycle(a) 这样就去除了a对象的循环引用，如果想恢复原本的循环引用对象a，可以调用retrocycle方法 1var a = JSON.retrocycle(c) 代码可以到github上下载： https://github.com/douglascrockford/JSON-js","categories":[{"name":"javascript","slug":"javascript","permalink":"http://pro.stonepark.fun/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://pro.stonepark.fun/tags/javascript/"}]},{"title":"javascript的命名代码块","slug":"javascript的命名代码块","date":"2018-04-04T05:24:26.000Z","updated":"2018-04-04T05:25:53.000Z","comments":true,"path":"2018/04/04/javascript的命名代码块/","link":"","permalink":"http://pro.stonepark.fun/2018/04/04/javascript的命名代码块/","excerpt":"","text":"参考:https://www.web-tinker.com/article/20015.html 123if(1)&#123; alert(0);&#125;; 看到这个代码，你会觉得它只有一个if语句，和一个判断为真时调用的函数。但是，事实上不止这些，if语句的部分仅仅是if(1)这个而已，而判断为真之后调用的函数也只是alert(0);这个而已。就这样，大括号完全被忽略了。人们通常会觉得，那个大括号是术语if语句的东西，其实不然。无论是if语句还是大括号，他们都是可以单独存在的。123456//if语句if(1);//用分号结束的话，条件为真就执行一个空语句。//大括号，可以作为一个独立的语句&#123; alert(0);&#125;; 它们完全可以作为独立的两个语句。if语句的作用，是判断条件是否成立，成立则执行紧接着的那个语句。而大括号在这里就是代码块，或者说匿名代码块。它是一个独立的语句，而它的作用是把许多个语句变成一个语句。比如有时候，if语句判断为真以后要做很多个动作，那么就会需要很多语句，而if本身判断为真以后只会执行紧接着的那个语句，这时候用大括号，把需要执行的一堆语句放在一个大括号中，变成代码块，这样就把一堆语句变成了一个语句。虽然if和大括号可以独立称为语句，但是它们写在一起的时候实际上是一个语句，这是因为if本身的功能是判断条件后直接后面的语句，所以“后面的语句”就变成了if的一部分，按照语句来划分就把“后面的语句”归入if语句中了。 通常，我们用的都是匿名代码块，但是还有命名代码块可以用。 12345if(1)a:&#123; alert(0); break a; alert(1);&#125;; 看这个代码，我们对if后面执行的代码快命名为a，在代码块内部，执行完第一个alert之后就强制结束这个代码块，那么后面的alert(1)就不会被执行到。也许在书本上找不到“命名代码块”这个东西，但是你可以结合label语句和break语句这这两个东西好好看看就会明白。label语句的作用是给语句命名，这里我们给代码块命名，所以就成了命名代码块。break语句通常是跳出循环，但是添加个操作数就可以跳出制定语句。这里的制定，这是说用label命名的语句。在这个例子中if语句其实可以去掉的，放着只是为了让break感觉上是从一个语句中跳出的。 命名代码块这玩意儿有什么用呢？比如表单验证之后需要执行很复杂的语句时就适合用匿名代码块 12345678910111213141516171819202122&lt;form name=\"f\"&gt; &lt;input name=\"t1\" /&gt;&lt;br/&gt; &lt;input name=\"t2\" /&gt;&lt;br/&gt; &lt;input name=\"t3\" /&gt;&lt;br/&gt; &lt;input name=\"t4\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;script&gt;var f=document.forms.f;f.onsubmit=function()&#123; chk:&#123; if(f.t1.value==\"\")break chk; if(f.t2.value==\"\")break chk; if(f.t3.value==\"\")break chk; if(f.t4.value==\"\")break chk; alert(\"验证通过！\"); return true; &#125;; alert(\"验证失败\"); return false;&#125;;&lt;/script&gt; 当然也可以使用一个变量作为验证成功与否的标识符，最后再判断那个变量；或者还可以用函数去做，验证失败时直接return掉；方法是很多的，但是这只是方法之一。懂得它的用法就可以了，也许以后你会遇上更适合用这个方法解决的问题。 最后，来说一说歧义句。1&#123;id:0&#125;;//这是个啥？ 一眼看过去，像是一个对象声明吧？但是又没有赋值语句，说是标准JSON又缺对双引号。其实，这玩意儿是123&#123; id:0&#125;; 一个大括号语句，里面把0这个没用没有动作的语句命名为id而已。123456//&#123;id:&#123;name:\"次碳酸钴\"&#125;&#125;;&#123; id:&#123; name:\"次碳酸钴\" &#125;&#125;; 这个也一样，这就是歧义句。如果想验证{id:0}到底是个啥？可以这样，1alert(eval(\"&#123;id:0&#125;\")); 这个代码输出的是0而不是object，所以显然这个大括号被解析为了代码块。如果想要让他输出object呢？很简单，让大括号做一个代码块不能做的操作，解析器就可以排除它是代码块的可能性了。1alert(eval(\"(&#123;id:0&#125;)\")); 只有这样，浏览器才能明白这玩儿而是一个object而不是代码块。这个歧义问题，可谓是JavaScript的一个BUG，自然语言有歧义就算了，编程语言怎么可以有歧义呢？所以后来标准JSON就被规定为所有键名必须加双引号，以区别开代码块和对象定义语句。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://pro.stonepark.fun/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://pro.stonepark.fun/tags/javascript/"}]},{"title":"find用法解析(macos环境BSD shell)","slug":"find用法解析-macos环境BSD-shell","date":"2018-04-03T08:44:33.000Z","updated":"2018-04-03T09:11:59.000Z","comments":true,"path":"2018/04/03/find用法解析-macos环境BSD-shell/","link":"","permalink":"http://pro.stonepark.fun/2018/04/03/find用法解析-macos环境BSD-shell/","excerpt":"","text":"排除指定目录参考:https://stackoverflow.com/questions/4210042/how-to-exclude-a-directory-in-find-command 文件搜索1find . -path ./misc -prune -o -name &apos;*.txt&apos; -print 文件夹搜索1find . -type d \\( -path dir1 -o -path dir2 -o -path dir3 \\) -prune -o -print 文件搜索另一种写法1find . -name \"*.png\" -not -path \"./a/*\" -and -not -path \"./b/*\" 排除指定目录12345678910111213141516# 获取指定目录下的文件find . -type f \\( -path \"./a/*\" -o -path \"./b/*\" -o -path \"./c/*\" \\) -prune -name \"*.png\" -print# 获取指定目录 &amp; 子文件夹find . -type d \\( -path \"./a/*\" -o -path \"./b/*\" -o -path \"./c/*\" \\) -prune -print# 排除指定目录 写法1find . -name \"*.png\" -not -path \"./a/*\" -and -not -path \"./b/*\"# 排除指定目录 写法2find . -path \"./a/*\" -o -path \"./b/*\" -o -type f -name \"*.png\" -print# 连续写法find . -path ./a -prune -or \\-path ./b -prune -or \\-name '*.png' -print 待更新…","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"find","slug":"find","permalink":"http://pro.stonepark.fun/tags/find/"}]},{"title":"Mac Chrome crx 文件导出","slug":"Mac-Chrome-crx-文件导出","date":"2018-03-31T20:47:08.000Z","updated":"2018-03-31T21:03:18.000Z","comments":true,"path":"2018/04/01/Mac-Chrome-crx-文件导出/","link":"","permalink":"http://pro.stonepark.fun/2018/04/01/Mac-Chrome-crx-文件导出/","excerpt":"","text":"参考:https://jingyan.baidu.com/article/6b1823098bdc9fba59e15979.html step1: 进入终端1cd ~/Library/Application\\ Support/Google/Chrome/Default/Extensions/ step2: 打开chrome 扩展程序 查看 ID浏览器地址上输入 chrome://extensions/ step3: 进入项目 和版本号 step4: 复制路径12# 显示路径用的命令echo $PWD step5: 勾选开发者模式, 打开 “打包扩展程序” step6: 点击打包扩展程序 step7: 去生成的目录找.crx文件 , .pem文件可以删除 完成现在可以分享给别人了…","categories":[{"name":"chrome","slug":"chrome","permalink":"http://pro.stonepark.fun/categories/chrome/"}],"tags":[{"name":"chrome","slug":"chrome","permalink":"http://pro.stonepark.fun/tags/chrome/"}]},{"title":"Apache设置多个监听端口与架设多个网站的方法","slug":"Apache设置多个监听端口与架设多个网站的方法","date":"2018-03-30T11:48:32.000Z","updated":"2018-03-30T11:56:17.000Z","comments":true,"path":"2018/03/30/Apache设置多个监听端口与架设多个网站的方法/","link":"","permalink":"http://pro.stonepark.fun/2018/03/30/Apache设置多个监听端口与架设多个网站的方法/","excerpt":"","text":"参考:https://blog.csdn.net/mgsky1/article/details/52105434 打开Apache的httpf.conf文件, 去掉 注释12#LoadModule vhost_alias_module modules/mod_vhost_alias.so #Include conf/extra/httpd-vhosts.conf 接着，找到DocumentRoot 这个值要设置为你所有网站目录的最顶层目录 比如，www文件夹中包含localhost81文件夹和localhost82文件夹，localhost81、localhost82文件夹分别对应一个网站，这时，DocumentRoot就要设置为指向www文件夹的路径 继续，找到Listen 80在下面添加，例如要监听81端口 保存后打开extra文件夹下的httpd-vhosts.conf文件默认的这两个可以删掉 1234&lt;VirtualHost *:80&gt;DocumentRoot &quot;D:/example/example/1&quot;ServerName www.xxx.com&lt;/VirtualHost&gt;","categories":[{"name":"apache","slug":"apache","permalink":"http://pro.stonepark.fun/categories/apache/"}],"tags":[{"name":"apache","slug":"apache","permalink":"http://pro.stonepark.fun/tags/apache/"}]},{"title":"fastDFS & nginx 综合","slug":"fastDFS-nginx-综合","date":"2018-03-01T16:55:05.000Z","updated":"2018-03-01T16:56:06.000Z","comments":true,"path":"2018/03/02/fastDFS-nginx-综合/","link":"","permalink":"http://pro.stonepark.fun/2018/03/02/fastDFS-nginx-综合/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427#!/bin/bash################################# fastDFS need################################# 第一步：安装gcc环境yum install -y gcc-c++# 第二步：安装libevent，FastDFS依赖libevent库yum install -y libevent################################# nginx need################################# 第三步：安装libfastcommon，libfastcommon是FastDFS官方提供的包，包含了FastDFS运行所需要的一些基础库#Nginx是使用C语言开发，安装nginx需要先从官网上将源码下载，然后编译，编译需要gcc环境：yum install -y gcc-c++#PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安&gt;装pcre库yum install -y pcre pcre-devel#zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库yum install -y zlib zlib-devel#OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。#nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。yum install -y openssl openssl-develwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/libfastcommonV1.0.7.tar.gz\"# 下载fastdfs #最新版可从github上下载 https://github.com/happyfish100/fastdfswget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/fastdfs-5.05.tar.gz\"wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/nginx-1.8.0.tar.gz\"wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/fastdfs-nginx-module_v1.16.tar.gz\"# ---- fast dfs ---if [ ! -d \"/usr/local/fastdfs\" ]; then mkdir /usr/local/fastdfsficp ~/soft/libfastcommonV1.0.7.tar.gz /usr/local/fastdfscp ~/soft/fastdfs-5.05.tar.gz /usr/local/fastdfscd /usr/local/fastdfstar -zxvf libfastcommonV1.0.7.tar.gztar -zxvf fastdfs-5.05.tar.gzcd libfastcommon-1.0.7./make.sh &amp;&amp; ./make.sh install# libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录，所以需要将/usr/lib64下的库文件拷贝至/usr/lib下cp /usr/lib64/libfastcommon.so /usr/lib/cd /usr/local/fastdfs/fastdfs-5.05./make.sh &amp;&amp; ./make.sh install# --- 配置 ------# 拷贝/usr/local/fastdfs/fastdfs-5.05/conf 目录下的文件到/etc/fdfs 目录下if [ ! -d \"/etc/fdfs\" ]; then mkdir /etc/fdfsficp /usr/local/fastdfs/fastdfs-5.05/conf/* /etc/fdfs/cd /etc/fdfs# ★ Tracker配置sed -i '/^base_path/s/^/#/' /etc/fdfs/tracker.confsed -i '/^#base_path/a\\\\base_path=\\/usr\\/local\\/fastdfs\\/tracker' /etc/fdfs/tracker.conf# ★ Storage配置filepath=\"/etc/fdfs/storage.conf\"ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`names=(\"group_name\" \"base_path\" \"store_path0\" \"tracker_server\")replace_names=(\"group_name=group1\" \"base_path=\\/usr\\/local\\/fastdfs\\/storage\" \"store_path0=\\/usr\\/local\\/fastdfs\\/storage\" \"tracker_server=$ipaddr:22122\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do #sed -i \"\" \"/^$&#123;names[$i]&#125;/s/^/#/\" $filepath sed -i \"/^$&#123;names[$i]&#125;/s/^/#/\" $filepath #sed -i \"\" \"/^#$&#123;names[$i]&#125;/a\\ #$&#123;replace_names[$i]&#125;\" $filepath sed -i \"/^#$&#123;names[$i]&#125;/a\\\\$&#123;replace_names[$i]&#125;\" $filepath done# 创建目录#mkdir /usr/local/fastdfs/tracker –p#mkdir /usr/local/fastdfs/storage –pif [ ! -d \"/usr/local/fastdfs/tracker\" ]; then mkdir /usr/local/fastdfs/tracker –pfiif [ ! -d \"/usr/local/fastdfs/storage\" ]; then mkdir /usr/local/fastdfs/storage –pfips -ef | grep tracker | awk -F \" \" '&#123;if($8!=\"grep\")print $2&#125;' | xargs kill -9ps -ef | grep storage | awk -F \" \" '&#123;if($8!=\"grep\")print $2&#125;' | xargs kill -9# --- 启动 ------#Tracker启动命令：#/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf#Storage启动命令：#/usr/bin/fdfs_storaged /etc/fdfs/storage.conf############################################### This script will be executed *after* all the other init scripts.# You can put your own initialization stuff in here if you don't# want to do the full Sys V style init stuff.#设置开机自动启动：#vim /etc/rc.d/rc.local#将运行命令行添加进文件：#/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf#/usr/bin/fdfs_storaged /etc/fdfs/storage.conf############################################### 安装fastdfs-nginx-modulecp ~/soft/fastdfs-nginx-module_v1.16.tar.gz /usr/local/fastdfs/cd /usr/local/fastdfstar -zxvf fastdfs-nginx-module_v1.16.tar.gzfilepath=\"/usr/local/fastdfs/fastdfs-nginx-module/src/config\"sed -i \"s/\\/usr\\/local\\/include\\/fastdfs/\\/usr\\/include\\/fastdfs/g\" $filepathsed -i \"s/\\/usr\\/local\\/include\\/fastcommon/\\/usr\\/include\\/fastcommon/g\" $filepathsed -i \"s/\\/usr\\/local\\/lib/\\/usr\\/lib/g\" $filepath#将fastdfs-nginx-module/src下的mod_fastdfs.conf拷贝至/etc/fdfs/下cp /usr/local/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/# 修改mod_FastDFS.conf文件#base_path=/usr/local/fastdfs/storage#tracker_server=192.168.242.140:22122#url中是否包含group名称#url_have_group_name=true#指定文件存储路径，访问时使用该路径#store_path0=/usr/local/fastdfs/storagecd /etc/fdfs/modfilepath=\"mod_fastdfs.conf\"ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`#ipaddr='192.168.1.101'names=(\"base_path\" \"tracker_server\" \"url_have_group_name\")replace_names=(\"base_path=\\/usr\\/local\\/fastdfs\\/storage\" \"tracker_server=$ipaddr:22122\" \"url_have_group_name=true\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do sed -i \"/^$&#123;names[$i]&#125;/s/^/#/\" $modfilepath sed -i \"/^#$&#123;names[$i]&#125;/a\\\\$&#123;replace_names[$i]&#125;\" $modfilepath done#\"#[group1]\"##\"store_path0=\\/usr\\/local\\/fastdfs\\/storage\"## linux不能使用/r/n#sed -i \"s/^#\\\\[group1\\\\]/#\\\\[group1\\\\]`echo -e '\\r\\n'`store_path0=\\/usr\\/local\\/fastdfs\\/storage/g\" $modfilepath# 考虑到可能重复执行该脚本, 把之前设置的 注释掉sed -ie \"/^store_path0/s/^/#/\" $modfilepathsed -E -ie \"/^#\\[group1\\]/a\\\\store_path0=\\/usr\\/local\\/fastdfs\\/storage\" $modfilepath# 将libfdfsclient.so拷贝至/usr/lib下cp /usr/lib64/libfdfsclient.so /usr/lib/# 创建nginx/client目录if [ ! -d \"/var/temp/nginx/client\" ]; then mkdir -p /var/temp/nginx/clientfi#-- nginx --if [ ! -d \"/usr/local/nginx\" ]; then mkdir /usr/local/nginxficp ~/soft/nginx-1.8.0.tar.gz /usr/local/nginxcd /usr/local/nginxtar -zxvf nginx-1.8.0.tar.gzcd nginx-1.8.0#使用nginx的configure命令进行配置，./configure --help查询详细参数#进行nginx-1.8.0目录执行以下命令（其中prefix参数指定的是nginx的安装目录）：./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi \\--add-module=/usr/local/fastdfs/fastdfs-nginx-module/srcif [ ! -d \"/var/temp/nginx\" ]; then mkdir /var/temp/nginx -pfimake &amp;&amp; make installecho ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ls -al /usr/local/nginx## 修改nginx.conf配置文件file=\"/usr/local/nginx/conf/nginx.conf\"## 方法1: 不能重复使用, 端口重复问题#sed -i '1,/^[[:space:]]*listen.*/s/^[[:space:]]*listen.*/\\tlisten 8080;/' $file#sed -i -e \"/#gzip on;/a\\\\\\t&#125;\" $file#sed -i -e \"/#gzip on;/a\\\\\\t\\t&#125;\" $file#sed -i -e \"/#gzip on;/a\\\\\\t\\tngx_fastdfs_module;\" $file#sed -i -e \"/#gzip on;/a\\\\\\tlocation /group1/M00/&#123;\" $file#sed -i -e \"/#gzip on;/a\\\\\\tserver_name localhost;\" $file#sed -i -e \"/#gzip on;/a\\\\\\tlisten 80;\" $file#sed -i -e \"/#gzip on;/a\\\\\\tserver &#123;\" $file## 方法2: 直接覆盖echo \"#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '\\$remote_addr - \\$remote_user [\\$time_local] \\\"\\$request\\\" ' # '\\$status \\$body_bytes_sent \\\"\\$http_referer\\\" ' # '\\\"\\$http_user_agent\\\" \\\"\\$http_x_forwarded_for\\\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; location /group1/M00/ &#123; ngx_fastdfs_module; &#125; &#125; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts\\$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125;\" &gt; $file## 启动nginx/usr/local/nginx/sbin/nginx# --- 启动 fast DFS------#Tracker启动命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf#Storage启动命令：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf## 测试配置#第一步：进入/etc/fdfs/ 目录，拷贝一份client.conf文件cd /etc/fdfscp client.conf.sample client.conf# 第二步：修改client.conf#base_path=/usr/local/fastdfs/client#tracker_server=192.168.242.140:22122ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`sed -i '/^base_path/s/^/#/' /etc/fdfs/client.confsed -i '/^#base_path/a\\\\base_path=\\/usr\\/local\\/fastdfs\\/client' /etc/fdfs/client.confsed -i '/^tracker_server/s/^/#/' /etc/fdfs/client.confsed -i \"/^#tracker_server/a\\\\tracker_server=$ipaddr:22122\" /etc/fdfs/client.confif [ ! -d \"/usr/local/fastdfs/client\" ]; then mkdir /usr/local/fastdfs/client -pfi############################################### 上传图片1234#图片上传scp /Users/stone/Pictures/sucai/android/9.jpg root@172.16.124.137:/home/tomcat.jpg# 返回图片地址 浏览器访问 测试上传123456789#home目录下得有tomcat.png图片.../usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/tomcat.jpg# 上传成功的话 返回图片下载路径# 由于现在还没有和nginx整合无法使用http下载#http://192.168.101.3/group1/M00/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png就是文件的下载访问路径。#对应storage服务器上的磁盘路径：#/usr/local/fastdfs/storage/data/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png文件 解决VMware克隆虚拟机无法上网123456789101112#!/bin/bashsudo sed -i '/eth0/s/^/#/' /etc/udev/rules.d/70-persistent-net.rulessudo sed -i '/eth1/s/eth1/eth0/' /etc/udev/rules.d/70-persistent-net.rules#sudo rebootcat /etc/udev/rules.d/70-persistent-net.rules | grep eth0success=\"可以重启了， 执行命令 sudo reboot\"echo -e \"\\033[0;32;1m$success\\033[0m\" html测试12345678910111213141516171819&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" pageEncoding=\"UTF-8\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath &#125;/pic/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 选择文件:&lt;input type=\"file\" name=\"uploadFile\" width=\"120px\"&gt; &lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;%--&lt;form action=\"$&#123;pageContext.request.contextPath &#125;/file/down.do\" method=\"get\"&gt;--%&gt; &lt;%--&lt;input type=\"submit\" value=\"下载\"&gt;--%&gt; &lt;%--&lt;/form&gt;--%&gt; &lt;/body&gt; &lt;/body&gt;&lt;/html&gt; PicController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.stone.sncodetools.web.controller;import com.stone.sncodetools.utils.FastDFSClient;import com.stone.sncodetools.utils.JsonUtils;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import java.util.HashMap;import java.util.Map;/** * Created by stone on 2018/2/11. */@Controller@RequestMapping(\"/pic\")public class PicController &#123; @Value(\"$&#123;imageBaseUrl&#125;\") private String imageBaseUrl; /*@RequestMapping(value = \"/upload\") @ResponseBody public Map&lt;String, Object&gt; upload(MultipartFile uploadFile) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); if (uploadFile == null) &#123; map.put(\"error\", 1); map.put(\"message\", \"文件对象为空\"); return map; &#125; String originalFilename = uploadFile.getOriginalFilename(); if (StringUtils.isBlank(originalFilename)) &#123; map.put(\"error\", 1); map.put(\"message\", \"文件对象为空\"); return map; &#125; // 获取文件扩展名 (扩展名不带点) String extName = originalFilename.substring(originalFilename.lastIndexOf(\".\") + 1); // 执行上传 try &#123; String uploadFileId = FastDFSClient.uploadFile(uploadFile.getBytes(), extName); //组装完整图片访问URL String url = imageBaseUrl + uploadFileId; System.out.println(url); map.put(\"error\", 0); map.put(\"url\", url); return map; &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(\"error\", 1); map.put(\"message\", \"上传失败\"); return map; &#125; &#125;*/ //为了ie 火狐 兼容性 不能返回json @RequestMapping(value = \"/upload\") @ResponseBody // ResponseBody作用 对象转json , raw数据返回, 不去找资源 public String upload(MultipartFile uploadFile) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); if (uploadFile == null) &#123; map.put(\"error\", 1); map.put(\"message\", \"文件对象为空\"); return JsonUtils.objectToJson(map); &#125; String originalFilename = uploadFile.getOriginalFilename(); if (StringUtils.isBlank(originalFilename)) &#123; map.put(\"error\", 1); map.put(\"message\", \"文件对象为空\"); return JsonUtils.objectToJson(map); &#125; // 获取文件扩展名 (扩展名不带点) String extName = originalFilename.substring(originalFilename.lastIndexOf(\".\") + 1); System.out.println(uploadFile); // 执行上传 try &#123; String uploadFileId = FastDFSClient.uploadFile(uploadFile.getBytes(), extName); //组装完整图片访问URL String url = imageBaseUrl + uploadFileId; System.out.println(url); map.put(\"error\", 0); map.put(\"url\", url); System.out.println(JsonUtils.objectToJson(map)); return JsonUtils.objectToJson(map); &#125; catch (Exception e) &#123; e.printStackTrace(); map.put(\"error\", 1); map.put(\"message\", \"upload faild\"); return JsonUtils.objectToJson(map); &#125; &#125;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/categories/Linux/"}],"tags":[{"name":"fastDFS & nginx综合","slug":"fastDFS-nginx综合","permalink":"http://pro.stonepark.fun/tags/fastDFS-nginx综合/"}]},{"title":"sso","slug":"sso","date":"2018-02-24T16:58:58.000Z","updated":"2018-02-24T16:59:31.000Z","comments":true,"path":"2018/02/25/sso/","link":"","permalink":"http://pro.stonepark.fun/2018/02/25/sso/","excerpt":"","text":"md5加密1DigestUtils.md5DigestAsHex(user.getPassword().getBytes()); redis不进入查询1./redis-cli -p 7003 -c --raw hget token:86870f61-619c-4f5a-86f9-ac739dc404e3 user 查询有效期1./redis-cli -p 7003 -c --raw ttl token:86870f61-619c-4f5a-86f9-ac739dc404e3","categories":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/categories/Linux/"}],"tags":[{"name":"sso","slug":"sso","permalink":"http://pro.stonepark.fun/tags/sso/"}]},{"title":"google搜索","slug":"google搜索","date":"2018-02-23T16:29:45.000Z","updated":"2018-02-23T16:30:41.000Z","comments":true,"path":"2018/02/24/google搜索/","link":"","permalink":"http://pro.stonepark.fun/2018/02/24/google搜索/","excerpt":"","text":"搜索特殊符号http://symbolhound.com/ 程序员的搜索引擎： SymbolHound is a search engine that doesn’t ignore special characters. This means you can easily search for symbols like &amp;, %, and π. We hope SymbolHound will help programmers find information about their chosen languages and frameworks more easily. google搜索特殊符号加个中括号1如: xargs [-o] 优化网页搜索您可以在搜索中使用符号或单词以使搜索结果更加精确。 Google搜索通常会忽略不属于搜索运算符的标点符号。 不要在符号或单词与搜索词之间放置空格。搜索site:nytimes.com 将起作用，但site: nytimes.com 不会。 常见的搜索技术搜索社交媒体1放在@一个词前面搜索社交媒体。例如：@twitter。 搜索价格1放在$ 一个数字前面。例如：camera $400。 搜索主题标签1放在# 一个字的前面。例如：#throwbackthursday 从搜索中排除单词1放在- 你想离开的单词前面。例如，jaguar speed -car 搜索完全匹配1在引号中加入单词或短语。例如，&quot;tallest building&quot;。 搜索通配符或未知单词1* 在你想留下占位符的地方放上你的单词或短语。例如，&quot;largest * in the world&quot;。 在数字范围内搜索1放在.. 两个数字之间。例如，camera $50..$100。 合并搜索1OR在每个搜索查询之间放置“ ”。例如， marathon OR race。 搜索特定的网站1将“ site:”放在网站或域名的前面。例如，site:youtube.com 或 site:.gov。 搜索相关网站1把“ related:”放在你已经知道的网址前面。例如，related:time.com。 获取有关网站的详细信息1将“ info:”放在网站地址的前面。 查看Google的网站缓存版本1将“ cache:”放在网站地址的前面。","categories":[{"name":"搜索","slug":"搜索","permalink":"http://pro.stonepark.fun/categories/搜索/"}],"tags":[{"name":"google","slug":"google","permalink":"http://pro.stonepark.fun/tags/google/"}]},{"title":"xargs","slug":"xargs","date":"2018-02-23T15:28:51.000Z","updated":"2018-02-23T15:50:01.000Z","comments":true,"path":"2018/02/23/xargs/","link":"","permalink":"http://pro.stonepark.fun/2018/02/23/xargs/","excerpt":"","text":"参数简介12345678910111213-0 用\\0分割字符串 , 主要和find -print0配合, 能操作不规范文件名的文件 如: 1 log.txt (有空格的文件名)-E 自定义结束标记 , 找到该标记之后 后面的内容就不读入了-I 给拿到的每一行数据起个别名 如: find . -type f -name \"*.png\" | xargs -I @ echo @-J 和I差不多, BSD shell 独有, GNU shell没有-L 一次读取多少行-n 一次选中多少行, 和-L差不多-o 没查到资料-P 没查到资料-p 没查到资料-R 没查到资料-s 没查到资料-t 显示命令, 调试用的-x 没查到资料 sed 单引号获取变量值的写法12345sed -i &quot;&quot; &apos;s/regex/replace/g&apos; filesed -i &quot;&quot; &apos;s/regex/&apos;&quot;$&#123;var&#125;&quot;&apos;/g&apos; fileYeah, in mac should use -I, e.g. redis-cli keys &apos;foo*&apos; | xargs -I @ echo @ linux &amp; mac xargs区别12345# linuxbasename -s .JPG -a *.JPG | xargs -n1 -i mv &#123;&#125;.JPG &#123;&#125;.jpg# macbasename -s .JPG -a *.JPG | xargs -n1 -I &#123;&#125; mv &#123;&#125;&quot;.JPG&quot; &#123;&#125;&quot;.jpg&quot; 真对有空格的文件名的解决办法1find . -type f -name &quot;*.png&quot; -print0 | xargs -0 -L 1 -I @ echo @ 参考:http://www.jb51.net/LINUXjishu/205761.html mac -J -I 都能用 效果差不多 , 为了和 Linux统一还是用-I吧 参考:https://superuser.com/questions/529742/how-can-i-move-files-with-xargs-on-linux/529744https://unix.stackexchange.com/questions/407634/xargs-j-option -n 与 -L的区别123456789find . -type f -name &quot;*.png&quot; -print0 | xargs -0 -L 2 -t echo#-L 从标准输入一次读取num行送给Command命令echo ./下载 (1).png ./下载 (2).png./下载 (1).png ./下载 (2).pngecho ./下载.png ./图片 1.png./下载.png ./图片 1.pngecho ./图片 21.png./图片 21.png 12find . -type f -name &quot;*.png&quot; -print0 | xargs -0 -n5 -t open# -n 相当于 多选, 当-n5的时候 图片不是一个个打开, 会打开成 列表 参考:http://blog.163.com/squall_smile/blog/static/603498402013122570281/","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"xargs","slug":"xargs","permalink":"http://pro.stonepark.fun/tags/xargs/"}]},{"title":"Freemarker ★★★★★","slug":"Freemarker-★★★★★","date":"2018-02-23T13:40:01.000Z","updated":"2018-02-24T11:01:07.000Z","comments":true,"path":"2018/02/23/Freemarker-★★★★★/","link":"","permalink":"http://pro.stonepark.fun/2018/02/23/Freemarker-★★★★★/","excerpt":"","text":"简介 FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本并输出。FreeMarker不仅可以用作表现层的实现技术，类似于JSP的功能一样，而且还可以用于生成XML、HTML、JSP或Java源代码等文件。目前企业中:主要用Freemarker做静态页面或是页面展示。 同类产品 velocity Template：即模板，是以ftl为后缀的文件，类似于JSP的编写，拥有专门的模板语言FTL。Java Objects：即数据，可以是简单类型（String，Number，Date），或者POJO、Map、List等对象。Output：即文本输出，模板填充上数据之后，将会被模板对象通过输出流写成html文件或者其他文件。 总结：模板+数据 = 输出 pom123456&lt;!-- https://mvnrepository.com/artifact/org.freemarker/freemarker --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt; jsp转ftl12拷贝jsp文件到 ftl文件夹下, 并进入,执行以下脚本# jsp文件转ftl 生成html文件 shell_1 普通处理12345678910111213141516171819202122232425for var in `find $PWD -type f -name \"*.jsp\"`do echo $var var_destination=`echo $var | sed -e 's/.jsp/.ftl/'` echo $var_destination sed -e '/&lt;%@.*/d' -e '/.*%&gt;/d' -e '/&lt;jsp:include/&#123;s/jsp:/#/;s/page=//;s/.jsp/.ftl/;s/&gt;&lt;\\/jsp:include&gt;/\\/&gt;/;&#125;' $var &gt; $var_destination grep -n \"&lt;c:\" $var_destination if [ $? -eq 0 ];then echo -e \"\\033[0;33;1m注意!!!注意!!! `echo $var_destination` 中有【&lt;c:】标签\\033[0m\" grep -n \"&lt;fmt:\" $var_destination if [ $? -eq 0 ];then echo -e \"\\033[0;33;1m注意!!!注意!!! `echo $var_destination` 中有【&lt;fmt:】标签\\033[0m\" fi else echo -e \"\\033[0;32;1m`echo $var_destination` 修改完成 \\033[0m\" grep -n \"&lt;fmt:\" $var_destination if [ $? -eq 0 ];then echo -e \"\\033[0;33;1m注意!!!注意!!! `echo $var_destination` 中有【&lt;fmt:】标签\\033[0m\" else echo -e \"\\033[0;32;1m`echo $var` 修改完成 \\033[0m\" fi fidone shell_2 逻辑处理(只能手动)123456789101112131415161718for var in `find $PWD -type f -name \"*.ftl\"`do grep -n \"&lt;c:\" $var if [ $? -eq 0 ];then echo -e \"\\033[0;33;1m注意!!!注意!!! `echo $var` 中有【&lt;c:】标签\\033[0m\" grep -n \"&lt;fmt:\" $var if [ $? -eq 0 ];then echo -e \"\\033[0;33;1m注意!!!注意!!! `echo $var` 中有【&lt;fmt:】标签\\033[0m\" fi else grep -n \"&lt;fmt:\" $var if [ $? -eq 0 ];then echo -e \"\\033[0;33;1m注意!!!注意!!! `echo $var` 中有【&lt;fmt:】标签\\033[0m\" else echo -e \"\\033[0;32;1m`echo $var` 修改完成 \\033[0m\" fi fidone MAC OS查看端口占用情况1sudo lsof -i :9000 参考:http://blog.csdn.net/zkp0601/article/details/49765289 SPEL 调用类方法1Configuration configuration = new Configuration(Configuration.getVersion()); 1234&lt;bean id=\"configuration\" class=\"freemarker.template.Configuration\"&gt; &lt;!--&lt;constructor-arg name=\"incompatibleImprovements\" value=\"2.3.23\"/&gt;--&gt; &lt;constructor-arg name=\"incompatibleImprovements\" value='#&#123; T(freemarker.template.Configuration).getVersion()&#125;'/&gt;&lt;/bean&gt; 参考:https://stackoverflow.com/questions/7585627/calling-static-methods-from-spring-security-expressionshttp://blog.csdn.net/zhangguo5/article/details/62423345 freemarker 特殊符号 输出参考:http://blog.csdn.net/achilles12345/article/details/41820507 1$&#123;r&apos;$&#123;obj.name&#125;&apos;&#125;，这样最终显示的结果就是：$&#123;obj.name&#125;，而不会被freemarker解析。这里要注意，前边那个标红的“r”字符是关键点。 12sed -e '/&lt;jsp:include/&#123;s/jsp:/#/;s/page=//;&#125;' item.jsp &gt; item.ftl# 注：如果需要使用多条命令，或者需要在某个地址范围内嵌套地址，就必须用花括号将命令括起来，每行只写一条命令，或这用分号分割同一行中的多条命令。","categories":[{"name":"freemarker","slug":"freemarker","permalink":"http://pro.stonepark.fun/categories/freemarker/"}],"tags":[{"name":"freemarker","slug":"freemarker","permalink":"http://pro.stonepark.fun/tags/freemarker/"}]},{"title":"ActiveMQ","slug":"ActiveMQ","date":"2018-02-22T18:17:47.000Z","updated":"2018-02-22T18:22:28.000Z","comments":true,"path":"2018/02/23/ActiveMQ/","link":"","permalink":"http://pro.stonepark.fun/2018/02/23/ActiveMQ/","excerpt":"","text":"安装&amp;配置12345678910111213141516171819202122#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/apache-activemq-5.12.0-bin.tar.gz\"if [ ! -d \"/usr/local/activemq\" ]; then mkdir /usr/local/activemqficp $HOME/soft/apache-activemq-5.12.0-bin.tar.gz /usr/local/activemqcd /usr/local/activemqtar -zxvf apache-activemq-5.12.0-bin.tar.gz/usr/local/activemq/apache-activemq-5.12.0/bin/activemq start# 默认端口 8161# http://172.16.124.134:8161/admin# 默认账号密码 admin admin 访问出错问题解决访问ActiveMQ后台管理系统出现Service Unavailable，解决步骤如下： 第一步：停止ActiveMQ1/root/apache-activemq-5.12.0/bin/activemq stop 第二步：查看ActiveMQ后台1/root/apache-activemq-5.12.0/bin/activemq console 找出错误：主机名未能正确解析 第三步：修改hosts文件，将主机名称添加hosts文件中。1vim /etc/hosts 第四步：重启虚拟机。 activeMQ的两个默认端口8161和61616的区别http://ask.csdn.net/questions/672298 8161是后台管理系统，61616是给java用的tcp端口 一般是没关联，只是面向不同的服务而已。 就跟一个Linux开启的21和22端口一样。 ActiveMQ问题分析 生产者发送消息到broker失败了，怎么办？ 在生产者本身业务逻辑中，添加日志记录（要记录消息目的地以及发送的信息内容） 开发一段代码或者一个功能点，去实现重新发送消息的功能。 broker接收消息之后，服务器挂掉，怎么办？ 搭建ActiveMQ集群 对消息持久化 消费者从broker，将消息接收到之后，业务处理失败怎么办？ 在消费者本身业务逻辑中，添加日志记录（要记录接收到的消息以及信息目的地） 要分析业务处理失败的原因，并改正 重新编写消息处理代码，去重新处理。 消费者从broker，没有成功消费消息？ 重新执行单元测试代码或者功能去接收指定消息。 ActiveMQ集群 安装&amp;配置123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bash#wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/apache-activemq-5.12.0-bin.tar.gz\"if [ ! -d \"/usr/local/activemq-cluster\" ]; then mkdir /usr/local/activemq-clusterficp $HOME/soft/apache-activemq-5.12.0-bin.tar.gz /usr/local/activemq-clustercd /usr/local/activemq-clustertar -zxvf apache-activemq-5.12.0-bin.tar.gzmv apache-activemq-5.12.0 mq-01sed -E -i -e 's/&lt;property name=\"port\" value=\"[0-9]&#123;4&#125;\"\\/&gt;/&lt;property name=\"port\" value=\"8162\"\\/&gt;/g' /usr/local/activemq-cluster/mq-01/conf/jetty.xmlsed -i -e '/&lt;transportConnector .*\\/&gt;/d' /usr/local/activemq-cluster/mq-01/conf/activemq.xmlsed -i -e '/&lt;transportConnectors&gt;/a\\'$'\\n&lt;transportConnector name=\"openwire\" uri=\"tcp:\\/\\/0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600\"\\/&gt;' /usr/local/activemq-cluster/mq-01/conf/activemq.xmlsed -i -e '/&lt;broker xmlns/a\\\\&lt;networkConnectors&gt;\\ &lt;networkConnector uri=\"static:(tcp:\\/\\/127.0.0.1:61618)\" duplex=\"true\"\\/&gt;\\&lt;\\/networkConnectors&gt;' /usr/local/activemq-cluster/mq-01/conf/activemq.xmlcd /usr/local/activemq-clustercp mq-01 mq-02 -rsed -i -e '/networkConnector/d' /usr/local/activemq-cluster/mq-02/conf/activemq.xmlsed -E -i -e '/transportConnector name/s/0.0.0.0:[0-9]&#123;5&#125;/0.0.0.0:61618/' /usr/local/activemq-cluster/mq-02/conf/activemq.xmlsed -E -i -e 's/&lt;property name=\"port\" value=\"[0-9]&#123;4&#125;\"\\/&gt;/&lt;property name=\"port\" value=\"8163\"\\/&gt;/g' /usr/local/activemq-cluster/mq-02/conf/jetty.xml# 启动/usr/local/activemq-cluster/mq-01/bin/activemq start /usr/local/activemq-cluster/mq-02/bin/activemq start col命令1234567# Linux col命令用于过滤控制字符。#在许多UNIX说明文件里，都有RLF控制字符。当我们运用shell特殊字符\"&gt;\"和\"&gt;&gt;\"，把说明文件的内容输出成纯文本文件时，控制字符会变成乱码，col指令则能有效滤除这些控制字符。man grep | col -b# -b 过滤掉所有的控制字符，包括RLF和HRLF。 坑12sed -ie '/networkConnector/d' activemq.xml# 写成这样和GNU shell 一样了...BSD shell maven工程用 Favorites管理…配合快捷键 ⌥F1 快速定位 awk gsub &amp; sub使用, 着色1awk '/\\$&#123;.*&#125;/&#123;gsub(/\\$&#123;[a-z.= 0-9]+&#125;/,\"\\033[0;31;1m&amp;\\033[0m\");print&#125;' ./e3-item-web/src/main/webapp/WEB-INF/jsp/item.jsp reids ttl命令查看对象生命剩余时间 redis查询中文1./redis-cli -p 7003 -c --raw get item:151931160828312 | sed 's/[a-zA-Z0-9[:punct:]]//g' | grep -v '^$' 参考:http://blog.csdn.net/u010627840/article/details/41863395","categories":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/categories/Linux/"}],"tags":[{"name":"ActiveMQ","slug":"ActiveMQ","permalink":"http://pro.stonepark.fun/tags/ActiveMQ/"}]},{"title":"solr","slug":"solr","date":"2018-02-21T11:57:37.000Z","updated":"2018-02-21T12:00:41.000Z","comments":true,"path":"2018/02/21/solr/","link":"","permalink":"http://pro.stonepark.fun/2018/02/21/solr/","excerpt":"","text":"安装&amp;配置 (提前安装JDK&amp;tomcat)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/solr-4.10.3.tgz.tgz\"cd ~/softif [ ! -d \"/usr/local/solr\" ]; then mkdir /usr/local/solrficp apache-tomcat-7.0.79.tar.gz /usr/local/solr cp solr-4.10.3.tgz.tgz /usr/local/solrtar -zxvf apache-tomcat-7.0.79.tar.gztar -zxvf solr-4.10.3.tgz.tgzcp solr-4.10.3/example/solr /usr/local/solr/solrhome -rcp solr-4.10.3/example/webapps/solr.war /usr/local/solr/apache-tomcat-7.0.79/webapps/ # ================ 解压war包 ================var=/usr/local/solr/apache-tomcat-7.0.79/webapps/solr.wartmp=$&#123;var##*/&#125;path=$&#123;tmp%.*&#125;if [ ! -d \"/usr/local/solr/apache-tomcat-7.0.79/webapps/$path\" ]; then mkdir /usr/local/solr/apache-tomcat-7.0.79/webapps/$pathfiunzip -oq $var -d /usr/local/solr/apache-tomcat-7.0.79/webapps/$pathrm -f $var# ============================================if [ ! -d \"/usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/classes\" ]; then mkdir /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/classesficp solr-4.10.3/example/resources/log4j.properties /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/classes/cp solr-4.10.3/example/lib/ext/* /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/lib/sed -i -e '/&lt;\\/env-entry&gt;/&#123;n;d;&#125;' /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/web.xml # 后一行sed -i -e '$!N;s/.*\\n\\(.*&lt;env-entry&gt;\\)/\\1/' -e 'P;D;' /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/web.xml #前一行sed -i -e 's/\\/put\\/your\\/solr\\/home\\/here/\\/usr\\/local\\/solr\\/solrhome/g' /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/web.xml########################serverpath=\"/usr/local/solr/apache-tomcat-7.0.79/conf/server.xml\"val=\"1\"sed -i \"s/&lt;Server port=\\\"8005\\\"/&lt;Server port=\\\"80`echo $val`5\\\"/g\" $serverpathsed -i \"s/&lt;Connector port=\\\"8080\\\"/&lt;Connector port=\\\"808`echo $val`\\\"/g\" $serverpathsed -i \"s/&lt;Connector port=\\\"8009\\\"/&lt;Connector port=\\\"80`echo $val`9\\\"/g\" $serverpathwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/IK%20Analyzer%202012FF_hf1.zip\"cp $HOME/soft/IK\\ Analyzer\\ 2012FF_hf1.zip /usr/local/solr/cd /usr/local/solrunzip IK\\ Analyzer\\ 2012FF_hf1.zipcd IK\\ Analyzer\\ 2012FF_hf1cp IKAnalyzer2012FF_u1.jar /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/libcp IKAnalyzer.cfg.xml /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/classescp *.dic /usr/local/solr/apache-tomcat-7.0.79/webapps/solr/WEB-INF/classesschemafile=\"/usr/local/solr/solrhome/collection1/conf/schema.xml\"sed -i -e 's/^&lt;\\/schema&gt;//' $schemafileprintf '&lt;!-- IKAnalyzer--&gt;&lt;fieldType name=\"text_ik\" class=\"solr.TextField\"&gt; &lt;analyzer class=\"org.wltea.analyzer.lucene.IKAnalyzer\"/&gt;&lt;/fieldType&gt;### 不同项目得修改...&lt;!-- 商品名称 --&gt;&lt;field name=\"item_title\" type=\"text_ik\" indexed=\"true\" stored=\"true\"/&gt; &lt;!-- 商品卖点 --&gt;&lt;field name=\"item_sell_point\" type=\"text_ik\" indexed=\"true\" stored=\"false\"/&gt;&lt;!-- 商品分类名称 --&gt;&lt;field name=\"item_category_name\" type=\"string\" indexed=\"true\" stored=\"false\"/&gt; &lt;!-- 商品价格 --&gt;&lt;field name=\"item_price\" type=\"long\" indexed=\"true\" stored=\"true\"/&gt; &lt;!-- 商品描述 --&gt;&lt;field name=\"item_description\" type=\"text_ik\" indexed=\"true\" stored=\"false\"/&gt; &lt;!-- 商品图片地址 --&gt;&lt;field name=\"item_image\" type=\"string\" indexed=\"false\" stored=\"true\"/&gt; &lt;!-- 目标域--&gt;&lt;field name=\"item_keywords\" type=\"text_ik\" indexed=\"true\" stored=\"false\" multiValued=\"true\"/&gt; &lt;!-- 将商品名称添加到目标域--&gt;&lt;copyField source=\"item_title\" dest=\"item_keywords\"/&gt;&lt;!-- 将商品卖点添加到目标域--&gt;&lt;copyField source=\"item_sell_point\" dest=\"item_keywords\"/&gt;&lt;!-- 将商品描述添加到目标域--&gt;&lt;copyField source=\"item_description\" dest=\"item_keywords\"/&gt;' &gt;&gt; $schemafileecho -e \"\\n\\n&lt;/schema&gt;\" &gt;&gt; $schemafile/usr/local/solr/apache-tomcat-7.0.79/bin/startup.sh Solrcloud 安装&amp;配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/zookeeper-3.4.6.tar.gz\"wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/apache-tomcat-7.0.79.tar.gz\"wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/solr-4.10.3.tgz.tgz\"# zookeepr 集群搭建if [ ! -d \"/usr/local/solrcloud\" ]; then mkdir /usr/local/solrcloudficd ~/softcp zookeeper-3.4.6.tar.gz /usr/local/solrcloudcd /usr/local/solrcloudtar -zxvf zookeeper-3.4.6.tar.gz mv zookeeper-3.4.6 zk1cd zk1/confcp zoo_sample.cfg zoo.cfgsed -i -e 's/^dataDir=.*/dataDir=\\/usr\\/local\\/solrcloud\\/zk1\\/data/g' zoo.cfgsed -i -e 's/^clientPort=.*/clientPort=2281/g' zoo.cfgipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\" | head -n 1`echo -e \"\\n\\n#集群中每台机器都是以下配置#2881系列端口是zookeeper通信端口#3881系列端口是zookeeper投票选举端口server.1=$&#123;ipaddr&#125;:2881:3881server.2=$&#123;ipaddr&#125;:2882:3882server.3=$&#123;ipaddr&#125;:2883:3883\" &gt;&gt; zoo.cfg# 创建data目录if [ ! -d \"/usr/local/solrcloud/zk1/data\" ]; then mkdir /usr/local/solrcloud/zk1/datafiecho \"1\" &gt; /usr/local/solrcloud/zk1/data/myid# 复制cd /usr/local/solrcloudcp -r zk1 zk2cp -r zk1 zk3 sed -i -e 's/^dataDir=.*/dataDir=\\/usr\\/local\\/solrcloud\\/zk2\\/data/g' -e 's/^clientPort=.*/clientPort=2282/g' /usr/local/solrcloud/zk2/conf/zoo.cfgecho \"2\" &gt; /usr/local/solrcloud/zk2/data/myidsed -i -e 's/^dataDir=.*/dataDir=\\/usr\\/local\\/solrcloud\\/zk3\\/data/g' -e 's/^clientPort=.*/clientPort=2283/g' /usr/local/solrcloud/zk3/conf/zoo.cfgecho \"3\" &gt; /usr/local/solrcloud/zk3/data/myid/usr/local/solrcloud/zk1/bin/zkServer.sh restart/usr/local/solrcloud/zk2/bin/zkServer.sh restart/usr/local/solrcloud/zk3/bin/zkServer.sh restart# 查看是否启动成功ps -ef | grep zook | grep solr | grep -e 'zk[0-9]/bin'# 查看状态/usr/local/solrcloud/zk1/bin/zkServer.sh status/usr/local/solrcloud/zk2/bin/zkServer.sh status/usr/local/solrcloud/zk3/bin/zkServer.sh status# solr 集群搭建# solrcloud启动之前, 需要先启动 zookeeper集群.cd /usr/local/solrcloud# 如果没有安装单机版的solr就下载配置好的solr#wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/solr_tomcat.zip\"cp /usr/local/solr/apache-tomcat-7.0.79 ./tomcat8280 -rcp /usr/local/solr/apache-tomcat-7.0.79 ./tomcat8380 -rcp /usr/local/solr/apache-tomcat-7.0.79 ./tomcat8480 -rcp /usr/local/solr/apache-tomcat-7.0.79 ./tomcat8580 -r# 修改 server.xmlpath=\"/usr/local/solrcloud\"names=(\"2\" \"3\" \"4\" \"5\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do file=$&#123;path&#125;/tomcat8$&#123;names[$i]&#125;80/conf/server.xml echo $file sed -i -e \"/&lt;Server port=\\\".*\\\" shutdown=\\\"SHUTDOWN\\\"&gt;/s/[0-9]\\&#123;4\\&#125;/8$&#123;names[$i]&#125;05/g\" \\ -e \"/&lt;Connector port=\\\".*\\\" protocol=\\\"AJP\\/1.3\\\" redirectPort=\\\"8443\\\" \\/&gt;/s/[0-9]\\&#123;4\\&#125;/8$&#123;names[$i]&#125;09/g\" \\ -e \"/&lt;Connector port=\\\".*\\\" protocol=\\\"HTTP\\/1.1\\\"/s/[0-9]\\&#123;4\\&#125;/8$&#123;names[$i]&#125;80/g\" $filedonecd /usr/local/solrcloudcp -r /usr/local/solr/solrhome ./solrhome8280cp -r /usr/local/solr/solrhome ./solrhome8380cp -r /usr/local/solr/solrhome ./solrhome8480cp -r /usr/local/solr/solrhome ./solrhome8580# 修改web.xmlpath=\"/usr/local/solrcloud\"names=(\"2\" \"3\" \"4\" \"5\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do file=$&#123;path&#125;/tomcat8$&#123;names[$i]&#125;80/webapps/solr/WEB-INF/web.xml echo $file sed -i -e \"/&lt;env-entry-value&gt;.*&lt;\\/env-entry-value&gt;/s/&lt;env-entry-value&gt;.*&lt;\\/env-entry-value&gt;/&lt;env-entry-value&gt;\\/usr\\/local\\/solrcloud\\/solrhome8$&#123;names[$i]&#125;80&lt;\\/env-entry-value&gt;/g\" $filedone# 修改solrhome下的 solr.xmlipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\" | head -n 1`path=\"/usr/local/solrcloud\"names=(\"2\" \"3\" \"4\" \"5\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do file=$&#123;path&#125;/solrhome8$&#123;names[$i]&#125;80/solr.xml echo $file sed -i -e \"s/&lt;str name=\\\"host\\\"&gt;.*&lt;\\/str&gt;/&lt;str name=\\\"host\\\"&gt;$ipaddr&lt;\\/str&gt;/g\" \\ -e \"s/&lt;int name=\\\"hostPort\\\"&gt;.*&lt;\\/int&gt;/&lt;int name=\\\"hostPort\\\"&gt;8$&#123;names[$i]&#125;80&lt;\\/int&gt;/g\" $filedone# 修改 catalina.shipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\" | head -n 1`path=\"/usr/local/solrcloud\"names=(\"2\" \"3\" \"4\" \"5\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do file=$&#123;path&#125;/tomcat8$&#123;names[$i]&#125;80/bin/catalina.sh echo $file sed -i -e \"/^#JAVA_OPTS/a\\\\JAVA_OPTS=\\\"-DzkHost=$&#123;ipaddr&#125;:2281,$&#123;ipaddr&#125;:2282,$&#123;ipaddr&#125;:2283\\\"\" $filedone# 上传配置文件ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\" | head -n 1`/usr/local/solr/solr-4.10.3/example/scripts/cloud-scripts/zkcli.sh -zkhost $&#123;ipaddr&#125;:2281,$&#123;ipaddr&#125;:2282,$&#123;ipaddr&#125;:2283 -cmd upconfig -confdir /usr/local/solrcloud/solrhome8280/collection1/conf -confname myconf# 查看是否成功# /usr/local/solrcloud/zk1/bin/zkCli.sh -server $&#123;ipaddr&#125;:2281# ls / # ls /configs/myconf# 启动tomcat/usr/local/solrcloud/tomcat8280/bin/startup.sh/usr/local/solrcloud/tomcat8380/bin/startup.sh/usr/local/solrcloud/tomcat8480/bin/startup.sh/usr/local/solrcloud/tomcat8580/bin/startup.sh 集群分片1http://172.16.124.134:8280/solr/admin/collections?action=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2 删除collection1http://172.16.124.134:8280/solr/admin/collections?action=DELETE&amp;name=collection1 删除 匹配行的 前一行 &amp; 后一行12sed -i \"\" -e '/&lt;\\/env-entry&gt;/&#123;n;d;&#125;' web.xml # 后一行sed -i \"\" -e :a -e '$!N;s/.*\\n\\(.*&lt;env-entry&gt;\\)/\\1/;ta' -e 'P;D' web.xml #前一行 参考:https://unix.stackexchange.com/questions/152312/remove-multiple-lines-after-a-pattern-match-but-only-after-pattern-matchhttps://www.zhihu.com/question/26122927 python写的sed调试工具https://www.cnblogs.com/lemon-le/p/6061189.html shell 脚本中怎样将字符串转化为命令可以使用eval命令。eval命令，如同熟悉的其他脚本语言，会将它的参数做为命令执行。eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。这些需要进行两次扫描的变量有时候被称为复杂变量。命令格式：eval [参数]补充说明：eval可读取一连串的参数，然后再依参数本身的特性来执行。参数不限数目，彼此之间用分号分开。用法示例：将字符串变量s的值作为命令执行s=”ls”eval $s 1234grep --color=auto --exclude-dir=&#123;.bzr,CVS,.git,.hg,.svn&#125; -r -I $* .$* 以一个单字符串显示所有向脚本传递的参数。如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 参考:http://www.runoob.com/linux/linux-shell-passing-arguments.html 查看图片尺寸的命令参考:http://blog.csdn.net/u014295667/article/details/46876265http://www.webhek.com/post/get-image-dimensions-from-command-line.html 1brew install imagemagick maven项目下的 所有target目录大小的总和1find . -type d -name \"target\" | xargs -I &#123;&#125; du -s -k &#123;&#125; | awk '&#123;size=size+$1&#125;END&#123;print size&#125;'","categories":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/categories/Linux/"}],"tags":[{"name":"solr","slug":"solr","permalink":"http://pro.stonepark.fun/tags/solr/"}]},{"title":"sed高级用法(GHDNPD)","slug":"sed高级用法-GHDNPD","date":"2018-02-20T06:40:33.000Z","updated":"2018-02-20T06:40:57.000Z","comments":true,"path":"2018/02/20/sed高级用法-GHDNPD/","link":"","permalink":"http://pro.stonepark.fun/2018/02/20/sed高级用法-GHDNPD/","excerpt":"","text":"##How does the command sed ‘1!G;h;$!d’ reverse the contents of a file?参考:https://unix.stackexchange.com/questions/233014/how-does-the-command-sed-1ghd-reverse-the-contents-of-a-filehttp://blog.csdn.net/itsenlin/article/details/21129405 123456789#test.txt1234567 1sed '1!G;h;$!d' test.txt 1234d Delete pattern space. Start next cycle. 删除pattern space的内容，开始下一个循环.h、 H Copy/append pattern space to hold space. 复制/追加pattern space的内容到hold space.g、 G Copy/append hold space to pattern space. 复制/追加hold space的内容到pattern space.x Exchange the contents of the hold and pattern spaces. 交换hold space和pattern space的内容. 12345678910111213141516171819sed&apos;1！G; h; $！d&apos; 文件首先，sed拥有一个占有空间和一个模式空间。在专注于特定的命令之前，我们必须区分它们。当sed读取新行时，它被加载到模式空间中。因此，每次处理新行时都会覆盖该空间。另一方面，在整个处理过程中保持空间是一致的，并且值可以存储在那里供以后使用。以下命令：在这个语句中有3个命令：1!G，h和$!d1!G意味着该G命令在除第一行之外的每一行执行（!否定1）。G意味着将保存空间中的内容追加到模式空间中。h适用于每一行。它将模式空间复制到保留空间（并覆盖它）。$!d适用于除最后一行之外的每一行（$表示最后一行，!否定它）。d是删除行（模式空间）的命令。现在，读取第一行时，sed执行该h命令。第一行被复制到保存空间中。然后它被删除，因为它符合$!条件。sed继续第二行。第二行符合条件1!（不是第一行），因此保留空间（具有第一行）被附加到模式空间（具有第二行）。之后，在模式空间中，现在是第二行，后面跟着第一行，由换行符分隔。现在，该h命令适用（如在每行中）; 模式空间中的所有内容都被复制到保存空间。第三条语句（$!d）适用：该行将从模式空间中删除。第2步现在完成所有行。我们跳到最后一行。在最后一行（$）中，几乎全部步骤2完成，但不是删除部分（d）。sed，如果没有调用-n，则在每个输入行的处理结束时自动打印模式空间。所以，不删除时，模式空间打印。它现在包含所有倒行顺序的行。 sed’1!G; h; $!d’ 文件 1!G : 第一行不从保持空间中拿数据, 因为是空的h: 模式空间的数据 拷贝到 保持空间 , 是覆盖操作$!d: 不是最后一行就删除模式空间的内容, 因为读完一行 模式空间有内容sed就会输出 第一行操作 : 模式空间读入行数据, 1!G(满足);不从保持空间拿数据, h(满足) 模式空间内容拷贝到保持空间, $!d(满足)删除模式空间的内容 | 模式空间没数据 sed就不打印 第二行操作 : 模式空间读入行数据, 1!G(不满足,所以执行G);从保持空间拿数据(变成第二行\\n第一行), h(满足) 模式空间内容拷贝到保持空间, $!d(满足)删除模式空间的内容 | 模式空间没数据 sed就不打印 第三行操作 : 模式空间读入行数据, 1!G(不满足,所以执行G);从保持空间拿数据(变成第三行\\n第二行\\n第一行), h(满足) 模式空间内容拷贝到保持空间, $!d(满足)删除模式空间的内容 | 模式空间没数据 sed就不打印 … 最后一行操作: 模式空间读入行数据, 1!G(不满足,所以执行G);从保持空间拿数据(变成最后一行\\n…第三行\\n第二行\\n第一行), h(满足) 模式空间内容拷贝到保持空间, $!d(最后一行就不执行d)保留模式空间的内容 | 模式空间有数据 sed打印模式空间的数据 NPD命令参考:http://blog.csdn.net/heihuifeng/article/details/7943982 1234567891011再贴上N P D的解释：P：Print up to the first embedded newline of the current pattern space.(就是输出模式空间开头到第一个\\n之间的内容)D：If pattern space contains no newline, start a normal new cycle as if the d command was issued. Otherwise, delete text in the pattern space up to the first newline, and restart cycle with the resultant pattern space, without reading a new line of input.(是删除模式空间开头到第一个\\n(含)之间的内容，并且控制流跳到脚本的第一条语句。这里一定要注意这句话“and restart cycle with the resultant pattern space, without reading a new line of input.”，即它是在不改变当前行号的情况下，从头执行的。)这句话也充分的说明了，为什么很多人不愿意读中文翻译版书籍的原因。:-)N：Add a newline to the pattern space, then append the next line of input to the pattern space. If there is no more input then sed exits without processing any more commands.(追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。如果没有下一个可处理的行，则退出) 12345678d 删除资料。D 删除 pattern space 内第一个 newline 字母 / 前的资料。n 读入下一笔资料。N 添加下一笔资料到 pattern space。p 印出资料。P 印出 pattern space 内第一个 newline 字母 / 前的资料。 12345test.txt#123 1sed -E -ne '/#/!p' test.txt 打印:123 12# 在mac os ; -r 和 mac里的-E 一样 , mac中没有-rsed -E -e :a -e '$!N;/#/!s/\\n//;ta' -e 'P;D' test.txt 12# 在Linux ; -r 和 mac里的-E 一样 , mac中没有-rsed -r ':a;$!N;/#/!s/\\n/ /;ta;P;D' urfile -n 的作用By default, each line of input is echoed to the standard output after all of the commands have been applied to it. The -n option suppresses this behavior. 默认情况下，每一行输入都回显到标准输出。在所有的命令都被应用到它之后。-n选项抑制这种行为。 默认情况加 每一行都打印 只要模式空间中有数据 都打印,-n的作用是 取消这种行为, -n和p命令结合 选择性的打印… sed 打印行号1sed -ne '&#123;=;p;&#125;' web.xml | sed -E -e '$!N;s/\\n/ /'","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"sed","slug":"sed","permalink":"http://pro.stonepark.fun/tags/sed/"}]},{"title":"sed 删除空行","slug":"sed-删除空行","date":"2018-02-19T07:56:17.000Z","updated":"2018-02-19T07:57:13.000Z","comments":true,"path":"2018/02/19/sed-删除空行/","link":"","permalink":"http://pro.stonepark.fun/2018/02/19/sed-删除空行/","excerpt":"","text":"参考:http://blog.csdn.net/arganzheng/article/details/6261912 方法1:1sed -E -i \"\" -e \"/^[[:space:]]*$/d\" viewcontroller.m 方法2:1sed -E -i \"\" -e \"/^\\s*$/d\" viewcontroller.m AppCode中 正则表达式删除空行1^(?:[\\t ]*(?:\\r?\\n|\\r))+","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"sed","slug":"sed","permalink":"http://pro.stonepark.fun/tags/sed/"}]},{"title":"AppCode踩坑记","slug":"AppCode踩坑记","date":"2018-02-19T03:21:48.000Z","updated":"2018-02-19T14:41:23.000Z","comments":true,"path":"2018/02/19/AppCode踩坑记/","link":"","permalink":"http://pro.stonepark.fun/2018/02/19/AppCode踩坑记/","excerpt":"","text":"使用rightSideType() Default value 一定得填写点东西, 不然出不来 12/* $hashMap$ getType */$TYPE$ $entries$ = $hashMap$; hashMap 必须得先有值, 真坑…用注释接收值 AutoLayout中的Content Hugging 和 Content Compression Resistance参考:http://blog.csdn.net/yongyinmg/article/details/39526207 Content Hugging 和 Content Compression Resistance 这两个属性对有intrinsic content size的控件（例如button，label）非常重要。通俗的讲，具有intrinsic content size的控件自己知道（可以计算）自己的大小，例如一个label，当你设置text，font之后，其大小是可以计算到的。关于intrinsic content size官方的解释： Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.自定义视图通常具有它们显示的内容，而布局系统不知道这些内容。重写此方法允许自定义视图根据其内容与布局系统通信它想要的大小。这个内在的大小必须独立于内容框架，因为没有方法可以根据变化的高度动态地将更改的宽度传递给布局系统。 好了，了解了intrinsic content size的概念之后，下面就重点讨论Content Hugging 和 Content Compression Resistance了。 UIView中关于Content Hugging 和 Content Compression Resistance的方法有： 1234567- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis 大概的意思就是设置优先级的。 123Hugging priority 确定view有多大的优先级【阻止自己变大】。Compression Resistance priority 确定有多大的优先级【阻止自己变小】。 很抽象，其实content Hugging就是要维持当前view在它的optimal size(最佳的大小)（intrinsic content size固有内容尺寸），可以想象成给view添加了一个额外的width constraint，此constraint试图保持view的size不让其变【大】： view.width &lt;= optimal size(最佳的大小)1content Hugging 在合适的大小上 不想再变大 此constraint的优先级就是通过上面的方法得到和设置的，content Hugging默认为250. Content Compression Resistance就是要维持当前view在他的optimal size（intrinsic content size），可以想象成给view添加了一个额外的width constraint，此constraint试图保持view的size不让其变【小】： view.width &gt;= optimal size 此默认优先级为750.1Content Compression Resistance 在合适的大小上 不想再变小 代码设置 12UILayoutPriority priority = 751; [self.testLabel setContentCompressionResistancePriority:priority forAxis:UILayoutConstraintAxisVertical]; 代码块写法 自动获取变量名不好使…1234567891011121314UIImageView *iconImageView = (&#123; UIImageView *imageView = [[UIImageView alloc] init]; imageView.backgroundColor = [UIColor colorWithWhite:0.5 alpha:1.0]; NSString *path = [[NSBundle mainBundle] pathForResource:@\"aaa\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.image = image; [self.view addSubview:imageView]; imageView;&#125;);self.iconImageView = iconImageView; 在里面自动获取变量名直接跳到括号外…比如 [UIImage imageWithContentsOfFile:path]; 快捷键 取变量名 , AppCode修改 UIImageView * iconImageView 的变量名 真坑… 修改成…1234567891011121314UIImageView *iconImageView = nil;&#123; UIImageView *imageView = [[UIImageView alloc] init]; imageView.backgroundColor = [UIColor colorWithWhite:0.5 alpha:1.0]; NSString *path = [[NSBundle mainBundle] pathForResource:@\"aaa\" ofType:@\"jpg\"]; UIImage *image = [UIImage imageWithContentsOfFile:path]; imageView.image = image; [self.view addSubview:imageView]; iconImageView = imageView;&#125;self.iconImageView = iconImageView; key-value-observing 建议http://nshipster.com/key-value-observing/","categories":[{"name":"iOS","slug":"iOS","permalink":"http://pro.stonepark.fun/categories/iOS/"}],"tags":[{"name":"AppCode","slug":"AppCode","permalink":"http://pro.stonepark.fun/tags/AppCode/"}]},{"title":"shell 字符串截取","slug":"shell-字符串截取","date":"2018-02-18T07:09:19.000Z","updated":"2018-02-18T07:09:56.000Z","comments":true,"path":"2018/02/18/shell-字符串截取/","link":"","permalink":"http://pro.stonepark.fun/2018/02/18/shell-字符串截取/","excerpt":"","text":"1234567891011121314151617181920#假设有变量 var=http://www.aaa.com/123.htmvar=http://www.aaa.com/123.htm##1. # 号截取，删除左边字符，保留右边字符。#echo $&#123;var#*//&#125;#其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符##即删除 http://##结果是 ：www.aaa.com/123.htm##2. ## 号截取，删除左边字符，保留右边字符。#echo $&#123;var##*/&#125;###*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符##即删除 http://www.aaa.com/##结果是 123.htm 总结: 想删除左边的 先写上 */ 星号在左边就无脑 写个 #*/ (默认从左边开始扫描), 再用 加与不加# 来调整 从 左边开始扫描 还是从 右边开始扫描 1234567891011121314##3. %号截取，删除右边字符，保留左边字符#echo $&#123;var%/*&#125;#%/* 表示从右边开始，删除第一个 / 号及右边的字符##结果是：http://www.aaa.com##4. %% 号截取，删除右边字符，保留左边字符#echo $&#123;var%%/*&#125;#%%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符##结果是：http: 总结: 想删除右边的 先写上 /* 星号在左边就无脑 写个 %/* (默认从右边开始扫描), 再用 加与不加% 来调整 从 右边开始扫描 还是从 左边开始扫描 1234567891011121314151617181920212223242526272829#5. 从左边第几个字符开始，及字符的个数#echo $&#123;var:0:5&#125;#其中的 0 表示左边第一个字符开始，5 表示字符的总个数。##结果是：http:##6. 从左边第几个字符开始，一直到结束。#echo $&#123;var:7&#125;#其中的 7 表示左边第8个字符开始，一直到结束。##结果是 ：www.aaa.com/123.htm##7. 从右边第几个字符开始，及字符的个数#echo $&#123;var:0-7:3&#125;#其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。##结果是：123##8. 从右边第几个字符开始，一直到结束。#echo $&#123;var:0-7&#125;#表示从右边第七个字符开始，一直到结束。##结果是：123.htm##注：（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"字符串操作","slug":"字符串操作","permalink":"http://pro.stonepark.fun/tags/字符串操作/"}]},{"title":"sed grep awk 正则表达式","slug":"sed-grep-awk-正则表达式","date":"2018-02-18T01:49:24.000Z","updated":"2018-02-18T01:50:09.000Z","comments":true,"path":"2018/02/18/sed-grep-awk-正则表达式/","link":"","permalink":"http://pro.stonepark.fun/2018/02/18/sed-grep-awk-正则表达式/","excerpt":"","text":"12345678910# regular_express.txtecho \"Love your parents. We are too busy growing up yet we forget that they are already growing old——多关心一下自己的父母吧，我们总忙着自己成长，却忘了他们也在变老。 The moment you think about giving up,think of the reason why you held on so long——每当你想放弃的时候，想一想是什么支撑着你一路坚持。 I don't wanna be your 'number one' that implies there are a number two and maybe a number three. I want to be your only one——我不想做你的“第一”，因为那就意味着还有第二，第三……我只想做你的“唯一”。 Total umbrella for someone else if he, you're just not for him in the rain.——如果他总为别人撑伞，你又何苦非为他等在雨中。 Hold my hand,you won't get lost even with eyes closed. ——握住我的手，即使你閉上眼睛也不會迷路。 We never really grow up. We only learn how to act in public. ——我们从未真正长大，我们只是在别人面前学会了假装。 Each trauma, is another kind of maturity. ——每一种创伤，都是另一种成熟。Fortune favours the brave——运气往往眷顾勇敢的人。\" &gt; regular_express.txt sed regex1echo \"Love your parents. We are too busy growing up yet we forget that they are already growing old——多关心一下自己的父母吧，我们总忙着自己成长，却忘了他们也在变老。 \\n\\nThe moment you think about giving up,think of the reason why you held on so long——每当你想放弃的时候，想一想是什么支撑着你一路坚持。 \\n\\nI don't wanna be your 'number one' that implies there are a number two and maybe a number three. I want to be your only one——我不想做你的“第一”，因为那就意味着还有第二，第三……我只想做你的“唯一”。 \\n\\nTotal umbrella for someone else if he, you're just not for him in the rain.——如果他总为别人撑伞，你又何苦非为他等在雨中。 \\n\\nHold my hand,you won't get lost even with eyes closed. ——握住我的手，即使你閉上眼睛也不會迷路。 \\n\\nWe never really grow up. We only learn how to act in public. ——我们从未真正长大，我们只是在别人面前学会了假装。 \\n\\nEach trauma, is another kind of maturity. ——每一种创伤，都是另一种成熟。\\n\\nFortune favours the brave——运气往往眷顾勇敢的人。\" | sed -E -ne 's/\\\\n\\\\n/\\'$'\\n/g' -e \"p\" grep regex1grep -E -e \"\\b[a-z]&#123;5&#125;\\b\" regular_express.txt awk regex1awk '/[a-z]&#123;5&#125;/&#123;print FILENAME,NR,$0&#125;' $file | grep -E \"[a-z]&#123;5&#125;\"","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"regex","slug":"regex","permalink":"http://pro.stonepark.fun/tags/regex/"}]},{"title":"tr用法解析(macos环境BSD shell)","slug":"tr用法解析-macos环境BSD-shell","date":"2018-02-17T07:29:32.000Z","updated":"2018-02-17T07:34:40.000Z","comments":true,"path":"2018/02/17/tr用法解析-macos环境BSD-shell/","link":"","permalink":"http://pro.stonepark.fun/2018/02/17/tr用法解析-macos环境BSD-shell/","excerpt":"","text":"参考:http://fyan.iteye.com/blog/1172279 简介 tr是translate的简写，亦即翻译，但是遗憾的是，它不能翻译句子，只能翻译单个字符。 tr的工作原理是什么?先记住一点，tr命令不接受指定的文件参数，而只是对标准输入进行翻译。好了，记住这点后，我们继续。 tr的命令格式是tr SET1 SET2，凡是在SET1中的字符，都会被替换为SET2中相应位置上的字符，简单吧! 举个例子吧! tr的例子其实都大同小异，看一个最简单的例子： 我们有一个包含了四个人身高的数据文件，名字叫height.txt，它的内容是这样的： 12printf '1.79 1.831.65 1.59' &gt; height.txt 我们想搞一个恶作剧，将所有人的身高从1米级别都提高到2米级别，呵呵，一个tr就可以搞定。1234tr 1 2 &lt; height.txt2.79 2.83 2.65 2.59 希望你没有忘记，tr只处理标准输入，所以我们需要将height.txt通过重定向指到tr的标准输入才可以。 我们可以用tr来修改文件中的间隔符么？ 1234tr ' ' '\\11' &lt; height.txt | sed -n l1.79\\t1.83$1.65\\t1.59$ 这里有一个小知识点，像制表符、换行符这些字符不好表示，我们可以考虑使用ASCII的八进制形式来表示，制表符的八进制形式是11，回车是15，换行是12。而在tr命令中，可以使用\\nnn形式表示八进制形式的字符。如果你实在记不住这些编号，那么用\\t表示制表符你总该可以记住吧！（\\n代表新行, \\r代表回车) 1sed -n l # l 是什么意思? 参考:https://www.cnblogs.com/ctaixw/p/5860221.html l 显示与八进制ACSII代码等价的控制符 使用tr能把文章中的小写都转换成大写1234echo AbcdE | tr 'a-z' 'A-Z'ABCDE [CHAR*]怎么用？这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止 123echo 1234567890 | tr '[:digit:]' '[A*]'AAAAAAAAAA [CHAR*REPEAT]怎么用？这也是SET2专用的设定，功能是将CHAR重复REPEAT次数。其中REPEAT次数可以用八进制数表示，但记得要以0开头表示八进制数。 123echo 1你2好3吗4世5界67890 | tr '1-9' '[A*5]BCDE'A你A好A吗B世C界DEEEA 在tr中还有哪些表示集合的符号呢?123456789101112[:alnum:] ：所有字母字符与数字 [:alpha:] ：所有字母字符 [:blank:] ：所有水平空格 [:cntrl:] ：所有控制字符 [:digit:] ：所有数字 [:graph:] ：所有可打印的字符(不包含空格符) [:lower:] ：所有小写字母 [:print:] ：所有可打印的字符(包含空格符) [:punct:] ：所有标点字符 [:space:] ：所有水平与垂直空格符 [:upper:] ：所有大写字母 [:xdigit:] ：所有 16 进位制的数字 1234#将所有的数字都转换为字符x。echo 1你2好3吗4世5界67890 | tr [:alnum:] &apos;[x*]&apos;x你x好x吗x世x界xxxxx tr里面包含SET1和SET2，那如果出现两个集合的大小不同的情况，tr如何处理呢？第一种情况是SET1&gt;SET2： 123echo 0,1,2,3,4,5,6,7,8,9 | tr '1-5' 'AB'0,A,B,B,B,B,6,7,8,9 1结论一下子就出来了，SET1中多出来的字符都会和SET2中最后一个字符相对应。 第二种情况SET1&lt;SET2： 123echo 0,1,2,3,4,5,6,7,8,9 | tr '1-3' 'ABCDE'0,A,B,C,4,5,6,7,8,9 1很明了，SET2中多余的部分将被抛弃。 -S参数用法这个-s选项，是专门针对SET1起作用的，意思是如果发现有连续的SET1里的字符，就把它们缩减为1个。 一个很经典的应用就是把不规律的空格缩减为一个空格： 12printf 'How are you? Fine! Thank you! ' &gt; spaces.txt 1234tr -s &apos; &apos; &apos; &apos; &lt; spaces.txt How are you? Fine! Thank you! -d选项咋用？-d选项是用来删除字符用的。格式是这样的：1tr -d charset 1234tr -d ' ' &lt; spaces.txt Howareyou? Fine!Thankyou! 看，该有的空格都没了…这就是-d的作用，把空格都删除了! 如果你想把文章中的数字都删除，就1tr -d [0-9] &lt; filename 就可以了。 语法：1tr [options] [source-char-list] [replace-char-list] &lt; filename 用途： 转换字符，例如：将大写字符转换成小写字符。选项可以让你指定所要删除的字符，以及将一串重复出现的字符浓缩成一个。常用选项：1－c： 取source-char-list的反义，所有不在source-char-list中的字符。常与-d , -s配合使用。 －d： 删除source-char-list中所定义的字符。1－s： 浓缩重复的字符。如果标准输入中连续重复出现source-char-list里所列的字符，则将其浓缩成一个。或者将其浓缩成replace-char-list中的字符。 tr ‘X’ ‘x’ 把所有大写X转换成小写x1tr &apos;()&apos; &apos;&#123;&#125;&apos; 把( )替换成&#123; &#125; tr ‘[a-z]’ ‘[A-Z]’ 把所有小写字母变成大写字母tr ‘[A-Z]’ ‘[N-ZA-M]’ 把字符A-M分别转换成N-Z，而N-Z转换成A-Mtr -s ‘ ‘ ‘ ‘ 把多个空格转换成单个空格tr -d ‘[0-9]’ 删除所有数字 引用:[a-z] a-z内的字符组成的字符串。[A-Z] A-Z内的字符组成的字符串。[0-9] 数字串。 代码:速记符含义八进制方式1234567\\a Ctrl-G 铃声 \\007\\b Ctrl-H 退格符 \\010\\f Ctrl-L 走行换页 \\014\\n Ctrl-J 新行 \\012 \\r Ctrl-M 回车 \\015\\t Ctrl-I tab键 \\011\\v Ctrl-X \\030 如果要去除重复字母或将其压缩在一起，使用-s选项。因为都是字母，故使用[a-z][A-Z]。输入文件重定向到tr命令。1234567echo &apos;success differentAnd the cowwwwws went homeeeeeeeeeeeee Or did theyyyyyyyyyyyyy&apos; | tr -s &quot;[a-zA-Z]&quot;suces diferentAnd the cows went home Or did they 注: 小心使用 success 会变成 suces 删除空行123456789101112131415echo &apos;9879932 Spitfire 190992 Lancaster 238991 Typhoon &apos; | tr -s &quot;\\012&quot; 大写到小写除了删除控制字符，转换大小写是tr最常用的功能。为此需指定即将转换的小写字符[a-z]和转换结果[A-Z]。第一个例子，tr从一个包含大小写字母的字符串中接受输入。 1234#tr \"[a-z]\" \"[A-Z]\" 或者 tr \"[:lower:]\" \"[:upper:]\" echo \"May Day,May Day,Going Down..\" | tr \"[a-z]\" \"[A-Z]\" MAY DAY,MAY DAY,GOING DOWN.. 删除指定字符12345偶尔会从下载文件中删除只包含字母或数字的列。需要结合使用-c和-s选项完成此功能。 下面的文件包含一个星期的日程表。任务是从其中删除所有数字，只保留日期。日期有大写，也有小写格式。因此需指定两个字符范围[a-z]和[A-Z]，命令tr -cs \"[a-z][A-Z]\" \"\\n\"将文件每行所有不包含在[a-z]或[A-Z]（所有希腊字母）的字符串放在字符串replace-char-list中并转换为一新行。-s 选项表明压缩所有新行， -c 表明取source-char-list的反义。 12345678910111213141516171819echo 'success differentmondy 1all0:5b0 Tuesday 15:00 wednesday 15:30 thurday 10:30 Fridya 09:20 ' | tr -cs \"[a-z][A-Z]\" \"[\\n*]\"# [\\n*] 自动匹配 SET1的长度successdifferentmondyallbTuesdaywednesdaythurdayFridya","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"tr","slug":"tr","permalink":"http://pro.stonepark.fun/tags/tr/"}]},{"title":"awk用法解析(macos环境BSD shell)","slug":"awk用法解析-macos环境BSD-shell","date":"2018-02-16T13:48:34.000Z","updated":"2018-02-17T13:00:57.000Z","comments":true,"path":"2018/02/16/awk用法解析-macos环境BSD-shell/","link":"","permalink":"http://pro.stonepark.fun/2018/02/16/awk用法解析-macos环境BSD-shell/","excerpt":"","text":"参考:https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html 简介 awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。 awk有3个不同版本: awk、nawk和gawk，未作特别说明，一般指gawk，gawk 是 AWK 的 GNU 版本。 awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。 使用方法awk ‘{pattern + action}’ {filenames}尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。 awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。 通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。 test.txt12345678910111213141516171819202122232425262728293031323334root:x:0:0:root:/root:/bin/zshbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologingopher:x:13:30:gopher:/var/gopher:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinusbmuxd:x:113:113:usbmuxd user:/:/sbin/nologinvcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologinrpc:x:32:32:Rpcbind Daemon:/var/cache/rpcbind:/sbin/nologinrtkit:x:499:497:RealtimeKit:/proc:/sbin/nologinavahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologinabrt:x:173:173::/etc/abrt:/sbin/nologinrpcuser:x:29:29:RPC Service User:/var/lib/nfs:/sbin/nologinnfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologinhaldaemon:x:68:68:HAL daemon:/:/sbin/nologingdm:x:42:42::/var/lib/gdm:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinapache:x:48:48:Apache:/var/www:/sbin/nologinsaslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinpulse:x:497:496:PulseAudio System Daemon:/var/run/pulse:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinstonelinux:x:500:500:StoneParkLinux:/home/stonelinux:/bin/zsh 全局设置(测试)1file=test.txt 调用awk有三种方式调用awk 1.命令行方式 123awk [-F field-separator] 'commands' input-file(s)awk -F: '/root/&#123;print $7&#125;' $file 其中，commands 是真正awk命令，[-F域分隔符]是可选的。 input-file(s) 是待处理的文件。在awk中，文件的每一行中，由域分隔符分开的每一项称为一个域。通常，在不指名-F域分隔符的情况下，默认的域分隔符是空格。 2.shell脚本方式将所有的awk命令插入一个文件，并使awk程序可执行，然后awk命令解释器作为脚本的首行，一遍通过键入脚本名称来调用。相当于shell脚本首行的：#!/bin/sh可以换成：#!/bin/awk12345678#------------------------------# commandfile.sh文件内容#!/bin/awk##/root/&#123;print $7&#125;#/root/#------------------------------awk -F: -f ./commandfile.sh $file 3.将所有的awk命令插入一个单独文件，然后调用：123awk -f awk-script-file input-file(s)awk -F: -f ./commandfile.sh $file 其中，-f选项加载awk-script-file中的awk脚本，input-file(s)跟上面的是一样的。 入门实例1last -5 | awk '&#123;print $1&#125;' 1awk工作流程是这样的：读入有&apos;\\n&apos;换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。默认域分隔符是&quot;空白键&quot; 或 &quot;[tab]键&quot;,所以$1表示登录用户，$3表示登录用户ip,以此类推。 123456789cat $file |awk -F ':' '&#123;print $1&#125;' #结果rootbindaemonadmlpsync 这种是awk+action的示例，每行都会执行action{print $1}。-F指定域分隔符为’:’。 如果只是显示/etc/passwd的账户和账户对应的shell,而账户与shell之间以tab键分割1234567cat $file | awk -F ':' '&#123;print $1\"\\t\"$7&#125;'root /bin/zshbin /sbin/nologindaemon /sbin/nologinadm /sbin/nologinlp /sbin/nologinsync /bin/sync awk工作流程是这样的：先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······直到所有的记录都读完，最后执行END操作。 awk直接修改原文件 12#注意:重定向符号后面的文件名需要加双引号cat $file |awk -F ':' '&#123;print $1\"\\t\"$7 &gt; \"aa/a.txt\"&#125;' awk + regex搜索$file有root关键字的所有行1awk -F: '/root/' $file 这种是pattern的使用示例，匹配了pattern(这里是root)的行才会执行action(没有指定action，默认输出每行的内容)。 搜索支持正则，例如找root开头的:1awk -F: '/root/&#123;print $7&#125;' $file # 这里指定了action&#123;print $7&#125; awk内置变量awk有许多内置变量用来设置环境信息，这些变量可以被改变，下面给出了最常用的一些变量。 1234567891011ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk浏览的文件名FNR 浏览文件的记录数FS 设置输入域分隔符，等价于命令行 -F选项NF 浏览记录的域的个数NR 已读的记录数OFS 输出域分隔符ORS 输出记录分隔符RS 控制记录分隔符 此外,$0变量是指整条记录。$1表示当前行的第一个域,$2表示当前行的第二个域,......以此类推。 统计$file:文件名，每行的行号，每行的列数，对应的完整行内容: 1awk -F ':' '&#123;print \"filename:\" FILENAME \",linenumber:\" NR \",columns:\" NF \",linecontent:\"$0&#125;' $file 使用printf替代print,可以让代码更加简洁，易读 1awk -F ':' '&#123;printf(\"filename:%10s,linenumber:%s,columns:%s,linecontent:%s\\n\",FILENAME,NR,NF,$0)&#125;' $file print和printfawk中同时提供了print和printf两种打印输出的函数。 其中print函数的参数可以是变量、数值或者字符串。字符串必须用双引号引用，参数用逗号分隔。如果没有逗号，参数就串联在一起而无法区分。这里，逗号的作用与输出文件的分隔符的作用是一样的，只是后者是空格而已。 printf函数，其用法和c语言中printf基本相似,可以格式化字符串,输出复杂时，printf更加好用，代码更易懂。 awk编程除了awk的内置变量，awk还可以自定义变量。下面统计/etc/passwd的账户人数1234567awk '&#123; count++; print $0;&#125;END&#123; print \"user count is \", count&#125;' $file count是自定义变量。之前的action{}里都是只有一个print,其实print只是一个语句，而action{}可以有多个语句，以;号隔开。 这里没有初始化count，虽然默认是0，但是妥当的做法还是初始化为0: 123456789101112awk 'BEGIN &#123; count=0; print \"[start]user count is \", count&#125; &#123; count=count+1; print $0;&#125; END&#123; print \"[end]user count is \", count&#125;' $file 统计某个文件夹下的文件占用的字节数123456789ls -l $temp | awk 'BEGIN &#123; size=0;&#125; &#123; size=size+$5;&#125; END &#123; print \"[end]size is \", size&#125;' 如果以M为单位显示: 1ls -l $temp|awk 'BEGIN &#123;size=0;&#125; &#123;size=size+$5;&#125; END&#123;print \"[end]size is \", size/1024/1024,\"M\"&#125;' 注意，统计不包括文件夹的子目录。 条件语句awk中的条件语句是从C语言中借鉴来的，见如下声明方式：12345678910111213141516171819if (expression) &#123; statement; statement; ... ...&#125;if (expression) &#123; statement;&#125; else &#123; statement2;&#125;if (expression) &#123; statement1;&#125; else if (expression1) &#123; statement2;&#125; else &#123; statement3;&#125; 统计某个文件夹下的文件占用的字节数,过滤4096大小的文件(一般都是文件夹): 1ls -l $temp |awk 'BEGIN &#123;size=0;print \"[start]size is \", size&#125; &#123;if($5!=4096)&#123;size=size+$5;&#125;&#125; END&#123;print \"[end]size is \", size/1024/1024,\"M\"&#125;' 循环语句awk中的循环语句同样借鉴于C语言，支持while、do/while、for、break、continue，这些关键字的语义和C语言中的语义完全相同。 数组因为awk中数组的下标可以是数字和字母，数组的下标通常被称为关键字(key)。值和关键字都存储在内部的一张针对key/value应用hash的表格里。由于hash不是顺序存储，因此在显示数组内容时会发现，它们并不是按照你预料的顺序显示出来的。数组和变量一样，都是在使用时自动创建的，awk也同样会自动判断其存储的是数字还是字符串。一般而言，awk中的数组用来从记录中收集信息，可以用于计算总和、统计单词以及跟踪模板被匹配的次数等等。 1234567891011121314awk -F ':' 'BEGIN &#123; count=0;&#125; &#123; name[count] = $1; count++;&#125; END &#123; for (i = 0; i &lt; NR; i++) &#123; print i, name[i] print \"hello world\" &#125; &#125;' $file 12345678910111213#结果0 roothello world1 binhello world2 daemonhello world3 admhello world4 lphello world5 synchello world 这里使用for循环遍历数组 awk编程的内容极多，这里只罗列简单常用的用法，更多请参考 http://www.gnu.org/software/gawk/manual/gawk.html awk之RS、ORS与FS、OFS参考:https://www.cnblogs.com/fhefh/archive/2011/11/16/2251656.html 123456789RS：Record Separator，记录分隔符ORS：Output Record Separate，输出当前记录分隔符FS：Field Separator，字段分隔符OFS：Out of Field Separator，输出字段分隔符PS：RS、ORS、FS、OFS的英文解释绝不是这样的，这里只是解释清楚。建议去阅读awk的英文读物，其中解释了缩写的含义。 什么是field（字段），什么是record（记录行）？ 示例：1.txt1231. i am a student.2. i like to swim3. hello moto 1代表第一个记录行，2代表第二个记录行，3代表第三个记录行。通过观察我们可以知道总共有3个记录行（record）。 看看第一行：“i am a student”，这一行的每个单词都是一个字段（field）。“i”是一个字段，“am”是一个字段，“a”是一个字段，“student”是一个字段，该行总共有4个字段。 RS与ORS12345672.txta\\nb\\nc\\nd\\ne\\n 该文本总共有5行，每一行都有一个换行符“\\n”。所以每行记录都是以“\\n”为一个（换行的）标志。 5行变1行(ORS：Output Record Separate, 输出的时候, 行分隔符 替换成 指定分隔符)观察每一行的“换行符号”，然后将“换行符号”替换成你想要的符号。 123awk 'BEGIN&#123;ORS=\"|\"&#125;&#123;print $0&#125;' 2.txt | sed -n \"s/\\\\\\n//gp\" | sed -n 's/.$//p' #.表示任意 $结束符 匹配到了 最后一个 ,(逗号) 然后替换成空 1233.txta|b|c|d|e 1行变5行(RS：Record Separator 读取的时候, 指定行分隔符,用指定分隔符 切成行)找到某某标志，让每个某某后的内容重新变成一行 1awk 'BEGIN&#123;RS=\"|\"&#125;1' 3.txt FS：字段分隔符FS默认值为“ （空格）”,如“hello moto”.在“hello moto”中有一个空格，空格就是hello与moto的分隔符（separator），而hello与moto就为字段（fields）。awk以空格来区分。 12# 在看看“i----love----you”,如果我们用命令awk '&#123; print $1 &#125;' ”会看到结果为：1i----love----you 123456#如果想打印出三个字母，通过观察可发现“----”为分隔符。awk &apos;BEGIN&#123; FS=&quot;----&quot;;&#125;&#123; print $1,$2,$3 &#125;&apos; filename# 结果# i love you OFS：输出的字段分隔符。这么解释吧，如上例中“i—-love—-you”，“—-”为分隔符(FS)，如果我们想改为用其他符号显示可以这样： 123awk 'BEGIN&#123; FS=\"----\";OFS=\"*****\" &#125;&#123; print $1,$2,$3 &#125;' filenamei*****love*****you 其实OFS还有一个例子123echo \"abc\" | awk '&#123; OFS=\".\" &#125; &#123; NF=NF; print NF,$0&#125;'# 结果# 1.abc 1234567echo \"abc\" | awk 'BEGIN&#123; OFS=\".\" &#125; &#123; print $0,\"hello\",\"world\"&#125;' # abc.hello.worldecho \"abc\" | awk 'BEGIN&#123; OFS=\".\" &#125; &#123; print $0 \"hello\" \"world\"&#125;' # abchelloworldecho \"abc\" | awk 'BEGIN&#123; OFS=\".\" &#125; &#123; print $0\"hello\"\"world\"&#125;' # abchelloworldecho \"abc\" | awk '&#123; print $0,\"hello\",\"world\"&#125;' # abc hello world 没有指定OFS 默认是空格# 总结, 还有用,(逗号)来写 print的分割, 指定OFS来完成指定列分隔符 PS：RS与ORS可以说成是一个互逆的过程（↔）也可以看成一个替换的过程，但是看成互逆的过程比较好理解；FS与OFS就是一个替换的过程。 ###为什么awk中的“1”打印当前行？https://stackoverflow.com/questions/20262869/why-does-1-in-awk-print-the-current-line 123456789101112131415161718192021cat filea b c d e f1 2 3 4不输出后两列字段，代码如下awk '&#123;NF=NF-2&#125;1'filea b c d1 2&#123;NF=NF-2&#125;1，这个后面接的1是什么意思呢？#----------------------------------awk是 一组 pattern action, pattern action, ……的组合pattern能匹配上，就执行对应的action。pattern省略或为1，等价于 /.*/action省略，等价于 &#123; print &#125;所以上式的完整写法是：/.*/ &#123;NF=NF-2&#125;/.*/ &#123;print&#125;因为两个pattern相同，所以可以合并：/.*/ &#123;NF=NF-2; print;&#125; 123456789101112#shell去掉最后一个字符#原创 2016年07月15日 11:34:55 8196#387691,387710,387720,387817,387922,388067,#如何搞掉最后一个,? 简单快捷的？sed 's/.$//'awk '&#123;sub(/.$/,\"\")&#125;1'awk '&#123;printf $0\"\\b \\n\"&#125;' ufile#\\b Backspace, Control-h, ASCII code 8 (BS). 参考:ftp://ftp.gnu.org/old-gnu/Manuals/gawk-3.0.3/html_chapter/gawk_5.html awk内建变量示例详解之NR、FNR、NF参考:http://www.letuknowit.com/topics/20120329/sample-about-awk-build-in-variable-nr-fnr-nf.html/ Number of RecordNR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。 File Number of Record在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。 Number of Field(用FS切,默认是空格, 切出来几块)NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field。 12345class1.txtzhaoyun 85 87guanyu 87 88liubei 90 86 1234class2.txtcaocao 92 87 90guojia 99 96 92 123456printf 'zhaoyun 85 87guanyu 87 88liubei 90 86' &gt; class1.txtprintf 'caocao 92 87 90guojia 99 96 92' &gt; class2.txt 12345678910111213141516171819202122232425# 现在要查看两个班级的所有成绩信息，并在每条信息前加上行号，则可以使用下面的awk指令；awk '&#123;print NR,$0&#125;' class1.txt class2.txt 1 zhaoyun 85 872 guanyu 87 883 liubei 90 864 caocao 92 87 905 guojia 99 96 92# 这里的行号就是通过NR来实现的，awk每读取一条记录，NR的值便加一。如果要求每个班级的行号从头开始变化，则需要使用FNR来实现，如下：awk '&#123;print FNR,$0&#125;' class1.txt class2.txt1 zhaoyun 85 872 guanyu 87 883 liubei 90 861 caocao 92 87 902 guojia 99 96 92# 下面的示例结合awk内建变量FILENAME，显示出来的两个班级的成绩信息可以进行更好的区分;awk '&#123; fn=FILENAME\"\\b\\b\\b\\b\"; print fn,\"第\"NR\"条记录\",fn\"的第\"FNR\"条记录\",\"最后一个字段为\"$NF;&#125;' class1.txt class2.txtclass1 第1条记录 class1的第1条记录 最后一个字段为87class1 第2条记录 class1的第2条记录 最后一个字段为88class1 第3条记录 class1的第3条记录 最后一个字段为86class2 第4条记录 class2的第1条记录 最后一个字段为90class2 第5条记录 class2的第2条记录 最后一个字段为92# 除了NR和FNR外，上面的示例中还演示了NF的使用，class1中每行有3个字段，而class2中有4个字段，通过$NF就可以很方便的获取最后一个字段了。 awk next命令参考:https://linux.cn/article-7609-1-rel.html food_list.txt1234567printf &apos;No Item_Name Price Quantity#1 Mangoes $3.45 5#2 Apples $2.45 25#3 Pineapples $4.45 55#4 Tomatoes $3.45 25#5 Onions $1.45 15#6 Bananas $3.45 30&apos; &gt; food_list.txt next 命令帮助你阻止运行命令执行过程中多余的步骤。awk 跳过你所提供的所有剩下的模式和表达式，直接处理下一个输入行。 运行下面的命令，它将在每个食物数量小于或者等于 20 的行后面标一个星号: 12345678# awk '$4 &lt;= 20 &#123; printf \"%s\\t%s\\n\", $0,\"*\" ; &#125; $4 &gt; 20 &#123; print $0 ;&#125; ' food_list.txt No Item_Name Price Quantity1 Mangoes $3.45 5 *2 Apples $2.45 253 Pineapples $4.45 554 Tomatoes $3.45 25 5 Onions $1.45 15 *6 Bananas $3.45 30 上面的命令实际运行如下:1234567首先，它用$4 &lt;= 20表达式检查每个输入行的第四列（数量（Quantity））是否小于或者等于 20，如果满足条件，它将在末尾打一个星号 (*)。接着，它用$4 &gt; 20表达式检查每个输入行的第四列是否大于20，如果满足条件，显示出来。但是这里有一个问题, 当第一个表达式用&#123; printf \"%s\\t%s\\n\", $0,\"**\" ; &#125;命令进行标注的时候在同样的步骤第二个表达式也进行了判断这样就浪费了时间.因此当我们已经用第一个表达式打印标志行的时候就不再需要用第二个表达式$4 &gt; 20再次打印。 要处理这个问题, 我们需要用到next 命令： 12345678# awk '$4 &lt;= 20 &#123; printf \"%s\\t%s\\n\", $0,\"*\" ; next; &#125; $4 &gt; 20 &#123; print $0 ;&#125; ' food_list.txtNo Item_Name Price Quantity1 Mangoes $3.45 5 *2 Apples $2.45 253 Pineapples $4.45 554 Tomatoes $3.45 25 5 Onions $1.45 15 *6 Bananas $3.45 30 1当输入行用$4 &lt;= 20 &#123; printf \"%s\\t%s\\n\", $0,\"*\" ; next ; &#125;命令打印以后，next命令将跳过第二个$4 &gt; 20 &#123; print $0 ;&#125;表达式，继续判断下一个输入行，而不是浪费时间继续判断一下是不是当前输入行还大于 20。 next命令在编写高效的命令脚本时候是非常重要的，它可以提高脚本速度。 awk, 批量改名12345678910111213141516171819202122232425262728293031323334353637383940#ls F* M* | awk '&#123;# # first = substr($1, 1, 1);# print first;# suffix = substr($1, 2);# print suffix;# if (first == \"M\") &#123;# newfile = \"ic_male_head0\"suffix;# &#125; else &#123;# newfile = \"ic_female_head0\"suffix;# &#125;# system(\"mv \"$1\" \"newfile);# #&#125;'#ls *.jpg | awk 'BEGIN &#123;count=0&#125; &#123;# # suffix = substr($1, 1);# # count+=1# # newfile = count\"\"\"img.jpg\"# # system(\"mv \"$1\" \"newfile);# #&#125;'ls *.png | awk 'BEGIN &#123;count=0;&#125; &#123; suffix = substr($0, 1); count+=1; newfile=\"img\"count\".png\"; system(\"mv \"$0\" \"newfile); print suffix;&#125;'# 解决不了带特殊字符的文件 awk 条件操作符:参考:https://www.cnblogs.com/benevolencedoctor/p/5181203.html 1234567891011121314151617181920212223242526272829303132333435# condition_test.txtFIRST_FIELD SECOND_FIELD THIRD_FIELD FORTH_FIELD FIFTH_FIELD SIXTH_FIELD SEVENTH_FIELD EIGHTH_FIELD NINTH_FIELD TENTH_FIELDexpect1 2 3 4 5 6 7 8 9 10expect2 2 48 4 5 6 7 8 9 10expect3 2 48 4 5 6 7 8 9 10asima 2 48 4 5 6 7 8 9 10asima 2 48 4 5 6 7 8 9 1011 22 33 44 55 66 77 88 99 1010The high construction is also one kind of artware, is classical, is graceful, looks like a rich paint color painting! everywhere is filling the Green, is also fluttering including the air green grass taste all around green and glossy, the Green startled colorful, the windmill also stops down, is infatuated with in the beautiful scene ......高高的建筑也是一种艺术品，古典、优雅，像一幅浓郁的油漆彩画！到处弥漫着绿色，连空气也飘着青草味四周一片绿油油，绿色的惊艳，风车也停下来，陶醉在美景中……Apple Phonea b c d e f g h i j k l m n o p q r s t u v w x y zb c d e f g h i j k l m n o p q r s t u v w x y z ab c d e f g h i j k l m n o p q r s t u v w x y z a=1stone 25 man 1985/01/17 China Beijing asima stone 25 man 1985/01/17 China Beijing 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/bin/bash#touch condition_test.txt#subl condition_test.txtfile=\"condition_test.txt\"#第一字域，包含expect，就打印整行awk '&#123;if($1~/expect/) print $0&#125;' $file#echo \"first, second, third,forth，fifth，sixth，seventh，eighth，ninth，tenth\" | sed -E -e 's/[, ，]/ /g' | tr -s ' ' #tr 'a-z' 'A-Z' &lt; $fileawk '$1~/expect/&#123;print $0&#125;' $file#精确匹配:，只打印第3 域等于\"48\"的记录awk '$3==\"48\" &#123;print $0&#125;' $file ###不等于: awk '$1 != \"asima\"' $file# ##不匹配: 打印整条不包含ASIMA 的记录awk '$0 !~ /asima/' $file # ~ 匹配正则表达式的意思# ##小于: awk '&#123; if ($1 !~ /[0-9]/) &#123; next; #如果不包含数字 就别再匹配下面的条件了 &#125;&#125; &#123; if ($1&lt;$2) print $1,\"is smaller\"&#125;' $fileawk '&#123; if ($1 ~ /^[0-9]+/) &#123; #如果不包含数字 就别再匹配下面的条件了 if ($1&lt;$2) &#123; print $1,\"is smaller\" &#125; &#125;&#125;' $file# ##设置大小写: awk '/[Gg]reen/' temp 打印整条包含Green，或者green 的记录awk '/[Gg]reen/&#123;print NR,$0&#125;' $file## #任意字符: awk '$1 ~/^...a/' temp 打印第1 域中第四个字符是a 的记录，符号’^’#代表行首，符合’.’代表任意字符awk '$1 ~/^...l/' $file## #AND 与关系: awk '&#123;if ( $1==\"a\" &amp;&amp; $2==\"b\" ) print $0&#125;' tempawk '&#123;if ( $1==\"a\" &amp;&amp; $2==\"b\" ) print $0&#125;' $file###OR 或关系: awk '&#123;if ($1==\"a\" || $1==\"b\") print $0&#125;' tempawk '&#123;if ($1==\"a\" || $1==\"b\") print $0&#125;' $file###for循环#awk -F \" \" '&#123;# for (i=1;i&lt;=NF;i++)&#123;# if($i~/a=/) &#123;# print $i# &#125;# &#125;#&#125;' $fileawk '/[Gg]reen/&#123; for (i=1;i&lt;=NF;i++)&#123; if($i~/[Gg]reen/) &#123; print FNR,$i &#125; &#125;&#125;' $file NF 的另一用法: echo $PWD | awk -F/ &#39;{print $NF}&#39; 显示当前目录名","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"awk","slug":"awk","permalink":"http://pro.stonepark.fun/tags/awk/"}]},{"title":"grep用法解析(macos环境BSD shell)","slug":"grep用法解析-macos环境BSD-shell","date":"2018-02-16T09:31:02.000Z","updated":"2018-02-16T09:34:02.000Z","comments":true,"path":"2018/02/16/grep用法解析-macos环境BSD-shell/","link":"","permalink":"http://pro.stonepark.fun/2018/02/16/grep用法解析-macos环境BSD-shell/","excerpt":"","text":"介绍 Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 主要参数1234567891011121314151617181920#格式grep [options][options]主要参数： －c：只输出匹配行的计数。 －i：不区分大 小写(只适用于单字符)。 －I：Ignore binary files. －h：查询多文件时不显示文件名。 －l：查询多文件时只输出包含匹配字符的文件名。 －n：显示匹配行及 行号。 －s：不显示不存在或无匹配文本的错误信息。 －v：显示不包含匹配文本的所有行。 testfile1wget -P ~/testfile/ \"http://ou0y29lb2.bkt.clouddn.com/po.zip\" ##全局设置12grepc=\"grep --color\"cd $HOME/Documents/test_directory/pojo_test -c : 只输出匹配行的计数 1$grepc -c &quot;\\&lt;condition\\&gt;&quot; ./po/* -d skip －i：不区分大 小写(只适用于单字符)。 1$grepc -i \"value\" ./po/* -d skip －h：查询多文件时不显示文件名。1$grepc -h -i \"value\" ./po/* -d skip －l：查询多文件时只输出包含匹配字符的文件名。 1$grepc -l -h -i \"value\" ./po/* -d skip －n：显示匹配行及 行号 1$grepc -n -i \"value\" ./po/* -d skip －s：不显示不存在或无匹配文本的错误信息。照样报错 - - 不知道有啥用… －v：显示不包含匹配文本的所有行。 1grep -h -E -v -i \"value|string|return|Criteria|&#123;|&#125;|=|addCriterion|super\" ./po/* -d skip | grep [:space:] 12345678910111213141516171819pattern正则表达式主要参数： \\： 忽略正则表达式中特殊字符的原有含义。 ^：匹配正则表达式的开始行。 $: 匹配正则表达式的结束行。 \\&lt;：从匹配正则表达 式的行开始。 \\&gt;：到匹配正则表达式的行结束。 [ ]：单个字符，如[A]即A符合要求 。 [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。 . ：所有的单个字符。 * ：有字符，长度可以为0。 1234567891011121314151617181920# \\： 忽略正则表达式中特殊字符的原有含义。$grepc -n -i \"\\\\$\" ./po/* -d skip# ^：匹配正则表达式的开始行。$grepc -h -i \"^sed\" ./po/* -d skip# $: 匹配正则表达式的结束行。$grepc -E -h -i \"class.*&#123;$\" ./po/* -d skip# \\&lt;：从匹配正则表达 式的行开始。$grepc -E -h -i \"\\&lt;cond\" ./po/* -d skip# \\&gt;：到匹配正则表达式的行结束。$grepc -E -h -i \"tion\\&gt;\" ./po/* -d skip# \\&lt; 和 \\&gt; 分别标注单词的开始与结尾。$grepc -E -h -i \"\\&lt;condition\\&gt;\" ./po/* -d skip# [ ]：单个字符，如[A]即A符合要求 。$grepc -E -h \"[A-Z]&#123;2,5&#125;\" ./po/* -d skip# [ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。$grepc -E -h \"[A-Z]&#123;2,5&#125;\" ./po/* -d skip# . ：所有的单个字符。$grepc -E -h \"\\b.&#123;5&#125;\\b\" ./po/* -d skip# * ：有字符，长度可以为0。$grepc -E -h \"\\b[[:alnum:]]&#123;5&#125;\\b\" ./po/* -d skip grep命令使用简单实例12# 如果只有一个 txt文件 并且匹配到了 不会显示全路径, 只会显示行号和匹配行$grepc -E -i -n \"value\" ./po/t* -d skip #显示所有以d开头的文件中包含 test的行。 123$grepc -E -n \"value|one\" ./po/test001.txt ./po/test002.txt #显示在test001.txt，test002.txt 文件中匹配value或者one的行。-E 表示表达式扩展$grepc -E '\\b[a-z]&#123;5&#125;\\b' ./po/test001.txt #显示所有包含每个字符串至少有5个连续小写字符的字符串的行。$grepc -E \"'number (one)'.*\\1\" ./po/test001.txt #如果number (one)被匹配，则one就被存储到内存中，并标记为1，然后搜索任意个字符(.*)，这些字符后面紧跟着 另外一个one(\\1)，找到就显示该行。如果用egrep或grep -E，就不用”\\”号进行转义. grep命令使用复杂实例123456789101112131415#假设您正在&apos;./po/*&apos;目录下搜索带字符 串&apos;value&apos;的文件：$grepc &quot;value&quot; ./po/*.txt#./po/test001.txt:What is your value?#./po/test002.txt:What is your value?#默认情况下，&apos;grep&apos;只搜索当前目录。如果 此目录下有许多子目录，’grep’会以如下形式列出：#grep: sound: Is a directory#这可能会使’grep’ 的输出难于阅读。这里有两种解决的办法：#明确要求搜索子目录：grep -r#或忽略子目录：grep -d skip#如果有很多 输出时，您可以通过管道将其转到’less’上阅读：$grepc &quot;value&quot; ./po/* | less#这样，您就可以更方便地阅读 1234567891011121314151617181920#下面还有一些有意思的命令行参数：files=\"./po/* -r\"$grepc -i obj ./po/* #：不区分大小写地搜索。默认情况区分大小写，$grepc -l obj $files #：只列出匹配的文件名，$grepc -L obj $files #：列出不匹配的文件名，$grepc -w obj $files #：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)，$grepc -C 2 obj $files #：匹配的上下文分别显示[number]行，$grepc -E -i \"address|value\" $files #：显示匹配 pattern1 或 pattern2 的行，$grepc -ie address $files | $grepc -ie value #：显示既匹配 pattern1 又匹配 pattern2 的行。$grepc -n -ie address $files #即可显示行号信息$grepc -c -ie address $files #即可查找总行数 可以使用国际模式匹配的类名：1234567891011[[:upper:]] [A-Z][[:lower:]] [a-z][[:digit:]] [0-9][[:alnum:]] [0-9a-zA-Z][[:space:]] 空格或tab[[:alpha:]] [a-zA-Z]","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"grep","slug":"grep","permalink":"http://pro.stonepark.fun/tags/grep/"}]},{"title":"sed用法解析(macos环境BSD shell)","slug":"sed用法解析-macos环境BSD-shell","date":"2018-02-15T14:38:26.000Z","updated":"2018-02-15T14:42:42.000Z","comments":true,"path":"2018/02/15/sed用法解析-macos环境BSD-shell/","link":"","permalink":"http://pro.stonepark.fun/2018/02/15/sed用法解析-macos环境BSD-shell/","excerpt":"","text":"参考:http://blog.csdn.net/zg_hover/article/details/1804481 sed介绍12345sed可删除(delete)、改变(change)、添加(append)、插入(insert)、合、交换文件中的资料行,或读入其它档的资料到文&gt;件中,也可替换(substuite)它们其中的字串、或转换(tranfer)其中的字母等等。例如将文件中的连续空白行删成一行、&quot;local&quot;字串替换成&quot;remote&quot;、&quot;t&quot;字母转换成&quot;T&quot;、将第10行资料与第11资料合等. 总合上述所言,当sed由标准输入读入一行资料并放入pattern space时,sed依照sed script 的编辑指令逐一对pattern space内的资料执行编辑,之後,再由pattern space内的结果送到标准输出,接着再将下一行资料读入.如此重执行上述动作,直至读&gt;完所有资料行为止. 小结,记住: (1)sed总是以行对输入进行处理 (2)sed处理的不是原文件而是原文件的拷贝 aa.txt123456789101112131415161718192021one#two#three#fourfive xxsix xxseveneightt hello world tporttest my car#port 6379machine phicomputer phiUnixif [ ! -d &quot;/usr/local/fastdfs&quot; ]; then mkdir /usr/local/fastdfsfiabc 删除1234inputfile=\"aa.txt\"sed -i '' -e '1d' $inputfile #(删除第一行)sed -i '' -e '3d' $inputfile #(删除第三行)sed -i '' -e '1d' -e '2d' -e '3d' $inputfile #(删除第1,2,3行) 1234file=\"aa.txt\"sed -i '' -e '1,3d' $file #(删除第一到第三行)sed -i '' -e '4,6d' $file #(删除第4到第6行)sed -i '' -e '2,$d' $file #$ 最后二行和二行的最后 1234file=\"aa.txt\"sed -i '' -e '/#/d' $file #(删除含有'#'号的行)sed -i '' -e '/xx/d' $file #(删除含有字母xx的行)sed -i '' -e '/xx/!d' $file #(删除 含有xx 以外的行, 反选) 1234file=\"aa.txt\"sed -i '' -e '/one/,/six/d' $file #(删除从含有单词one到含有单词six的行)sed -i '' -e '2,/six/d' $file #(删除文件中从第2行到含有six的行)sed -i '' -e '/two/,7d' $file #(删除从含有two的行到第7行) 12file=\"aa.txt\"sed -i '' -e '/t.*t/d' $file #(删除含有两个t的行) 替换 Sed 可替换文件中的字串、资料行、甚至资料区。其中,表示替换字串的指令中的函数参数为s;表示替换资料行、或资料区&gt;的指令中的函数参数为c。上述情况以下面三个例子说明。 1234567891011file=\"aa.txt\"sed -i '' -e '1c\\'$'\\n#!/bin/bash' $file #(把第一行替换成#!/bin/bash)#等价写法sed -i '' -e '1c\\#!/bin/bash' $file #(把第一行替换成#!/bin/bash)# 因此 '$'\\n 等价于 手动输入的 回车?sed -i '' -e '1i\\'$'\\n#!/bin/bash' $file #(把第一行【插入】#!/bin/bash)sed -i '' -e '2c\\'$'\\njust do it' $file #(把第2行替换成just do it) 123456file=\"aa.txt\"sed -i '' -e '1,6c\\'$'\\nI can do it!\\Let\\'s start\\hell world' $file #(换成三行(I can do it! Let's start hello world)) 1234file=\"aa.txt\"sed -e 's/^port/&amp; 6379/' $filesed -e 's/one/&amp; w2/' $file # one的地方输出 one w2sed -E -e \"s/(test) (my) (car)/[\\2 \\3 \\1]/\" $file #结果: [my car test] flag 参数举例 123456789file=\"aa.txt\"sed -i '' -E -e 's/^#(port)[ ]+[0-9]+/\\1 7001/1' $file #m(10) : 替换行内第m个符合的字串; 记住，是行内的第m个匹配的字串# BSD shell 正则居然不能用 \\d 悲剧.........sed -ne 's/one/&amp; w2/p' $file #p : 替换第一个和one匹配的字符串为one w2，并输出到标准输出.sed -e 's/one/&amp; w2/w out.txt' $file #w filename : 该参数会将替换过的内容写入到文件out.txt并输出替换后的整个文件。注意out.txt里写的只是替换过的行。 sed -e 's/one/&amp; w2/' $file #这里的flag 为空, 这样就只是将第一个w1匹配的字符串替换成w1 w2而后面的不进行替换。 位置参数应用举例123456789file=\"aa.txt\"# 将文件中含\"machine\"字串的资料行中的\"phi\"字串,替换成为\"beta\"字串sed -e '/machine/s/phi/beta/g' $file #先找到machine的行, 之后在匹配行中 找phi 替换成beta, 即便用的g flag参数 , 全局也是匹配行sed -e '1,14 s/port/&amp; extension/g' $file # 把1到14内的port字符串替换成port extension字符串。sed -e '1,$ s/port/&amp; extension/g' $file # $是最后一行, 因此 1,$ 表示整个文档sed -E -e '1,/six/ s/(xx)/oo\\1/g' $filesed -E -e '1,/six/ s/xx/&amp; oo/g' $file # 把1到字符串six内的xx字符串替换成xx oo字符串。 ####扩展 空行替换成换行1sed -e 's/ /\\'$'\\n/g' 12sed 's/ /\\/g' aa.txt 1sed -i \"\" 's/one/before\\'$'\\nafter/g' $file 参考:https://stackoverflow.com/questions/1421478/how-do-i-use-a-new-line-replacement-in-a-bsd-sedhttps://wenku.baidu.com/view/652dd26804a1b0717ed5dd5d 插入insert(在匹配行前面插入) i\\1234file=\"aa.txt\"sed -e '/#/i\\'$'\\nwords' $file #在#字符的前面插入一行wordssed -e '1i\\'$'\\nwords' $file #在第一行前加一行wordsecho -e \"hello\\nword\"| grep wo | sed -e 's/$/.doc/g' #输出word.doc #按理说是修改啊 , 怎么变成拼接了? $符号真奇妙... after(在匹配行后面插入) a\\1234#[address] a/ &lt;插入内容&gt; filenamefile=\"aa.txt\"sed -e '/Unix/a\\'$'\\nLinux' $file #在含有unix的行后添加\"Linux\"sed -e '1a\\'$'\\nhello after' $file #在第一行后添加hello after字符. 扩展12echo \"word\"| grep wo | sed -ne 's/'$'/aa/p'错误 : sed: first RE may not be empty | 从而证明'$'是表示空? 打印123456file=\"aa.txt\"sed -e '/one/ p' $file #打印所有行并重复打印含有then 的行sed -n '/one/ p' $file #只打印含有then的行sed -e '1,3 p' $file # 打印所有行并重复1-3行sed -n '1,3 p' $file # 打印1-3行sed -n '/if/,/fi/p' $file #打印字符if和fi之间的内容 字元的替换: y123file=\"aa.txt\"# 匹配范围有点大啊, 得限制指定行sed -i \"\" -E -e '/^#port/y/#port 6379/ port 7001/' -e 's/ +port/port/g' $file 反相执行命令 : !1sed -E -e '/one|two/!d' $file #删除除了含有one或者two的所有行。 改变文件中的资料: c1234567#基本格式：#[address1[ ,address2]]c/ filename#函数参数 c 紧接着 \"\\\" 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在&gt;每行的结尾加入\"\\\"sed -e '/six/c\\'$'\\n666\\777\\888' $file#表示把含有字符串six的行，该成666\\n777\\n888。 读入下一行资料: n123456#基本格式：#[address1[ ,address2]] nsed -i \"\" -E -ne '/one|two/n' -e 'p' $file # 相当于移除 匹配行sed -i \"\" -E -ne '/two|one/n' -e 'p' $file # 表示输出文件，但如果一行含有字符串echo，则输出包含该字符串的下一行。sed -ne 'n' -e 'p' $file # 输出文中的偶数行 命令的复用123#一次执行多个命令的方式有三种：sed -i \"\" -e 's/one/&amp; love/g;s/two/&amp; mail/g' $file #(使用;号把命令隔开，注意前面不加-e参数)sed -ne '1p' -ne '2p' $file #(使用多个-e参数) 为什么 Mac OS X 的文件打开方式菜单里会有重复图标？这是Mac传说中的打开方式重复。很多更新后的软件都会出现这种情况。解决方法：打开Terminal，粘贴进以下命令并回车：1/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -kill -r -domain local -domain system -domain user 然后重启Finder即可（control+option点击Finder图标）由于经常要用到这个命令，建议存为script。方法：打开AppleScript Editor，新建，在主窗口粘贴如下文字 do shell script 清除1/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/Support/lsregister -kill -r -domain local -domain system -domain user do shell script 重启Finder1killall Finder &amp;&amp; open /System/Library/CoreServices/Finder.app 然后点 文件-保存，格式选应用程序，确认即可。如此这个命令便存成了直接执行的应用程序，需要用的时候双击一下就会去除重复+重启Finder。 参考:http://krypted.com/mac-security/lsregister-associating-file-types-in-mac-os-x/https://www.zhihu.com/question/20599306","categories":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/categories/shell/"}],"tags":[{"name":"sed","slug":"sed","permalink":"http://pro.stonepark.fun/tags/sed/"}]},{"title":"Redis集群配置","slug":"Redis集群配置","date":"2018-02-14T01:14:17.000Z","updated":"2018-02-14T09:39:52.000Z","comments":true,"path":"2018/02/14/Redis集群配置/","link":"","permalink":"http://pro.stonepark.fun/2018/02/14/Redis集群配置/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/redis-3.0.0.gem\"wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/redis-3.0.0.tar.gz\"yum -y install gcc-c++if [ ! -d \"/usr/local/redis\" ]; then mkdir /usr/local/redisficp ~/soft/redis-3.0.0.tar.gz /usr/local/redis/cd /usr/local/redistar -zxvf redis-3.0.0.tar.gzcd /usr/local/redis/redis-3.0.0makemake install PREFIX=/usr/local/rediscd /usr/local/redis/bin# 前端启动# ./redis-servercp /usr/local/redis/redis-3.0.0/redis.conf ./sed -i \"s/^daemonize no/daemonize yes/g\" redis.conf# 查看是否变成yescat redis.conf| grep \"^daemon\"# 后台启动./redis-server redis.conf# 非正常关闭(不推荐使用)ps -ef | grep redis | awk -F \" \" '&#123;if($8!=\"grep\")print $2&#125;' | xargs kill -9# 正常关闭./redis-cli shutdown#=======================# 安装rubyyum install rubyyum install rubygemscp ~/soft/redis-3.0.0.gem /usr/local/redisgem install redis-3.0.0.gemcp /usr/local/redis/redis-3.0.0/src/redis-trib.rb /usr/local/redis/# 搭建集群mkdir /usr/local/redis-clustercd /usr/local/redis-clustermv /usr/local/redis/redis-trib.rb ./if [ ! -d \"/usr/local/redis-cluster/7001\" ]; then mkdir /usr/local/redis-cluster/7001ficp -r /usr/local/redis/bin/* /usr/local/redis-cluster/7001/ # 删除持久化文件if [ -e /usr/local/redis-cluster/7001/dump.rdb ];then rm /usr/local/redis-cluster/7001/dump.rdbfi;# 修改配置文件cd 7001sed -r -i \"s/^daemonize [a-z]+/daemonize yes/g\" redis.confsed -r -i \"s/^port [0-9]+/port 7001/g\" redis.confsed -r -i \"s/^# cluster-enable/cluster-enable/g\" redis.confcat redis.conf| grep -E \"^port|^daemonize|^# cluster-enabled|^cluster-enabled\"cd ..cp 7001 7002 -rcp 7001 7003 -rcp 7001 7004 -rcp 7001 7005 -rcp 7001 7006 -rpath=\"/usr/local/redis-cluster/\"names=(\"7002\" \"7003\" \"7004\" \"7005\" \"7006\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do sed -r -i \"s/^port [0-9]+/port $&#123;names[$i]&#125;/g\" $path$&#123;names[$i]&#125;/redis.conf donepath=\"/usr/local/redis-cluster/\"names=(\"7001\" \"7002\" \"7003\" \"7004\" \"7005\" \"7006\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do cd /usr/local/redis-cluster/$&#123;names[$i]&#125; ./redis-server redis.confdoneipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`cd /usr/local/redis-cluster./redis-trib.rb create --replicas 1 $ipaddr:7001 $ipaddr:7002 $ipaddr:7003 $ipaddr:7004 $ipaddr:7005 $ipaddr:7006# 连接redis集群# 任何一个都行cd 7001# ./redis-cli -h xxx -p xxx -c./redis-cli -p 7001 -c 坑1重装: 先关闭6个节点, 将6个节点中, 任何一个节点的三个文件都删除掉(*.rdb,*.aof,nodes.conf) redis能用shell脚本1/usr/local/redis-cluster/7001/redis-cli -p 7001 -c --raw hdel content 89 mac os sed 扩展正则表达式, 和GNU不一样…由于mac系统是原生于bsd系，sed命令和gnu不同 mac sed 正则表达式竟然不能用+号 还得使用扩展参数…略坑…-E1echo &quot;foobar&quot; | sed -E -e &quot;s/o+//&quot; 参考:https://stackoverflow.com/questions/4453760/how-to-escape-plus-sign-on-mac-os-x-bsd-sedhttp://blog.csdn.net/cbbbc/article/details/50474947 mac自带的sed和linux表现不一致， 需要安装gnu-sedhttp://blog.csdn.net/wk3368/article/details/50876808","categories":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/categories/Linux/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://pro.stonepark.fun/tags/Redis/"}]},{"title":"坑爹的IDEA分组功能","slug":"坑爹的IDEA分组功能","date":"2018-02-13T02:19:48.000Z","updated":"2018-02-13T03:01:24.000Z","comments":true,"path":"2018/02/13/坑爹的IDEA分组功能/","link":"","permalink":"http://pro.stonepark.fun/2018/02/13/坑爹的IDEA分组功能/","excerpt":"","text":"新建项目 只能用一次, 而且只能创建组 还不能删组, 我去… 要删还得手动 - - .idea/modules.xml 文件中 group属性负责创建组… 唉 手动也ok了 , 要是能同步就好了 - - 2017.3 版本倒是修复了 bug , 直接不让用 手动修改依旧能用 , 管理组的方式好像变了 没细研究… 用shell改 也挺方便 唉… 历史版本下载https://www.jetbrains.com/idea/download/previous.html","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://pro.stonepark.fun/categories/IntelliJ-IDEA/"}],"tags":[{"name":"idea坑","slug":"idea坑","permalink":"http://pro.stonepark.fun/tags/idea坑/"}]},{"title":"通过mybatis-generator生成mapper.xml，但是主键id提示error","slug":"通过mybatis-generator生成mapper-xml，但是主键id提示error","date":"2018-02-13T01:13:12.000Z","updated":"2018-02-13T01:22:18.000Z","comments":true,"path":"2018/02/13/通过mybatis-generator生成mapper-xml，但是主键id提示error/","link":"","permalink":"http://pro.stonepark.fun/2018/02/13/通过mybatis-generator生成mapper-xml，但是主键id提示error/","excerpt":"","text":"","categories":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://pro.stonepark.fun/categories/IntelliJ-IDEA/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"http://pro.stonepark.fun/tags/IntelliJ-IDEA/"}]},{"title":"批量修改pojo, 实现序列化","slug":"批量修改pojo-实现序列化","date":"2018-02-12T17:56:41.000Z","updated":"2018-02-12T17:58:29.000Z","comments":true,"path":"2018/02/13/批量修改pojo-实现序列化/","link":"","permalink":"http://pro.stonepark.fun/2018/02/13/批量修改pojo-实现序列化/","excerpt":"","text":"1234grep -r \"public class *\" . | grep -vE \"Example|implements Serializable\" | awk -F \":\" '&#123;print $1&#125;' | xargs -I &#123;&#125; sed -i \"\" \"/public class/i\\ `echo -e '\\r\\n'`import java.io.Serializable;`echo -e '\\r\\n'`\" &#123;&#125;grep -r \"public class *\" . | grep -vE \"Example|implements Serializable\" | awk -F \":\" '&#123;print $1&#125;' | xargs -I &#123;&#125; sed -i \"\" \"/public class/s/&#123;/implements Serializable &#123;/\" &#123;&#125; 参考:http://www.361way.com/sed-process-lines/2263.htmlhttp://blog.csdn.net/cbbbc/article/details/50474947","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://pro.stonepark.fun/tags/shell/"}]},{"title":"修复dubbo注册中心警告bug","slug":"修复dubbo注册中心警告bug","date":"2018-02-12T07:48:45.000Z","updated":"2018-02-12T07:54:14.000Z","comments":true,"path":"2018/02/12/修复dubbo注册中心警告bug/","link":"","permalink":"http://pro.stonepark.fun/2018/02/12/修复dubbo注册中心警告bug/","excerpt":"","text":"修复dubbo注册中心警告bugdubbo注册中心服务提供者界面显示警告，点击提示不同服务名注册了相同服务， 这是界面显示逻辑bug，源码文件位置：/dubbo-admin/src/main/webapp/WEB-INF/templates/governance/screen/providers/index.vm 部分代码如下： 123456789101112131415161718192021#set($providerApplication = \"\")#foreach($provider in $providers)&lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"ids\" value=\"$provider.id\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"providers/$provider.id\"&gt;#if($address)$tool.getSimpleName($provider.service)#else$provider.address#end&lt;/a&gt;&lt;/td&gt; &lt;td&gt;$tool.getProviderWeight($provider)&lt;/td&gt; &lt;td&gt;#if($provider.dynamic)&lt;font color=\"green\"&gt;$i18n.get(\"dynamic\")&lt;/font&gt;#else&lt;font color=\"blue\"&gt;$i18n.get(\"static\")&lt;/font&gt;#end&lt;/td&gt; &lt;td&gt;#if($tool.isProviderEnabled($provider))&lt;font color=\"green\"&gt;$i18n.get(\"enabled\")&lt;/font&gt;#else&lt;font color=\"red\"&gt;$i18n.get(\"disabled\")&lt;/font&gt;#end&lt;/td&gt; &lt;td&gt; #set($errorLevel = \"ok\") #set($errorMessage = \"\") #if ($providerApplication == \"\") #set($providerApplication = $provider.application) #end #if($providerApplication != $provider.application) #if ($errorLevel != \"error\") #set($errorLevel = \"warn\") #end #set($errorMessage = \"$errorMessage&lt;br&gt;$i18n.get('warn'): $i18n.get('CheckProviderApplicationDifferent', $providerApplication, $provider.application)\") #end #if($provider.address.startsWith(\"127.\") || $provider.address.startsWith(\"localhost:\") || $provider.address.startsWith(\"0.0.0.0:\")) 当判断providerApplication的值和provider.application的值不相同时就给出警告。就成为只要应用名和第一个遍历出来的不一样就加警告。而我们想要的警告是不同应用发布了相同的服务时给出警告。修改后的代码如下： 12345678910111213141516171819202122#foreach($provider in $providers)&lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"ids\" value=\"$provider.id\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"providers/$provider.id\"&gt;#if($address)$tool.getSimpleName($provider.service)#else$provider.address#end&lt;/a&gt;&lt;/td&gt; &lt;td&gt;$tool.getProviderWeight($provider)&lt;/td&gt; &lt;td&gt;#if($provider.dynamic)&lt;font color=\"green\"&gt;$i18n.get(\"dynamic\")&lt;/font&gt;#else&lt;font color=\"blue\"&gt;$i18n.get(\"static\")&lt;/font&gt;#end&lt;/td&gt; &lt;td&gt;#if($tool.isProviderEnabled($provider))&lt;font color=\"green\"&gt;$i18n.get(\"enabled\")&lt;/font&gt;#else&lt;font color=\"red\"&gt;$i18n.get(\"disabled\")&lt;/font&gt;#end&lt;/td&gt; &lt;td&gt; #set($errorLevel = \"ok\") #set($errorMessage = \"\") #foreach($patchProvider in $providers) #if ($patchProvider.application != $provider.application) #if ($provider.service == $patchProvider.service) #if ($errorLevel != \"error\") #set($errorLevel = \"warn\") #end #set($errorMessage = \"$errorMessage&lt;br&gt;$i18n.get('warn'): $i18n.get('CheckProviderApplicationDifferent', $patchProvider.application, $provider.application)\") #break #end #end #end #if($provider.address.startsWith(\"127.\") || $provider.address.startsWith(\"localhost:\") || $provider.address.startsWith(\"0.0.0.0:\")) 参考:https://github.com/alibaba/dubbo/pull/780http://blog.csdn.net/u012063409/article/details/59110559 错误页面： 修复后","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://pro.stonepark.fun/tags/dubbo/"}]},{"title":"brew下载的mysql开机启动","slug":"mysql","date":"2018-02-10T19:34:21.000Z","updated":"2018-02-10T19:38:23.000Z","comments":true,"path":"2018/02/11/mysql/","link":"","permalink":"http://pro.stonepark.fun/2018/02/11/mysql/","excerpt":"","text":"1cp `find /usr/local/Cellar/mysql -name \"homebrew.mxcl.mysql.plist\"` ~/Library/LaunchAgents/ 1launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 坑1 Path had bad ownership/permissions可能会有以下提示, 权限不够Path had bad ownership/permissions 修改用户组可解决这个plist文件必须是属于root用户，wheel组，用chown修改之 sudo chown root:wheel ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 坑2 launchctl: no plist was returned原因是：plist文件内容可能有格式错误。 用下面这个命令可以查看文件格式是否有问题，我就是用这个查看到 有一个&lt;true&gt;标记没有闭合。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://pro.stonepark.fun/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://pro.stonepark.fun/tags/mysql/"}]},{"title":"mac一键开启svn","slug":"mac一键开启svn","date":"2018-02-10T05:32:24.000Z","updated":"2018-02-10T05:34:29.000Z","comments":true,"path":"2018/02/10/mac一键开启svn/","link":"","permalink":"http://pro.stonepark.fun/2018/02/10/mac一键开启svn/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env bashecho -n '请输入仓库文件夹名称(默认test_svnserver):'read svnserver_nameecho -n '请输入仓库名称(默认test_repository):'read repository_nameif [ ! -n \"$svnserver_name\" ]; then svnserver_name=\"test_svnserver\"fiif [ ! -n \"$repository_name\" ]; then repository_name=\"test_repository\"fimkdir $HOME/$svnserver_namecd $HOME/$svnserver_namesvnadmin create $repository_name#echo $svnserver_name#echo $repository_nameecho -e \"\\033[0;32;1mcreate repository success please wait seconds\\033[0m\"sleep 2sfilepath=\"$HOME/$svnserver_name/$repository_name/conf/svnserve.conf\"sed -i \"\" \"s/# anon-access = read/anon-access = none/g\" $filepathsed -i \"\" \"s/# auth-access = write/auth-access = write/g\" $filepathsed -i \"\" \"s/# password-db = passwd/password-db = passwd/g\" $filepathsed -i \"\" \"s/# authz-db = authz/authz-db = authz/g\" $filepathfilepath=\"$HOME/$svnserver_name/$repository_name/conf/passwd\"sed -i \"\" \"s/root = 123//g\" $filepathecho \"root = 123\" &gt;&gt; $filepathfilepath=\"$HOME/$svnserver_name/$repository_name/conf/authz\"sed -i \"\" \"s/^\\\\[groups\\\\]/\\\\[groups\\\\]\\\\`echo -e '\\r\\n'`mygroup = root/g\" $filepathsed -i \"\" \"s/\\\\[\\/\\\\]//g\" $filepathsed -i \"\" \"s/@mygroup = rw//g\" $filepathsed -i \"\" \"s/^* =//g\" $filepathecho \"[/]\" &gt;&gt; $filepathecho \"@mygroup = rw\" &gt;&gt; $filepathecho \"* = \" &gt;&gt; $filepathps -ef | grep svnserve | awk -F \" \" '&#123;if($3==1)print $2&#125;' | xargs kill -9svnserve -d -r $HOME/$svnserver_name/$repository_namemkdir $HOME/svn_test_folderecho \"Hello SVN\" &gt;&gt; $HOME/svn_test_folder/hellosvn.txtcd $HOME/svn_test_foldersvn import . svn://localhost/$repository_name/svn_test_folder --username=root --password=123 -m \"初始化导入\"echo -e \"服务器地址:\\033[0;32;1msvn://root@127.0.0.1/$repository_name\\033[0m\"echo -e \"\\033[0;33;1mroot用户默认密码123\\033[0m\"echo -e \"\\033[0;33;1m$HOME/$svnserver_name/$repository_name/conf 目录下添加用户修改密码就行\\033[0m\"","categories":[{"name":"macos","slug":"macos","permalink":"http://pro.stonepark.fun/categories/macos/"}],"tags":[{"name":"svn","slug":"svn","permalink":"http://pro.stonepark.fun/tags/svn/"}]},{"title":"FastDFS","slug":"FastDFS","date":"2018-02-10T02:16:39.000Z","updated":"2018-03-01T17:13:26.000Z","comments":true,"path":"2018/02/10/FastDFS/","link":"","permalink":"http://pro.stonepark.fun/2018/02/10/FastDFS/","excerpt":"","text":"安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/bin/bash# 第一步：安装gcc环境yum install -y gcc-c++# 第二步：安装libevent，FastDFS依赖libevent库yum install -y libevent# 第三步：安装libfastcommon，libfastcommon是FastDFS官方提供的包，包含了FastDFS运行所需要的一些基础库wget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/libfastcommonV1.0.7.tar.gz\"# 下载fastdfs #最新版可从github上下载 https://github.com/happyfish100/fastdfswget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/fastdfs-5.05.tar.gz\"if [ ! -d \"/usr/local/fastdfs\" ]; then mkdir /usr/local/fastdfsficp ~/soft/libfastcommonV1.0.7.tar.gz /usr/local/fastdfscp ~/soft/fastdfs-5.05.tar.gz /usr/local/fastdfscd /usr/local/fastdfstar -zxvf libfastcommonV1.0.7.tar.gztar -zxvf fastdfs-5.05.tar.gzcd libfastcommon-1.0.7./make.sh &amp;&amp; ./make.sh install# libfastcommon安装好后会自动将库文件拷贝至/usr/lib64下，由于FastDFS程序引用usr/lib目录，所以需要将/usr/lib64下的库文件拷贝至/usr/lib下cp /usr/lib64/libfastcommon.so /usr/lib/cd /usr/local/fastdfs/fastdfs-5.05./make.sh &amp;&amp; ./make.sh install# --- 配置 ------# 拷贝/usr/local/fastdfs/fastdfs-5.05/conf 目录下的文件到/etc/fdfs 目录下if [ ! -d \"/etc/fdfs\" ]; then mkdir /etc/fdfsficp /usr/local/fastdfs/fastdfs-5.05/conf/* /etc/fdfs/cd /etc/fdfs# ★ Tracker配置# in mac os #sed -i '' '/^base_path/s/^/#/' tracker.conf##sed -i '' '/^#base_path/a\\#base_path=/usr/local/fastdfs/tracker#' tracker.conf# in linuxsed -i '/^base_path/s/^/#/' /etc/fdfs/tracker.confsed -i '/^#base_path/a\\\\base_path=\\/usr\\/local\\/fastdfs\\/tracker' /etc/fdfs/tracker.conf# ★ Storage配置#指定storage的组名#group_name=group1#base_path=/usr/local/fastdfs/storage#store_path0=/usr/local/fastdfs/storage#如果有多个挂载磁盘则定义多个store_path，如下#store_path1=.....#store_path2=......#配置tracker服务器IP和端口#tracker_server=192.168.242.140:22122 #如果有多个则配置多个tracker#tracker_server=192.168.101.4:22122filepath=\"/etc/fdfs/storage.conf\"ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`names=(\"group_name\" \"base_path\" \"store_path0\" \"tracker_server\")replace_names=(\"group_name=group1\" \"base_path=\\/usr\\/local\\/fastdfs\\/storage\" \"store_path0=\\/usr\\/local\\/fastdfs\\/storage\" \"tracker_server=$ipaddr:22122\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do #sed -i \"\" \"/^$&#123;names[$i]&#125;/s/^/#/\" $filepath sed -i \"/^$&#123;names[$i]&#125;/s/^/#/\" $filepath #sed -i \"\" \"/^#$&#123;names[$i]&#125;/a\\ #$&#123;replace_names[$i]&#125;\" $filepath sed -i \"/^#$&#123;names[$i]&#125;/a\\\\$&#123;replace_names[$i]&#125;\" $filepath done# 创建目录#mkdir /usr/local/fastdfs/tracker –p#mkdir /usr/local/fastdfs/storage –pif [ ! -d \"/usr/local/fastdfs/tracker\" ]; then mkdir /usr/local/fastdfs/tracker –pfiif [ ! -d \"/usr/local/fastdfs/storage\" ]; then mkdir /usr/local/fastdfs/storage –pfips -ef | grep tracker | awk -F \" \" '&#123;if($8!=\"grep\")print $2&#125;' | xargs kill -9ps -ef | grep storage | awk -F \" \" '&#123;if($8!=\"grep\")print $2&#125;' | xargs kill -9# --- 启动 ------#Tracker启动命令：/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf#Storage启动命令：/usr/bin/fdfs_storaged /etc/fdfs/storage.conf############################################### This script will be executed *after* all the other init scripts.# You can put your own initialization stuff in here if you don't# want to do the full Sys V style init stuff.#设置开机自动启动：#vim /etc/rc.d/rc.local#将运行命令行添加进文件：#/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf#/usr/bin/fdfs_storaged /etc/fdfs/storage.conf############################################## 上传图片测试12345678910111213141516171819202122232425262728293031#第一步：进入/etc/fdfs/ 目录，拷贝一份client.conf文件cd /etc/fdfscp client.conf.sample client.conf# 第二步：修改client.conf#base_path=/usr/local/fastdfs/client#tracker_server=192.168.242.140:22122ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`sed -i '/^base_path/s/^/#/' /etc/fdfs/client.confsed -i '/^#base_path/a\\\\base_path=\\/usr\\/local\\/fastdfs\\/client' /etc/fdfs/client.confsed -i '/^tracker_server/s/^/#/' /etc/fdfs/client.confsed -i \"/^#tracker_server/a\\\\tracker_server=$ipaddr:22122\" /etc/fdfs/client.confmkdir -p /usr/local/fastdfs/client################################################home目录下得有tomcat.png图片.../usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/tomcat.jpg# 上传成功的话 返回图片下载路径# 由于现在还没有和nginx整合无法使用http下载#http://192.168.101.3/group1/M00/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png就是文件的下载访问路径。#对应storage服务器上的磁盘路径：#/usr/local/fastdfs/storage/data/00/00/wKhlBVVY2M-AM_9DAAAT7-0xdqM485_big.png文件 FastDFS 和nginx整合在tracker服务器上安装nginx在每个tracker上安装nginx，的主要目的是做负载均衡及实现高可用。如果只有一台tracker服务器可以不配置nginx。 在storage服务器上安装nginx安装fastdfs-nginx-module1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/fastdfs-nginx-module_v1.16.tar.gz\"cp ~/soft/fastdfs-nginx-module_v1.16.tar.gz /usr/local/fastdfs/cd /usr/local/fastdfstar -zxvf fastdfs-nginx-module_v1.16.tar.gzfilepath=\"/usr/local/fastdfs/fastdfs-nginx-module/src/config\"sed -i \"s/\\/usr\\/local\\/include\\/fastdfs/\\/usr\\/include\\/fastdfs/g\" $filepathsed -i \"s/\\/usr\\/local\\/include\\/fastcommon/\\/usr\\/include\\/fastcommon/g\" $filepathsed -i \"s/\\/usr\\/local\\/lib/\\/usr\\/lib/g\" $filepath#将fastdfs-nginx-module/src下的mod_fastdfs.conf拷贝至/etc/fdfs/下cp /usr/local/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/# 修改mod_FastDFS.conf文件#base_path=/usr/local/fastdfs/storage#tracker_server=192.168.242.140:22122#url中是否包含group名称#url_have_group_name=true#指定文件存储路径，访问时使用该路径#store_path0=/usr/local/fastdfs/storagemodfilepath=\"mod_fastdfs.conf\"ipaddr=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`#ipaddr='192.168.1.101'names=(\"base_path\" \"tracker_server\" \"url_have_group_name\")replace_names=(\"base_path=\\/usr\\/local\\/fastdfs\\/storage\" \"tracker_server=$ipaddr:22122\" \"url_have_group_name=true\")count=$&#123;#names[*]&#125;for (( i=0; i&lt;\"$count\"; i=i+1 ))do sed -i \"/^$&#123;names[$i]&#125;/s/^/#/\" $modfilepath sed -i \"/^#$&#123;names[$i]&#125;/a\\\\$&#123;replace_names[$i]&#125;\" $modfilepath done#\"#[group1]\"##\"store_path0=\\/usr\\/local\\/fastdfs\\/storage\"## linux不能使用/r/n#sed -i \"s/^#\\\\[group1\\\\]/#\\\\[group1\\\\]`echo -e '\\r\\n'`store_path0=\\/usr\\/local\\/fastdfs\\/storage/g\" $modfilepath# 考虑到可能重复执行该脚本, 把之前设置的 注释掉sed -ie \"/^store_path0/s/^/#/\" $modfilepathsed -E -ie \"/^#\\[group1\\]/a\\\\store_path0=\\/usr\\/local\\/fastdfs\\/storage\" $modfilepath# 将libfdfsclient.so拷贝至/usr/lib下cp /usr/lib64/libfdfsclient.so /usr/lib/# 创建nginx/client目录if [ ! -d \"/var/temp/nginx/client\" ]; then mkdir -p /var/temp/nginx/clientfi 安装nginx参考 Linux 安装nginx 唯一不一样的地方是 configure配置 12345678910111213./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi \\--add-module=/usr/local/fastdfs/fastdfs-nginx-module/src 如果之前安装了nginx也没事, 重新编译会生成新的nginx可执行文件, 老的会自动修改成nginx.old 编译安装12makemake install 修改nginx.conf配置文件(有坑)/usr/local/nginx 有conf文件夹, 里面的nginx.conf 才起作用 /usr/local/nginx/nginx-1.8.0/ 也有conf文件夹, 修改这个不起作用 123456789server &#123; listen 80; server_name localhost; location /group1/M00/&#123; #root /usr/local/fastdfs/storage/data; ngx_fastdfs_module; &#125;&#125;","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"FastDFS","slug":"FastDFS","permalink":"http://pro.stonepark.fun/tags/FastDFS/"}]},{"title":"nginx","slug":"nginx","date":"2018-02-09T18:42:32.000Z","updated":"2018-03-01T12:24:24.000Z","comments":true,"path":"2018/02/10/nginx/","link":"","permalink":"http://pro.stonepark.fun/2018/02/10/nginx/","excerpt":"","text":"Linux 安装nginx12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/bash#Nginx是使用C语言开发，安装nginx需要先从官网上将源码下载，然后编译，编译需要gcc环境：yum install -y gcc-c++#PCRE(Perl Compatible Regular Expressions)是一个Perl库，包括 perl 兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式，所以需要在linux上安装pcre库yum install -y pcre pcre-devel#zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库yum install -y zlib zlib-devel#OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。#nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。yum install -y openssl openssl-develwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/nginx-1.8.0.tar.gz\"if [ ! -d \"/usr/local/nginx\" ]; then mkdir /usr/local/nginxficp ~/soft/nginx-1.8.0.tar.gz /usr/local/nginxcd /usr/local/nginxtar -zxvf nginx-1.8.0.tar.gzcd nginx-1.8.0#使用nginx的configure命令进行配置，./configure --help查询详细参数#进行nginx-1.8.0目录执行以下命令（其中prefix参数指定的是nginx的安装目录）：./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgimkdir -p /var/temp/nginx/make &amp;&amp; make installecho ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ls -al /usr/local/nginx 启动 nginx123/usr/local/nginx/sbin/nginxps -ef | grep nginx 重新加载配置文件 当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下： 1/usr/local/nginx/sbin/nginx –s reload nginx停止 123快速停止# 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。/usr/local/nginx/sbin/nginx –s stop 123完整停止（建议使用）# 此方式停止步骤是待nginx进程处理任务完毕进行停止/usr/local/nginx/sbin/nginx –s quit mac 安装 nginx1brew install nginx 123/usr/local/etc/nginx/nginx.conf （配置文件路径）/usr/local/var/www （服务器默认路径）/usr/local/Cellar/nginx/1.13.8 （安装路径） mac的configure 启动brew 已经讲命令放到 /usr/local/bin/nginx, 可以直接执行1nginx Mac下判断配置文件是否正确1nginx -t Mac下重启Nginx1nginx -s reload nginx停止123快速停止# 此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。nginx –s stop 123完整停止（建议使用）# 此方式停止步骤是待nginx进程处理任务完毕进行停止nginx –s quit 关闭进程1ps -ef | grep nginx | grep -v grep | awk &apos;&#123;print $2&#125;&apos; | xargs kill -9 nginx重启先停止再重启 对nginx进行重启相当于先停止nginx再启动nginx，即先执行停止命令再执行启动命令。如下：12nginx –s quitnginx 重新加载配置文件当nginx的配置文件nginx.conf修改后，要想让配置生效需要重启nginx，使用-s reload不用先停止nginx再启动nginx即可将配置信息在nginx中生效，如下： 1nginx –s reload 在 Sublime Text 中使用 SFTP 插件快速编辑远程服务器文件 Sublime-text with SFTP pluginhttp://justcoding.iteye.com/blog/2029825 坑1: 修改hosts文件不起作用使用普通用户开启 nginx 配置 拦截80端口 解析自定义域名时遇到 1ngix -t 结果:123nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is oknginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied)nginx: configuration file /usr/local/etc/nginx/nginx.conf test failed 【Nginx】nginx: [emerg] bind() to 0.0.0.0:80 failed (13: Permission denied) 这是端口号的问题，在Linux中1024以下的端口号都需要root权限才能使用，所以普通用户启动程序绑定会报出权限问题。 使用如下命令启动nginx。 解决办法:关闭nginx , 用管理员启动nginx1sudo nginx 1sudo nginx -t nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok ginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful 坑2: 访问不了html文件之外的资源文件(如 图片等)chmod -R +rx css chmod -R +rx js 至少得有读的权限…蛋疼… sudo 不输入密码echo 密码 | sudo -S nginx -t 反向代理配置12345678server &#123; listen 80; server_name www.tomcat.com; # 用户通过80端口访问 location / &#123; proxy_pass http://localhost:8080; # 去局域网找数据 找到并返回 &#125;&#125; 负载均衡配置1234567891011121314151617# 反向代理upstream www.tomcat_server.com &#123; server localhost:8080 weight=2; #增加权重命中率高,默认都是1 server localhost:8082; server localhost:8083; server localhost:8084;&#125;server &#123; listen 80; server_name www.tomcat_customer.com; location / &#123; proxy_pass http://www.tomcat_server.com; &#125;&#125; Nginx配置文件详细说明http://www.cnblogs.com/xiaogangqq123/archive/2011/03/02/1969006.html","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://pro.stonepark.fun/tags/nginx/"}]},{"title":"mac tomcat多开","slug":"tomcat多开","date":"2018-02-08T20:56:22.000Z","updated":"2018-02-08T21:20:45.000Z","comments":true,"path":"2018/02/09/tomcat多开/","link":"","permalink":"http://pro.stonepark.fun/2018/02/09/tomcat多开/","excerpt":"","text":"Mac自带Apache服务器的使用 打开终端，开启Apache: 12345开启apache: sudo apachectl start重启apache: sudo apachectl restart关闭apache: sudo apachectl stop 回车会提示输入密码，也就是你电脑的密码，http://127.0.0.1/测试一下，成功则如下图： 点击Finder,然后Command+Shift+G,前往Apache服务器的文件路径(/Library/WebServer/Documents)，如图： 在步骤1中只输入一个http://127.0.0.1其实默认打开的是index.html.en(html是一个网页文件)，该文件的内容就是在步骤1中测试时浏览器所显示的内容。此时如果我在浏览器的网址框输入的是http://127.0.0.1/PoweredByMacOSX.gif, 浏览器就便会显示PoweredByMacOSX.gif图片,如果没有正常显示，提示说没有权限时，单击该文件，然后Command+I在末尾设置权限即可。 测试创建一个文件，如test.html(名字能够随意起)，接下来用浏览器访问 http://127.0.0.1/test.htmlIP(127.0.0.1)也可以换成你电脑的IP地址，这样在同一局域网的设备也可以访问服务器的内容。PS:使用过后，记得关闭服务器，要不然会一直消耗你电脑内存，后果你懂的。 tomcat 多开, 前提是已经配好了CATALINA_HOME等的配置只能开7个8082到8088 , 开第8个, 端口冲突…懒得改了, 8080普通tomcat用, 8081私服用.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/bin/bashmkdir -p $HOME/soft/tomcat_clustertomcat_cluster_path=\"$HOME/soft/tomcat_cluster\"tomcat_names=()tomcat_starts=()if [ ! -n \"$1\" ] ;then count=3else count=$1fifor (( i=0; i&lt;\"$count\"; i=i+1 ))do tomcat_names+=(\"tomcat`expr 8082 + $i`\") donefor (( i=0; i&lt;\"$count\"; i=i+1 ))do# echo $&#123;tomcat_names[$i]&#125; mkdir -p $tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/bin cp -R $CATALINA_HOME/conf/ $tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/conf/ cp -R $CATALINA_HOME/webapps/ $tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/webapps/ touch $tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/bin/startup.sh chmod +x $tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/bin/startup.sh filename=\"$tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/bin/startup.sh\" tomcatname=$&#123;tomcat_names[$i]&#125; printf '#!/bin/bash export JRE_HOME=$JAVA_HOME/jreexport CATALINA_HOME=$CATALINA_HOMEexport CATALINA_BASE=\"%s/%s\"export CATALINA_TMPDIR=\"$CATALINA_BASE/temp\"export CATALINA_PID=\"$CATALINA_BASE/bin/tomcat.pid\"export JAVA_OPTS=\"-server -Xms1024m -Xmx1024m -Djava.awt.headless=true -Dtomcat.name=%s\"#创建logs目录if [ ! -d \"$CATALINA_BASE/logs\" ]; then mkdir $CATALINA_BASE/logsfi#创建temp目录if [ ! -d \"$CATALINA_BASE/temp\" ]; then mkdir $CATALINA_BASE/tempfi# 调用tomcat启动脚本bash $CATALINA_HOME/bin/startup.sh \"$@\"' \"$tomcat_cluster_path\" \"$tomcatname\" \"$tomcatname\" &gt; $filename filepath=\"$tomcat_cluster_path/$tomcatname/webapps/ROOT/index.jsp\" sed -i \"\" \"s/&lt;h1&gt;\\$&#123;pageContext.servletContext.serverInfo&#125;/&lt;h1&gt;\\$&#123;pageContext.servletContext.serverInfo&#125; | $tomcatname/g\" $filepath val=`expr $i + 2` serverpath=\"$tomcat_cluster_path/$tomcatname/conf/server.xml\" sed -i \"\" \"s/&lt;Server port=\\\"8005\\\"/&lt;Server port=\\\"80`echo $val`5\\\"/g\" $serverpath sed -i \"\" \"s/&lt;Connector port=\\\"8080\\\"/&lt;Connector port=\\\"808`echo $val`\\\"/g\" $serverpath sed -i \"\" \"s/&lt;Connector port=\\\"8009\\\"/&lt;Connector port=\\\"80`echo $val`9\\\"/g\" $serverpath $tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/bin/startup.sh tomcat_starts+=(\"$tomcat_cluster_path/$&#123;tomcat_names[$i]&#125;/bin/startup.sh\")doneecho \"#!/bin/bash\" &gt; startups.shfor (( i=0; i&lt;\"$count\"; i=i+1 ))do echo $&#123;tomcat_starts[$i]&#125; &gt;&gt; startups.shdoneecho -e \"\\033[0;33;1m■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\\033[0m\"success=`cat startups.sh`echo -e \"\\033[0;32;1m$success\\033[0m\"","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://pro.stonepark.fun/tags/tomcat/"}]},{"title":"Linux搭建开发环境","slug":"Linux搭建开发环境","date":"2018-02-07T18:08:57.000Z","updated":"2018-02-12T07:48:04.000Z","comments":true,"path":"2018/02/08/Linux搭建开发环境/","link":"","permalink":"http://pro.stonepark.fun/2018/02/08/Linux搭建开发环境/","excerpt":"","text":"Linux搭建开发环境 安装jdk1234567#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/jdk-7u55-linux-x64.rpm\"cd ~/softrpm -ivh jdk-7u55-linux-x64.rpm 安装tomcat12345678910111213141516171819#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/apache-tomcat-7.0.79.tar.gz\"tomcat_path=\"/usr/local/tomcat\"if [ ! -d \"$tomcat_path\" ]; then mkdir $tomcat_pathelse rm -rf $tomcat_path mkdir $tomcat_pathficp ~/soft/apache-tomcat-7.0.79.tar.gz $tomcat_path/cd $tomcat_pathtar -zxvf apache-tomcat-7.0.79.tar.gz 安装zookeeper123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/zookeeper-3.4.6.tar.gz\" if [ ! -d \"/usr/local/dubbo\" ]; then mkdir /usr/local/dubboelse rm -rf /usr/local/dubbo mkdir /usr/local/dubboficp ~/soft/zookeeper-3.4.6.tar.gz /usr/local/dubbocd /usr/local/dubbotar -zxvf zookeeper-3.4.6.tar.gzcd zookeeper-3.4.6/confcp zoo_sample.cfg zoo.cfg#sed -i '' '/eth1/s/^/#/' file# on mac os# sed -i '' '/^dataDir/s/^/#/' zoo.cfg# on linuxsed -i '/^dataDir/s/^/#/' zoo.cfg# in macos#sed -i '' '/^#dataDir/a\\#dataDir=/usr/local/dubbo/zookeeper-3.4.6/data#' zoo.cfg# in linuxsed -i '/^#dataDir/a\\\\dataDir=/usr/local/dubbo/zookeeper-3.4.6/data' zoo.cfgcd ../bin./zkServer.sh restart./zkServer.sh status 安装监控中心123456789101112131415161718192021222324252627282930313233#!/bin/bashwget -P ~/soft/ \"http://ou0y29lb2.bkt.clouddn.com/dubbo-admin-2.5.4.war\"cp ~/soft/apache-tomcat-7.0.79.tar.gz /usr/local/dubbocd /usr/local/dubbotar -zxvf apache-tomcat-7.0.79.tar.gzcp ~/soft/dubbo-admin-2.5.4.war apache-tomcat-7.0.79/webapps/cd /usr/local/dubbo/apache-tomcat-7.0.79/webappsvar=\"dubbo-admin-2.5.4.war\"tmp=$&#123;var##*/&#125;path=$&#123;tmp%.*&#125;if [ ! -d \"./$path\" ]; then mkdir ./$pathfiunzip -oq dubbo-admin-2.5.4.war -d ./$pathip_address=`ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6|awk '&#123;print $2&#125;'|tr -d \"addr:\"`sed -i \"s/127.0.0.1/$ip_address/g\" ./dubbo-admin-2.5.4/WEB-INF/dubbo.propertiesrm dubbo-admin-2.5.4.war/usr/local/dubbo/apache-tomcat-7.0.79/bin/startup.shsuccess=\"打开 http://$ip_address:8080/dubbo-admin-2.5.4\"echo -e \"\\033[0;32;1m$success\\033[0m\" 管理员账号密码是 root root linux mac下使用sed a\\追加文本由于mac系统是原生于bsd系，sed命令和gnu不同，如果想用sed实现在某一行插入一行文本。gnu sed:1sed &quot;$line a\\\\(多加一个\\，防止后面的$value被转义)$value&quot; $file mac sed:123sed &quot;$line a\\ (注意此处有空格,要在下一行添加文本) $value(如果想换行要把&quot;写到下一行) &quot; $file 示例：在test.txt第二行插入xxxgnu:1sed &quot;2 a\\\\xxx&quot; test.txt mac:123sed &quot;2 a\\ xxx &quot; test.txt i\\是在某一行之前插入，操作和a\\一样。 Linux下开启关闭防火墙Linux下启动apache server之后，由于防火墙的原因不能远程访问(本机可以)，接下来介绍下Linux下如何关闭防火墙. 解决方案 #临时关闭，即时生效，重启失效 关闭防火墙1$ service iptables stop 开启防火墙1$ service iptables start #永久关闭，重启生效 关闭防火墙1$ chkconfig iptables off 开启防火墙1$ chkconfig iptables on Linux下防火墙开启相关端口及查看已开启端口1234/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT #开启80端口 /sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT #开启22端口 /etc/rc.d/init.d/iptables save #保存配置 /etc/rc.d/init.d/iptables restart #重启服务 查看已开放端口1/etc/init.d/iptables status 结果如下 able: filter hain INPUT (policy ACCEPT) um target prot opt source destination ACCEPT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 ACCEPT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 你可以使用 lsof 命令来查看某一端口是否开放。查看端口可以这样来使用，我就以80端口为例：1lsof -i:80 如果有显示说明已经开放了，如果没有显示说明没有开放。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/tags/Linux/"}]},{"title":"如何解决VMware克隆虚拟机无法上网","slug":"如何解决VMware克隆虚拟机无法上网","date":"2018-02-07T15:16:30.000Z","updated":"2018-02-09T21:11:37.000Z","comments":true,"path":"2018/02/07/如何解决VMware克隆虚拟机无法上网/","link":"","permalink":"http://pro.stonepark.fun/2018/02/07/如何解决VMware克隆虚拟机无法上网/","excerpt":"","text":"如何解决VMware克隆虚拟机无法上网 在VMware上安装的一个centos系统，克隆之后网卡eth0变成了eth1，而且还找不到eth1的配置文件，克隆的虚拟机网卡总是会出现各种问题。 克隆之后eth0变成了eth1,但是网卡配置文件ifcfg-eth1不存在。即使有IP地址，也无法编辑 服务器只有一块网卡，/etc/udev/rules.d/70-persistent-net.rules中有两条网卡信息 克隆主机的eth0网卡MAC为 00:0c:29:3c:9b:42 被克隆主机eth0网卡MAC为 00:0C:29:3C:9B:42 两个主机的MAC相同，克隆主机就“舍弃”eth0，重新“生成”了网卡eth1。即使eth1能获取到IP，ifcfg-eth1配置文件不存在还是不行 vi /etc/udev/rules.d/70-persistent-net.rules 注释掉eth0这一行，将第二条配置中的eth1改成eth0 保存退出重启系统 重启完成eth1变成了eth0，并且ifcfg-eth0的配置文件生效了 匹配行 行首 添加macos:sed -i ‘’ ‘/eth1/s/^/#/‘ file linux: sed ‘/eth1/s/^/#/‘ file 做成shell脚本, 只能执行一次…12345678910sudo sed -i '/eth0/s/^/#/' /etc/udev/rules.d/70-persistent-net.rulessudo sed -i '/eth1/s/eth1/eth0/' /etc/udev/rules.d/70-persistent-net.rules#sudo rebootcat /etc/udev/rules.d/70-persistent-net.rules | grep eth0success=\"可以重启了， 执行命令 sudo reboot\"echo -e \"\\033[0;32;1m$success\\033[0m\"","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://pro.stonepark.fun/tags/Linux/"}]},{"title":"svn","slug":"svn","date":"2018-02-07T01:59:20.000Z","updated":"2018-02-07T02:08:02.000Z","comments":true,"path":"2018/02/07/svn/","link":"","permalink":"http://pro.stonepark.fun/2018/02/07/svn/","excerpt":"","text":"svn svn 1.7版本以上的坑…终端每次看log日志要输入密码解决办法https://stackoverflow.com/questions/2899209/how-to-save-password-when-using-subversion-from-the-console In ~/.subversion/config, you probably have store-passwords = no. Change it to yes (or just comment it out because it defaults to yes), and the next time you give Subversion your password it should save it. You might want to ensure that the owner and permissions of ~/.subversion/config are correct (no public or group access; 600). 如果看不到log日志… 修改成none","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"svn","slug":"svn","permalink":"http://pro.stonepark.fun/tags/svn/"}]},{"title":"docker","slug":"docker","date":"2018-02-06T16:14:40.000Z","updated":"2018-02-06T18:21:01.000Z","comments":true,"path":"2018/02/07/docker/","link":"","permalink":"http://pro.stonepark.fun/2018/02/07/docker/","excerpt":"","text":"docker镜像操作查看本地镜像1$ docker images REPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest c54a2cc56cbb 9 weeks ago 1.848 kB 在线查找镜像：1$ docker search tomcat 通常第一条为官方镜像，即Docker Hub中的镜像。官方镜像会在OFFICIAL一列显示[OK]字样，另外，STARS一列的星星数量显示了该镜像的受欢迎程度，星星越多，表明用的人越多，不过为安全起见，通常建议首选官方镜像或自制镜像，而不是第三方的。 拉取镜像使用docker pull [镜像名称[:版本]]可以拉取一个镜像： 注： 完整的镜像名称由[repository]/name:[tag]构成，[repository]为仓库，如果省略,则默认为library,即从Docker Hub拉取；如果省略tag,则默认拉取latest版本，name为镜像名称，不能省略。 1$ docker pull tomcat:7 一个好的实践是，拉取镜像时，总是指定一个明确的版本，这样能确保在接下来的使用中，明确知道使用的是哪个版本。因为latest版本总是指向最新的版本，这将造成不确定性。 删除镜像删除一个镜像前，需要先停止使所有用它的容器，否则会报错，或者使用 -f选项强制删除。 1$ docker rmi tomcat:7 导入导出镜像导出镜像：1docker save 镜像 &gt; /root/xx.tar.gz 导入镜像：1$ docker load &lt; /root/xx.tar.gz 制作镜像1docker commit 容器名称或者容器ID 新镜像名称 容器操作创建容器以交互方式启动容器：1docker run -it --name 容器名称 镜像 /bin/bash 以守护进程方式启动容器：1docker run -d --name 容器名称 镜像 Example:1$ docker run -d --name tomcat001 -p 8081:8080 tomcat:7 其中，-d 指定容器在后台运行；–name用于指定容器的名称；-p 8888:8080 用于将容器内的8080端口映射到主机的8081端口，你也可以换成其他本机端口.如果需要，你可以创建多个容器使用，需要注意的是，本机映射的端口不能重复，name也不能重复。 查看当前容器123$ docker ps 查看正在运行的容器$ docker ps -a 查看历史运行过的容器$ docker ps -l 查看最近运行过的容器 查看容器日志使用 docker logs 容器名称可以查看容器的日志输出，-f选项可以指定实时输出最新日志，类似于Linux 下的tail -f命令。 1$ docker logs -f tomcat001 停止容器1$ docker stop tomcat001 启动容器1$ docker start tomcat001 删除容器删除一个容器前，需要先停止容器，否则，需要使用 -f选项强制删除(不推荐)。1$ docker rm tomcat001 删除所有容器：1docker rm &apos;docker ps -a -q&apos; 搭建Tomcat服务1docker run -d --name my-tomcat -p 8888:8080 镜像 说明：8888端口是宿主机的端口8080端口是容器内的端口 部署web应用 将war包上传到宿主机器 通过docker cp命令将宿主机器的war包上传到容器中tomcat的webapps目录下。 1docker cp /root/docker.war 容器名称或者容器ID:/usr/local/tomcat/webapps tomat会自动热部署，直接访问web应用的路径即可。 做成shell 创建dkcp.sh 12#!/bin/bashdocker cp $1 $2:/usr/local/tomcat/webapps .bash_profile中1alias dkcp=&quot;bash $HOME/shell/dkcp.sh&quot; #$1 war包路径, $2 容器名 or 容器id docker 后台运行和进入后台运行的容器1docker exec -it ContainerName /bin/bash exec的 用exit也不会真正退出容器继续后台运行 用name或id都可以 1docker exec -it ContainerName Command 是执行完命令就退出放在后台比如 ps -ef 显示内容然后就退出前台 如果要进入容器就用/bin/bash 前提是容器要正在运行 如果不是running就先 docker start containername","categories":[{"name":"其他","slug":"其他","permalink":"http://pro.stonepark.fun/categories/其他/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://pro.stonepark.fun/tags/docker/"}]},{"title":"links","slug":"links","date":"2018-02-03T17:34:58.000Z","updated":"2018-02-14T04:57:34.000Z","comments":true,"path":"2018/02/04/links/","link":"","permalink":"http://pro.stonepark.fun/2018/02/04/links/","excerpt":"","text":"linksjsonparser http://json.parser.online.fr/regex101: https://regex101.com/regex_on_line: http://tools.jb51.net/regex/create_regCode4App: http://www.code4app.com/category/gestureCocoaChina: http://www.cocoachina.com/huaban: http://huaban.com/pinspinterest: https://www.pinterest.com/500px: https://500px.com/zcool: http://www.zcool.com.cn/cocoacontrols: https://www.cocoacontrols.com/123.th7.cn: http://123.th7.cn/list/list_33_1.htmlcode4app.net: http://code4app.net/forum.phpwallpaperswide: http://wallpaperswide.com/wooden_path_2-wallpapers.htmlproject_code: http://www.code4app.com/forum-2-1.html?&amp;sid=3|125swift: http://swift.ctolib.com/codeschool: https://www.codeschool.com/JavaScriptOnLineTest: http://tools.jb51.net/regex/javascriptJavaScriptOnlineGeneration: http://tools.jb51.net/regex/create_reg","categories":[{"name":"links","slug":"links","permalink":"http://pro.stonepark.fun/categories/links/"}],"tags":[{"name":"links","slug":"links","permalink":"http://pro.stonepark.fun/tags/links/"}]},{"title":"常用的三方库Podfile","slug":"常用的三方库Podfile","date":"2016-08-27T18:05:43.000Z","updated":"2016-08-27T18:06:51.000Z","comments":true,"path":"2016/08/28/常用的三方库Podfile/","link":"","permalink":"http://pro.stonepark.fun/2016/08/28/常用的三方库Podfile/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# Uncomment this line to define a global platform for your project# platform :ios, '9.0'target 'Risk' do # Uncomment this line if you're using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for Riskend#/***************EF使用的三方库 ************/#三方登录分享pod 'libWeChatSDK', '~&gt; 1.5'pod \"WeiboSDK\", :git =&gt; \"https://github.com/sinaweibosdk/weibo_ios_sdk\"pod 'TencentOpenApiSDK'pod 'MJRefresh', '~&gt; 3.1.0’pod 'AFNetworking', '~&gt; 2.5.4’pod 'ELCImagePickerController', '~&gt; 0.2.0'pod 'YYModel'pod 'iRate', '~&gt; 1.11.3'pod 'Reachability', '~&gt; 3.0.0'pod 'XHImageViewer', '~&gt; 0.1.2'pod 'SDWebImage', '~&gt; 3.7.2'#pod 'HYBUnicodeReadable', '~&gt; 1.3'pod 'libWeChatSDK', '~&gt; 1.5'pod 'SVWebViewController', '~&gt; 1.0'pod 'AlipaySDK-2.0'#/***************EF使用的三方库 *********end/pod 'WZLBadge', '~&gt; 1.2.1' #小红点#pod 'MLeaksFinder' #内存管理pod \"HYBLoopScrollView\", '~&gt; 3.0.0' #轮播pod 'MBProgressHUD', '~&gt; 0.9'pod 'FontIcon', '~&gt; 1.0'pod 'AlipaySDK-2.0'pod 'JPush'pod 'RETableViewManager'pod 'UIScrollView+PullBig'pod 'UMengAnalytics-NO-IDFA'pod 'HyphenateSDK', :git =&gt; 'https://github.com/easemob/hyphenate-cocoapods.git'#pod 'EaseMobSDKFull', :git =&gt; 'https://github.com/easemob/sdk-ios-cocoapods-integration.git'pod 'TZImagePickerController' #图片选择pod 'Masonry' #AutoLayout(视频播放界面用到了)pod 'DZNEmptyDataSet' #tableView 没数据时提示页面pod 'FLEX', '~&gt; 2.0', :configurations =&gt; ['Debug'] #An in-app debugging and exploration tool for iOSplatform :ios, '7.0'pod 'FDFullscreenPopGesture', '1.1'pod 'IQKeyboardManager', '~&gt; 3.3.6'pod 'FXBlurView', '~&gt; 1.6.4'pod 'SFHFKeychainUtils', '~&gt; 0.0.1'pod 'SDAutoLayout', '~&gt; 1.52'pod 'NJKWebViewProgress'","categories":[],"tags":[]},{"title":"版本：Swift","slug":"版本：Swift","date":"2016-08-27T15:54:08.000Z","updated":"2016-08-27T16:02:44.000Z","comments":true,"path":"2016/08/27/版本：Swift/","link":"","permalink":"http://pro.stonepark.fun/2016/08/27/版本：Swift/","excerpt":"版本：Swiftgithub排名 https://github.com/trending,github搜索：https://github.com/search 主要工作说明： 将Swift从Objective-C混合的md文件中抽出（正在进行…） 使用方法：根据目录关键字搜索，记得包含@，以保证搜索目录关键字的唯一性。 问题反馈：请广大网友只按照目录结构（即使目录结构有问题）添加三方库，并pull request。目录问题大家提出issues后楼主会及时更改的。 目录 Github用法@ 完整App@ App框架@ 响应式框架@ UI@ 日历三方库@ 下拉刷新@ 模糊效果@ 富文本@ 图表@ 颜色@ 表相关@(TabbleView、Tabbar、即时聊天界面)) 隐藏与显示@ HUD与Toast@ 对话框@ 状态栏@ 导航栏@ 设置@ 其他UI@ 动画@ 侧滑与右滑返回手势@ gif动画@ 其他动画@ AutoLayout@ 网络@ 网络连接@ 图像获取@ 网络聊天@ 网络测试@ 网页框架@ 网络解析@ CSV 开发资料@ 学习资料@ GitHub@ 他人开源总结@ 开发博客列表@ 学习笔记、书籍@ 设计@ 好的文章@ 美工资源@ 开发工具@ Xcode插件@ 好用的软件@ Cagegory@ 测试及调试@ 数据存储@ 缓存处理@ 数据库@ CoreData@ WebView与WKWebView@ 游戏@ FaceBook@ 通讯录@ 其他库@ 三方分享、支付、登录等等@ PDF@ 图像浏览及处理@ 摄像照相视频音频处理@ 视频@ 消息相关@ 消息推送客户端@ 消息推送服务器端@ 通知相关@ 时间日期@ 设计模式@ 版本新API的Demo@ 代码安全与密码@ 动态更新@ AppleWatch@ VPN@","text":"版本：Swiftgithub排名 https://github.com/trending,github搜索：https://github.com/search 主要工作说明： 将Swift从Objective-C混合的md文件中抽出（正在进行…） 使用方法：根据目录关键字搜索，记得包含@，以保证搜索目录关键字的唯一性。 问题反馈：请广大网友只按照目录结构（即使目录结构有问题）添加三方库，并pull request。目录问题大家提出issues后楼主会及时更改的。 目录 Github用法@ 完整App@ App框架@ 响应式框架@ UI@ 日历三方库@ 下拉刷新@ 模糊效果@ 富文本@ 图表@ 颜色@ 表相关@(TabbleView、Tabbar、即时聊天界面)) 隐藏与显示@ HUD与Toast@ 对话框@ 状态栏@ 导航栏@ 设置@ 其他UI@ 动画@ 侧滑与右滑返回手势@ gif动画@ 其他动画@ AutoLayout@ 网络@ 网络连接@ 图像获取@ 网络聊天@ 网络测试@ 网页框架@ 网络解析@ CSV 开发资料@ 学习资料@ GitHub@ 他人开源总结@ 开发博客列表@ 学习笔记、书籍@ 设计@ 好的文章@ 美工资源@ 开发工具@ Xcode插件@ 好用的软件@ Cagegory@ 测试及调试@ 数据存储@ 缓存处理@ 数据库@ CoreData@ WebView与WKWebView@ 游戏@ FaceBook@ 通讯录@ 其他库@ 三方分享、支付、登录等等@ PDF@ 图像浏览及处理@ 摄像照相视频音频处理@ 视频@ 消息相关@ 消息推送客户端@ 消息推送服务器端@ 通知相关@ 时间日期@ 设计模式@ 版本新API的Demo@ 代码安全与密码@ 动态更新@ AppleWatch@ VPN@ ======== 具体内容 ===================================== 下拉刷新@ ZLSwiftRefresh - swift下拉刷新/上拉加载更多，支持自定义动画，集成简单，兼容UITableView/CollectionView/ScrollView/WebView。 BreakOutToRefresh - swift，上拉和下拉刷新。 GearRefreshControl - swift，上拉和下拉刷新。 refresher - swift，上拉和下拉刷新。 ReplaceAnimation.swift - 基于 @ZeeYoung欧阳哲 同学的创意下拉刷新动画实现。值得称赞还有额外增加了“取消及滚动”效果支持。 PullToReflesh-Swift - 一款炫酷的下拉刷新封装库（Mobile page refresh concept inspired by Google and for something like a news app）。源码分析 pull-to-refresh.swift - 是一款非常易于开发者使用的下拉刷新和加载更多组件。通过一个 UIScrollView 的扩展，可以轻松为 UIScrollView 的所有子类添加下拉刷新功能。 模糊效果@ Blurable.swift - swift模糊组件。 AutoLayout@ Neon.swift - 功能强大的 UI 布局神器。 EasyPeasy.swift - 编程方式自动布局框架库。 Snap - Snap是Masonry Auto Layout DSL的Swift版本，是一款轻量级的布局框架，使用了更良好的语法封装了AutoLayout。Snap支持iOS和OS X。 富文本@ RichEditorView - swift，一套可定制富文本编辑器组件及示例。功能完整、代码简练、实现逻辑巧妙（编辑器核心与 WebView 结合，采用 HTML5 contentEditable 编辑模式，执行JS 配套命令 execCommand 实现富文本编辑功能）。 SwiftyMarkdown.swift - 用swift写的markdown解析库。 Marklight.swift - Markdown 语法高亮显示编辑库（Swift）。 LTMorphingLabel - swift 能够实现文字变形动画效果的Label，用Swift写的一个能够实现文字变形动画效果的Label，很炫。 Splitflap.swift - 可用于快速给 iOS 应用创建文字翻转的动画效果。 FloatLabelFields.swift - FloatLabelFields.swift浮动标签输入效果类。 cleartext-mac.swift - 提供一千个常用单词的编辑器。 GlitchLabel.swift - 可定制“黑（故障）文字标签”类库，熟称晃瞎你的眼文字标签。 图表@ swift-linechart - 功能完整、实用的折线图组件。使用方便，参数配置简单。是不可多得的优质组件–swift。 ios-charts - 一款优秀 Android 图表开源库 MPAndroidChart 的 Swift 语言实现版（支持 Objective-C 和 Swift 调用）。缺省提供的示例代码为 Objective-C。 Scrollable-GraphView.swift - 灵动感十足的自适应、可定制滚动曲（折）线图表库。 表相关、TabbleView、Tabbar、即时聊天界面@ Eureka.swift - Eureka 是 XLForm 的 Swift 的移植版本, 一个可以帮助开发者们快速构建 iOS 各种复杂表单的库, 具有较高的可扩展性, 方便自定制样式。 HBHorizontalTableView - swift，TableView 横向滚动小示例（仿照 AppStore 应用展示）。 Chats - 聊天 UI 示例程序。此项目应该只为演示或学习之用，没有服务器 – swift。 Chatto.swift - Chatto.swift:轻量级聊天应用框架及示例。文字及图片可扩展输入栏，汽泡效果等聊天核心特性，分页及自动布局完善。 COBezierTableView - swift，通过编辑 Bezier 曲线四点位置设置 TableView 内 Cell 及对应按扭位置。实验效果很赞。 LxTabBarController - 改变了原生tabbar切换tab时的生硬效果，并加入滑动切换手势（有和界面上的其它手势发生冲突的风险，可根据具体项目予以关闭），swift版本。 Sapporo - swift 单元格模型驱动的集合视图管理器组件。又一个超实用的“轮子”。 NavTopImage.swift - NavigationController动态缩放titleView。 paper-onboarding.swift - 漂亮的 material design 风格页面滑块。示例完整，易用。 Material.swift - 基于 Material Design 动画和图像框架库 （作者 Daniel Dahan）。 ReorderableGridView-Swift - 拖拽排序卡片。 ZYThumbnailTableView.swift - 可展开型预览TableView，开放接口，完全自由定制。实现教程 WHC_CollectionViewFramework.swift - 高仿支付宝可拖拽排序编辑动画效果cell的CollectionView集合视图。 SwipeViewController.swift - 一款好用的页面滑动和标签选项卡类库及示例。功能相当于 Objective-C 版 RKSwipeBetweenViewControllers。 TabDrawer.swift - 更适合单手操作的可定制 Tab Bar 组件库。P.S. 自动布局选择了 EasyPeasy。 SFFocusViewLayout.swift - UICollectionViewLayout实现的图片浏览器。 ESTabBarController.swift - 自定义TabBarController组件，继承自UITabBarControlle，可添加动画和自定义样式。swift 高度自定义TabBarController，支持自定义TabBarItem样式或添加动画 隐藏与显示@HUD与Toast@ Toast-Swift - 高可定制易用的 Toast 弹出信息或通知用户界面组件类。 对话框@ SwiftyDrop - 轻量、易用的小清新弹出列表及信息提示组件真心不错。 PCLBlurEffectAlert.swift - 细节定制较丰富的弹出警报窗口组件。 GSAlert.swftt - 苹果在iOS8推出了全新的UIAlertController，旧的UIAlertView和UIActionSheet渐渐被废弃，但如果你仍然支持iOS7系统，你将不得不写两套代码。GSAlert解决了这个问题。 TKSwarmAlert.swift - TKSwarmAlert.swift:模仿 Swarm app 的 Alert 提醒框动画工具。 PMAlertController.Swift - 可定制弹窗组件替代官版不可定制的 UIAlertController。 TBActionSheet.swift - 支持Carthage，可自定义度100%的 ActionSheet，支持微信样式。 状态栏@导航栏@设置@Switch@日历@ FSCalendar 一个包含objective-c和Swift版本的优秀的日历 其他UI@ KDCircularProgress - KDCircularProgress是使用swift制作的色彩炫丽的进度条，可以加入多种颜色来控制进度条的渐变效果。 RandomColorSwift - 一个自动生成好看的颜色的 Swift 库，RandomColorSwift。 Hue.Swift - Hue.Swift：颜色常规功能集于一身的定义、使用 Color 工具类库（含图片取色）。 KtColor.swift - 利用 Swift 的语法特性简化创建 UIColor对象的过程。具体文章可以参考博客：当UIColor遇上 Swift。 YPDropMenuViewDemo.swift - 一款DropMenu,menuView,类似之前美团的下拉菜单，支持swift2.2，因为用到iOS8.的毛玻璃。所以想支持到iOS8.0,支持自定义，支持等宽排列，支持从左向右排列。 ZMaterialDesignUIButton - Swift Material Design UIButton。 Twinkle - 为字体加上钻石版闪耀的效果。使用Swift编写。 Persei - 非常赞 动画隐藏或显示顶部菜单支持库及示例项目。–swift DateRangePicker.swift - 可能是目前最好的 OS X 日期选择器,高扩展性，界面风格看起来很舒服，不过注意，是 OS X 开发专用。 SwiftyFORM - swift 表单输入框架（亮点是表单验证规则引擎），是我见过地最易用的 Swift 表单组件。 SwiftSpinner - SwiftSpinner是使用swift制作的一款精致带感的指示器，并且连带有字体信息显示，模糊背景，半透明，扁平化等IOS8的效果。 AKPickerView-Swift - 一款小而美的 3D 效果选择器。 iOS-RatingBar - iOS-RatingBar swift版的评分控件,跟Android的RatingBar一样有两种模式，评分模式和只读模式’支持视图编辑，自定义星星数量，评分等级,另外还能支持非整数星，0.5颗星，0.1颗星,可以开启动画效果。 LxGridView-oc LxGridView-swift - 利用UICollectionView模仿iOS系统桌面图标的交互，作用如动图。 GMStepper - swift 带动画效果、支持手势滑动操作的步进标签。 LayoutTrait - swift 一个小类库。 做iPad 多任务分屏 适配的同学可以看一下。 BTNavigationDropdownMenu - 下拉列表暨导航标题组件。简单、直接、易用 -swift。 InceptionTouch.swift - 让没有 3D Touch 设备也有类似交互体验的 InceptionTouch 类（基于 UITextView 实现，支持日期，链接，电话号码，地址触摸响应）。 TWControls.swift - 简单的开关和按钮控制器,使用闭包来执行由控件触发的操作。 Instructions.swift - 可定制嵌入式操作指引框架及演示。 SMSegmentView.swift - 高可定制化，既支持横向，也支持纵向布局的图文 Segment Control 组件，节选器。 Gecco.Swift - Gecco.Swift 是一款支持对视图进行局部高亮的 Swift 库, 帮助 iOS 开发者快速创建产品的新手指导界面。 SubtleVolume.swift - 更隐蔽的系统音量替代指示器。 InkKit.swift - 该类库帮助开发者绘制简单图形更容易。 SwiftSVG - 支持多种接口（String, NS/UIBezierPath, CAShapeLayer, and NS/UIView）绘制 SVG 类库。 LeeGo.swift - 带来更 声明式的，可配置的和易复用的UI开发方式，让UI开发变得像玩乐高积木一样简单直观，某种程度上取代ComponentKit。用 struct 和 enum 来构建你的整套 UI Caishen.swift - 简易、实用的付款输入及校验 UI 组件。 StackViewController - 方便 iOS 开发者使用 UIStackView 构建表单或其它静态内容视图。 LLBootstrapButton - Bootstrap 3.0扁平化风格按钮，自带图标，一句代码直接调用！ JMRoundedCorner - UIView设置不触发离屏渲染的圆角！ 其他UI@ ZSeatSelector - 电影院位置排座位，电影选座。 JMRoundedCornerSwift - swift版本：UIView设置不触发离屏渲染的圆角！ ======== 动画@游戏@侧滑与右滑返回手势@ SideMenu - swift实现，一款带动画效果可定制 Slide Menu，可以学习其动画实现思路。P.S. 对于Hamburger式菜单，虽然很常用，不过，苹果并不鼓励使用，甚至有开发小组对其弊病用自家上线应用前后数据对比进行了抨击。 QQConfiguration - swift，QQ-iPhone端框架，左侧菜单栏拖动手势。 SwiftPages - 高可定制类似 Instagram 视图滑动切换功能类库。API 简单、易用。 FlowingMenu.swift - 菜单如此出场方式（橡皮筋弹跳式动画）好玩又有趣。 gif动画@ YLGIFImage-Swift - YLGIFImage-Swift。 gifu.Swift - gifu.Swift高性能GIF显示类库。 droptogif - droptogif视频拖拽到应用窗口后自动转换为 GIF 动画（其转换进程动画效果也超赞）。 JWAnimatedImage.swift - JWAnimatedImage.swift集中了目前主流的 GIF 显示库(如 FLAnimatedImage,Gifu 等)的优点，进行重构，代码短小精悍。而且使用了新的 frame 提取算法。 SwiftyGif - 高性能 Gif 播放引擎。 PHImageKit.swift - 出自 Product Hunter 开发小组的带下载、缓存的 GIF 播放组件库。使用简单又方便。 其他动画@ popping - popping是一个POP 使用实例工程 PopMenu - 用POP动画引擎写的Sina微博的Menu菜单。 MZGuidePages - 自己写的通用导航页，可以直接引入工程使用，请参考案例（版本新特性、导航页、引导页）。 Wizardry.swift - 可重用的方法和框架实现向导式用户界面管理。（版本新特性、导航页、引导页）。 Spring - Spring是一个Swift编写的开源库，可简化Swift编写的iOS动画。支持shake、pop、morph、squeeze、wobble、swing、flipX、flipY、fall、squeezeLeft、squeezeRight以及squeezeDown等多种动画形式，用 IBDesignable 让使用者可以在 Xcode 中快速设置动画效果。 JGTransitionCollectionView - swift，基于集合视图扩展实现完成自动布局及单元项 Flip式动画效果（效果很赞）。组件使用方便、自然（只需设置集合视图数据源的标准方式即可）。 KYShareMenu - 带弹性动画的分享菜单。 BuildAnInfiniteCarousel - 自己动手造无限循环图片轮播，教程。 tispr-card-stack - swift 卡片风格动画切换组件及完整交互示例。 ZLSwipeableViewSwift - swift 卡片堆叠效果的实现（ZLSwipeableView)】可实现类似Tinder和Potluck应用程序的卡片堆叠效果，该项目基于ZLSwipeableView objective-c实现。1.自定义动画。2.自定义滑动切换。3.自定义方向。4.撤销。 Koloda - 基于卡片的 Tinder-style 动画效果示例。精细绝人。更赞的是额外附了详细开发教程 How We Built Tinder-Like Koloda Animation in Swift 网页链接 。Yalantis 出品动画程序款款精品。 KDIntroView - swift 动态介绍视图框架及演示。另外两个相似的类库是 RazzleDazzle和 Presentation，择需使用。 RazzleDazzle - 【IFTTT开源Swift编写的帧动画框架–RazzleDazzle】RazzleDazzle 是IFTTT开源的一个iOS帧动画框架，非常适用于APP初次使用时的介绍和引导信息。JazzHands是UIKit一个简单的关键帧基础动画框架，可通过手势、scrollview、KVO等控制动画，被IFTTT应用在IFTTT for iPhone上。 SIFloatingCollection_Swift - 可定制的 Apple Music 风格浮动形状动画组件及演示。 CKWaveCollectionViewTransition - swift， UICollectionViewController之间切换的动画。 CardsAnimationDemo - swift， 《使用 UICollectionView 实现的一个卡片动画》不是直接操作所有 UIView 和 CALayer 的 transform3D 属性来实现整个效果的，而是使用 UICollectionView 来完成所有的视图管理和实现。 TKRubberIndicator.swift - 一个很不错的 page control。 TTGEmojiRate.swift - TTGEmojiRate.swift以Emoji表情为基础绘图，Swift开源项目: TTGEmojiRate的实现。 CardAnimation.swift - CardAnimation 是国人开发的一个用 Swift 实现卡片垂直翻转动画的 Demo, 实现思路。 CoreAnimationCode.swift - 提供了 “iOS Core Animation Advanced Techniques” 书籍中的代码实例, 方便开发者们进行参考学习。 UIViewXXYBoom.swift - 一个炫酷好玩的爆炸效果，如何实现这个效果。 ZLSwipeableViewSwift - ZLSwipeableView - ZLSwipeableViewSwift在Tinder and Potluck中的动画效果实现思路（连续卡片翻页效果），最贴心的是作者提供了OC和Swift两个版本来供开发者使用，非常丝滑顺畅的效果。 RYCuteView - 用UIBezierPath实现果冻效果。 教程 IBAnimatable.swift - 第三方开源库IBAnimatable可以帮助我们在Interface Builder和Swift Playground里面设计UI, 交互, 导航模式, 换场和动画。整个App 都是通过 IBAnimatable 在Interface Builder 设计完成，没有任何一行代码。 MotionMachine.swift - 功能强大、优雅、模块化动画库。 circle-menu.swift - 动画效率很赞的圆形缩放菜单演示及类库。 BWWalkthrough.swift - BWWalkthrough.swift界面切换中加入灵动的动画效果。 hamburger-button.swift - hamburger-button.swift一个汉堡包动画关闭按钮。 HamburgerButton.swift - HamburgerButton.swift一个汉堡包动画返回按钮。 MDCSwipeToChooseView - MDCSwipeToChooseView翻牌子效果。 Advance.swift - 简单易用、功能强大的动画框架库。在手势交互、帧动画、自定义动画及仿真类型将是不错的选择。 HWAnimationTransition_Swift 、HWAnimationTransition_OC - 类似于格瓦拉启动页中的放大转场动画（objective-C &amp;&amp; Swift）。教程 NumberMorphView.swift - 可爱的数字补间（变身）动画类库。 DisplaySwitcher.swift - 两个集合视图在不同布局（平铺和列表）间平滑切换。Yalantis 出品。 DynamicButton.swift - 一套完整、且带动画过渡的图标按钮库。 TKDotSegment.swift - 是一个带有圆点动画的 segment。 LiquidLoader.swift - 液态加载动画的轻量级 UI 组件。 15DaysofAnimationsinSwift - 15DaysofAnimationsinSwift动画。 Interpolate.swift - 手势驱动交互式转场动画框架库。这个很专业，且非常有意思。 PeekPop.swift - 3DTouch动画组件。 fantastic-ios-animation.swift - 基于 UI 组件类别分类，且带精彩动画效果的 iOS 组件库集合。 GridPanelDemo 赞，一个点击翻转的动画Demo ======== 网络@网络连接@ SwiftRouter - A URL Router for iOS, written in Swift 2.2 :large_orange_diamond: Alamofire - Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。Alamofire 最佳实践 AlamofireObjectMapper.swift - 将Alamofire JSON响应数据 转为swift对象。 RxAlamofire.swift - 为Alamofire提供函数响应式（FRP）调用接口,以优雅的方式使用Alamofire进行网络请求。 socket.io-client-swift - WebSockect 客户端类库。开放的通讯协议，有利于构建强大地跨平台应用。 Transporter - swift， 短小、精悍、易用的多文件（并发或顺序）上传和下载传输库。还支持后台运行、传输进程跟踪、暂停/续传/取消/重试控制等功能。 Just - 小而美的 HTTP 类。功能简单、直接、完整且健壮性高– swift。 Future - 基于微框架设计思想的异步执行及结果响应类，代码即简单又干净– swift。 HFDownLoad - iOS开发网络篇之文件下载、大文件下载、断点下载:NSData方式、NSURLConnection方式、NSURLSession下载方式 下载方式具体的思路、区别见Blog 。 Pitaya.swift - Pitaya 是纯 Swift 写的 iOS 网络库，支持 Basic Authorization、SSL 钢钉、HTTP raw body / JSON body、快速文件上传等特性，并通过内置 JSONNeverDie 实现了对 JSON 的完全支持，开箱即用。 中文文档 starscream.swift - starscream.swift:WebSocket客户端类库。 SwiftNet.swift - 基于 RxSwift 和 Alamofire 的网络请求简易封装库。 Networking.Swift - 使用简单、功能惊喜，基于 NSURLSession 的网络封装。 图像获取@ Kingfisher - 纯 Swift 实现的类 SDWebImage 库，实现了异步下载和缓存图片。 KFSwiftImageLoader - Swift，一个图像缓存加载库。 图像获取@ Kingfisher 一个用于图片缓存的开源库，类似 SDWebImage，但是完全基于 Swift 语言开发。 网络聊天@ MessageKit.swift - 消息 UI 库 JSQMessagesViewController 的 Swift 版。 jchat-swift - 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。 网络测试@ Reachability.swift - 用于替换苹果的 Reachability 类，可以方便地检测当前是否联网以及具体的联网状态。 NetReachability - swift2.0 简单的方法检查网络连接的连通性，提供通知中心集成接口。 SimpleBS.swift - 网络测试小工具。 网页框架@ Perfect.swift - Perfect 致力于 Swift 服务端应用，从打造专业应用服务器开始。Swift服务端编程：Perfect项目上手指南 swift-http - Swift HTTP Server，又一个 Swift 服务器，最大的亮点是支持 Docker 部署。 Swifton - Swifton是一个优秀的Swift on Rails 的Web Framework。 Taylor.swift - Taylor一个swift的轻量级的http服务器的库。 NetworkObjects.swift - NetworkObjects.swift轻量版HttpServer框架，跨平台解决方案。 vapor.swift - vapor.swift：swift的服务器库 vapor。 Kitura.swift - Kitura.swift：安装、使用步骤及文档最为清晰地来自 IBM Swift 开发组的开源 Web 服务器。此外，IBM 云服务 Bluemix 也为 Swift 打开通路。 CSV@ CSwiftV - A csv parser written in swift conforming to rfc4180 :large_orange_diamond: SwiftCSV - CSV parser for Swift :large_orange_diamond: WebView与WKWebView@ IOSCallJsOrJsCallIOS - IOSCallJsOrJsCallIOS：利用iOS7.0后出来的JavaScriptCore framework，webview与Js交互是常见的需求。OC版本与swift版本。《OC JavaScriptCore与js交互》,《Swift JavaScriptCore与js交互》。 WKWebViewTestDemo.swift - WKWebViewTestDemo：WKWebView新特性及JS交互,文章讲解。 React.swift - 启发自 React 的纯 Swift 函数版基于 UIKit 封装类库。这种结构是否似曾相识。 [GRMustache] (https://github.com/groue/GRMustache) 一个类似templateEngine的html渲染工具，可以更加有效的帮助大家完成数据生成HTML的过程。 Model@ Decodable - Swift 2 JSON parsing done (more) right :large_orange_diamond: Jay - Pure-Swift JSON parser &amp; formatter. Linux &amp; OS X ready. :large_orange_diamond: SwiftyJSON - The better way to deal with JSON data in Swift. :large_orange_diamond: XMLDictionary - ios与mac os平台下xml与NSDictionary相互转化开源类库。 AEXML.swift - AEXML.swift简单又易于的XML解析类及示例。 CFRuntime - “Swift 版的 MJExtension，运行时、反射与一键字典模型互转”。 protobuf-swift - Protocol Buffers 的 Swift 语言实现库。P.S. Protocol Buffers 是 Google 开源项目，主要功能是实现直接序列化结构化的对象数据，方便跨平台快速传递，开发者也可以直接修改 protobuf 中的数据。相比 XML 和 JSON，protobuf 解析更快，存储更小。 JSONCodable - 基于 Swift 2.0 新特性（Protocol Extensions and Error Handling）的JSON 解析类。 SwiftyJSON - 使Swift的JSON解析变得简单。 JSONNeverDie.swift - JSON 到 Model 类的自动映射工具。 Fuzi.swift - Swift实现的轻量快速的 XML/HTML 解析器。 SWXMLHash.swift - 易用的 XML 解析类库。非常实用的“轮子”。 YYModel - 高性能的 iOS JSON 模型框架。 TidyJSON.swift - TidyJSON.swift一款简单、易用、明了的 JSON 解析小类库。 PMJSON.swift - PMJSON.swift简单、实用、高效的 JSON 解析类库。 Unbox.swift - 极为易用、轻量，更少辅助代码的 JSON 解析类。 Wrap.swift - 方便、易用的对象转 JSON 类库。 通讯录@Email@ Postal A swift framework for working with emails,Postal is a swift framework providing simple access to common email providers. 三方分享、支付、登录等等@其他库@ SwiftDate - 特别完整、强大的日期时间操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性。 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。 SYKeyboardTextField - SYKeyboardTextField 是一个轻巧,简单,非侵入式的键盘附随输入框! 采用Swift编写。 IQKeyboardManager - 处理键盘事件强大的库，有OC和Swift版本，纯代码、Storyboard和Xib都适用。 ZFScan - 仿微信 二维码/条形码 扫描。 QRCodeReader.swift - QRCodeReader.swift一款简单的 QR 二维码阅读组件及示例，提供前后相机切换功能。 swiftScan - 具有丰富功能的二维码扫描组件及类库。对应OC版本LBXScan。 QR-Code-Generator.swift - 生成二维码。 Parsimmon - swift，小而美的语言学类库封装工具包。提供分词、标记词性、词形归并、朴素贝页斯分类、决策树等自然语言分析小工具。P.S. 英语分词效果好于中文，感兴趣的同学可以针对中文做一些优化开发。参考译文 NSHipster - NSLinguistic​Tagger。 MKMapView-Extension - 这是关于 MKMapView 写的一个基于swift的扩展，可以扩展 MKMapView 的相关功能，减少复用代码量。 SwiftValidator - 基于规则的输入验证类库。项目良好的面向对象设计思想，使规则的扩展及自定义非常方便。更专业的规则引擎（甚至是基于自然语言的规则配置）解决方案，比如：开源的 Drools，商用的 ILOG 等。 Validated.swift - Validated.swift通过值验证或限定，快速定义新类型的微类库（约50行代码）。 SwiftOCR - 识别字母和数字相较于 Tesseract 有压倒性优势（附图）的 OCR 类库。 Regex.swift - 实用的正则表达式微框架类库。 PySwiftyRegex.swift - 像Python一样简洁高效地作正则处理。 PhoneNumberKit.swift - 解析、格式化及验证国际电话号码工具库（相当于 Google 的 libphonenumber 库的 Swift 版本）。 BFKit-Swift - BFKit-Swift 这套工具库可以提高应用开发效率。 SwiftSequence - 简洁、灵活、多变的操作 SequenceType 的类库（基于微框架（μframework）设计思想）。 IDNFeedParser - 一个简单易用的Rss解析库。 Swifternalization - 一套实用的本地化工具库。使用教程及 API 文档完整。值得收入项目的“轮子”。 Localize-Swift - Localize-Swift一款开发者不可或缺的国际化及本地化字符串框架支持类库。同样地，使用简单、直观又方便。 apous - 一款有趣的 Swift 应用 － 让 Swift 成为脚本语言。 ControlOrientation - 如何用代码控制以不同屏幕方向打开新页面【iOS】， 使用说明。 SwiftyStoreKit - 一款轻量级的 iOS 应用内购买框架。 Device-swift - 可以非常方便的获取设备型号和屏幕尺寸，实现起来难度不大，大家可以学习一下源码。 RunKit.swift - 针对 GCD 框架的一个友好访问封装库（支持方法链式调用）。 Plum-O-Meter - swift 称重应用， (3D Touch之我见)[http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/]。 打开自带地图、百度地图、腾讯地图 - 打开自带地图、百度地图、腾讯地图。 MapManager.swift - MapManager.swift地图及路径管理封装库。 eviltransform.swift - eviltransform.swift解决国内GPS地图坐标偏移问题,它将政府加密过的GCJ-02坐标，转成世界通用的WGS-84坐标。 BabyBluetooth - 是一个非常容易使用的蓝牙库, 适用于 iOS 和 Mac OS, 基于原生 CoreBluetooth 框架封装, 可以帮开发者们更简单地使用 CoreBluetooth API, 使用链式方法体, 使得代码更简洁、优雅。iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍 RxBluetoothKit.swift - 基于 RxSwift 的蓝牙通讯库。 BluetoothKit.swift - 基于 CoreBluetooth API 实现iOS/OS X 设备间蓝牙通讯封装类库。功能强大、传输稳定，示例完整，很酷。 CoreDataStack.swift - 存储栈。 SYNQueue.swift - 执行队列类库。 DDMathParser.swift - 相比 NSExpression 和 GCMathPaser，功能更强大的数学表达式解析器。 RateLimit.swift - 简单、实用定时执行任务工具类库。 shoppingCart.swift - swift的购物车demo，采用纯代码UI，autolayout自动布局，core animation动画效果。 SwiftyGPIO - 通过 Swift 语言去控制基于 Linux 主板（比如：C.H.I.P. 和 树莓派） 的 GPIO（General Purpose Input Output ），去完成简单的工控功能（比如 LED 灯的显示）。 Scale.swifty - 简单直观的单位计算及换算类库（支持常用计量类型）。代码简洁性、直观性杠杠的。 swift-pons - 面向协议的不受长度限制数字类型及数学计算扩充类库。用它做一款最牛科学计算器妥妥地。 SwiftString - SwiftString:String 扩展功能很丰富（无论格式化杂乱字符串，还是子串查找，亦或是格式转换都很强大）。 FileBrowser.swift - FileBrowser.swift 一款开源的 iOS 文件浏览器, 支持文件搜索, 文件预览和 3D touch 功能。 AFBrushBoard.swift - AFBrushBoard.swift基于swift的毛笔画板Demo。包含多阶贝塞尔曲线的抽取、模拟画笔速度等算法。 SwiftForms - SwiftForms表单递交库，快速开发利器。 Design-Patterns-In-Swift - Design-Patterns-In-Swift如何使用常用设计模式及示例。 Dollar.swift - Dollar.swift是一个Swift库，无需扩展任何内置对象就为Swift语言提供有效的函数式编程辅助方法，类似于Lo-Dash或JavaScript中的Underscore。而Cent则是通过扩展功能来扩展Swift中的特定对象类型。 Underscore.swift - 函数式编程辅助方法，可靠性上压倒目标对手是 Dollar。 PathKit.swift - PathKit.swift小而美的路径管理类。 Surge.swift - Surge.swift基于苹果Accelerate高性能计算数学框架封装库。 Async.swift - Async.swift简洁的后台执行代码的异步封装库。 AlecrimAsyncKit.swift - 一款很优雅的异步执行框架库。 BrightFutures.swift - BrightFutures.swift漫长或复杂计算由独立线程异步来完成。 Euler.swift - Euler.swift直观、简洁的数学表达式∛27÷3+∑[3,1,2]。 Siren.swift - Siren.swift当应用更新时，通知用户并提供App Store链接。 BTree.swift - BTree.swift:相对于标准集合类型具有更优执行性能的基于B-Tree的优化集合类型实现类库。 PromiseKit - 同时支持 Swift 及 Objective-C 的 Promise 类库，异步编程类库 提供了很多实用的异步函数 让异步编程更简单。 Duration.swift - 测量代码片段执行时间工具类库（Swift）。 Bolts-Swift - 全平台（所有支持 Swift 的设备）任务管理 futures/promises 异步实现类库。 BCColor.swift - 轻量而强大的颜色处理库，纯 Swift 版。 支持从图片拾取一套主题色，类似AppleMusic；支持图片黑白化、对颜色的加深和变浅、生成渐变颜色等。 AIToolbox.swift - AI 主流模块集工具箱库。其中涉及 AI 知识实在广阔又高端。 EZSwiftExtensions - 对Swift标准库， Foundation， UIKit 提供了很多高级扩展函数。 TempiBeatDetection.swift - Swift 语言写的音乐节奏节拍检测库。 Venice.swift - 让 Swift 3 提前支持协程（Coroutine）。P.S. Chris 曾答疑过，Coroutine 不在 Swift 3 支持范围中，将在更晚时候讨论语言级支持。 FlatBuffersSwift - Swift 版 FlatBuffers 实现类库。P.S. FlatBuffers 是跨平台、高效，提供了 C++/Java 接口的序列化开源工具库。 Lyft.swift - 一套面向 Lyft 开发者的 Swift API 类库。 Up-Down.swift - Up-Down.swift:在 OS X 菜单栏上实时显示网络上传和下载速度小工具。 Algorithm.swift - 算法和概率模型工具集。（作者 Daniel Dahan） Spots.swift - 一套为了加速开发效率、将 view models 采用 JSON 格式存储于云端 view controller 框架库。 PinpointKit.swift - 简单的手势动作快速触发反馈组件。主要功能包含自动截屏、附加说明和日志。支持添加可定制箭头、着重框、文本、模糊打码等常用快照编辑功能。它非常适合开发过程中测试人员反馈缺陷。 Switcher.swift - 一个 OS X 小 App，可以很轻松地切换 App Store 和 iTunes 的账号，对于同时使用多个 Apple ID 的人来说非常地方便。 数据存储@缓存处理@ Cache.swift - 一款简单、易用的缓存库。支持 MemoryCache, DiskCache 以及前两项组合的 MultiCache。 Cache.swift - Nothing but Cache。 AwesomeCache.swift - Delightful on-disk cache (written in Swift)。 Track.swift - 基于文件系统和链表的 Cache。分为 Disk 和 Memory，线程安全，支持 LRU 淘汰，性能尚可。 CoreData@ JSQCoreDataKit - A swifter Core Data stack :large_orange_diamond: 数据库@ RealmIncrementalStore.swift - RealmIncrementalStore.swift:集 Realm 数据库和 CoreData 对象模型两者优势的 Realm 数据库访问类库。 Breeze - 用Swift写的一个轻量级的CoreData管理工具，并且还支持iCloud 。 AlecrimCoreData - Swift，更容易地访问 CoreData 对象封装类库。除了 CRUD，还提供指针定位，强大的排序、筛选，异步数据获取，以及独立线程后台存取数据。 SQLite.swift - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。 fluent.swift - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。 swiftydb - 是一个第三方 SQLite 工具，能够大大简化数据库操作。如果你不放心 Realm，那就用 SwiftyDB 吧。使用教程、demo Graph.swift - 设计新颖、使用简单基于 Core Data 的数据驱动框架库 （作者Daniel Dahan）。 SwiftStore - Key-Value store for Swift backed by LevelDB :large_orange_diamond: PDF@图像浏览及处理@ ShinpuruImage - Syntactic Sugar for Accelerate/vImage and Core Image Filters :large_orange_diamond: core-image-explorer - Core Image 滤镜处理图片– swift ，Core Image 介绍。 GPUImage2.swift - Swift 版基于 GPU 图像和视频处理框架库。 TimingFunctionEditor - TimingFunctionEditor用swift编写， 贝塞尔曲线编辑器，编辑后可以预览或拷贝代码片段直接使用。P.S. 该项目采用更简单的依赖管理器。 Carthage ，而非常用的 CocoaPods。Carthage介绍中文。 AAFaceDetection - AAFaceDetection–swift，简单、实用的面部识别封装库。虽然该技术从 iOS 5 发展，不过真正有趣的应用还不多。 Concorde - swift, Concorde, 一个可用于下载和解码渐进式 JPEG 的库, 可用来改善应用的用户体验。 ZoomTransition - swift, 通过手势操控图片的放大、缩小、旋转等自由变化效果的组件及示例。 AFImageHelper - swift,一套针对 UIImage 和 UIImageView 的实用扩展库，功能包含填色和渐变、裁剪、缩放以及具有缓存机制的在线图片获取。 PinterestSwift - swift,Pinterest 风格图片缩放、切换示例。 PhotoStackView-Swift - PhotoStackView——照片叠放视图，使用说明。 MPParallaxView - 是用 Swift 写的类似 Apple TV Parallax 效果的视图。 SDECollectionViewAlbumTransition - 用自定义的 push 和 pop 实现了有趣的 iOS 相册翻开动画效果。 SKPhotoBrowser.swift - swift中规中矩、实用的图片浏览类库。示例也很完整。 Nuke.swift - 完整、强大、实用的图片管理类库。主要功能包括可定制装载，缓存，滤镜及尺寸变换。 PagingView.swift - 注重细节的自动布局分页视图组件。 DouBanMeinv.swift - 抓取豆瓣美女图片，瀑布流显示。 SwViewCapture.swift - SwViewCapture.swift一个用起来还不错的iOS截图库.(支持截取所有内容, 适用于所有ScrollView组成的视图, 包括WebView)。 Filterpedia.swift - 强大的图片滤镜库演示。 preview-transition.swift - 通过向导式代码实现步骤，实现完整、自然流畅的图片预览及转场功能。 CartoonEyes.swift - 前置摄像头捕获图像后，采用 Core Image 脸部识别 CIDetector 和漫画效果滤镜复合出卡通效果眼睛。 图表摄像照相视频音频处理 CameraManager - 相机管理封装类库。看着极好用的样子—-swift。 recordDemo.swift - 一个Swift语言实现直接可以用的录音Demo，实现说明。 Swift-Radio-Pro - 集成 LastFM 的专业电台应用（基于 Swift 2.0）。 mobileplayer-ios.swift - 很不错的高度可定制播放器项目。 Periscope-VideoViewController.swift - 简洁实用的视频快进、倒带控制视图类库。 AudioKit.swift - 音频合成、加工及分析平台（支持 iOS、OS X、tvOS）框架库。无论其易用性，还是功能性及专业性。 SkfSwiftCammer - 一个相机demo，在oc里面调用了swift。 BMPlayer.swift - 基于 AVPlayer 使用 Swift 封装的视频播放器，方便快速集成,支持横屏、竖屏，上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。 响应式框架 RxSwift - RxSwift:函数响应式编程框架。 RxPermission.swift - 通过绑定 RxSwift 实现的 RxPermission。 Permission.swift - 统一的 API 请求 iOS 本地设备及资源权限类库。 ReactiveAnimation - ReactiveCocoa 推出了一个叫 ReactiveAnimation 的子项目，直接用完全用 Swift 来实现了。 Swiftest - BDD 全称 Behavior Driven Development，行为驱动开发。各种 DD 数不胜数，孰优孰劣争论不休，其实归根结底还是要根据使用场景进行选择。 消息相关@消息推送客户端@消息推送服务端@通知相关@ Homeoff - 用swift写了一个模仿Launcher通知中心快捷方式的应用。支持20个应用，并增加了一个返回到桌面来解放Home键的功能。 SwiftNotificationCenter - 一个面向协议的类型安全、线程安全、内存安全的通知中心。 时间日期@版本新API的Demo@ MTSwift-Learning - 通过一些简单项目实战演练开始学习 Swift 。 iOS8-day-by-day - swift。 iOS9-day-by-day - swfit iOS9 Day-by-Day :: Day 2 :: UI Testing。 iOS 9 分屏多任务 - iOS 9 分屏多任务：Slide Over &amp; Split View快速入门（中文版）。 uistackview-sample.swift - iOS 9 引进了 UIStackViews，提供 auto-layout 特性。如果你开发过 Android 应用，会发现它和 LinearLayouts 概念上很类似，它是增强版。你可以手动创建，也可以使用 IB 自动创建，本文用的是代码实现。 代码安全与密码@ OAuthSwift - OAuthSwift国外主流网站OAuth授权类库。 CryptoSwift - swift加密库, 支持md5,sha1,sha224,sha256…。 测试及调试@ CleanroomLogger - 相当于 CocoaLumberjack 或 Log4j 的 Swift 版本，功能上甚至更强大。另外，源代码中已经内含了完整的 API 文档，使用非常方便。 Quick - 用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。 Sleipnir - Swift的测试框架。 XXPlaceHolder.swift - MMPlaceHolder的swift版本。 SwiftyBeaver - 一个完善的日志工具，支持彩色输出、输出内容到文件、重要性分级、多输出目标。工具执行在后台，不影响性能，可以极大提高开发效率。 swiftlog - 为Swift 应用提供快捷添加日志信息的方法，Swift 包管理支持（SPM）、 使用惊艳的 Rainbow 包输出彩色日志、支持写入文件。使用 swiftlog Log.swift - 灵活、易用、可定制输出格式和主题风格的日志类（Swift）,支持控制台彩色输出。 Cuckoo.swift - Cuckoo.swift一款用法更接近于传统单元测试 Mock 框架库（区别之处在于需要用脚本预先生成 Mock 类）。 XCGLogger.swift - XCGLogger.swift功能完整的日志管理类库。 Peek.swift - 更友好、手势方式检查界面内组件布局信息（相当于浏览器元素检查功能），界面调试利器。 动态更新@AppleWatch@ Apple Watch开发教程资料汇总 - Apple Watch开发教程资料汇总。 Stargate - 通过 iPhone 桥接实现 Mac 与 Watch 的即时通讯。Stargate 通过封装两个优秀的基础类库 MMWormhole 和 PeerKit 实现高效的通讯应用。–swift soon - 一款倒计时 WatchKit 示例应用。作者从架构的角度，思考如何设计一款完整、通讯高效且性能又好的 WatchKit 扩展应用。该示例学习性非常强。–swift MMWormhole.swift - MMWormhole.swift:iOS或OS X扩展与宿主应用的通讯框架。 VPN@ vpnon - swift的VPN On 的源码和本地化内容都是开放的: 官方网站。 完整项目@ V2ex-Swift - 用 Swift 写的 V2EX 客户端。 iBBS-Swift - “新手开源一个用Swift（2.0）写的论坛客户端”。BBS 服务端。 DesignerNewsApp - Swift 开发的 DesignerNews 客户端，看着美美的！ Eidolon - 艺术品拍卖的投标亭平台，用swift与反应式编程框架 ReactiveCocoa。 BaiduFM-Swift - 百度FM, swift语言实现，基于最新xcode6.3+swift1.2,初步只是为了实现功能，代码比较粗燥，后面有时间会整理，支持Apple Watch。 Tuan - 模仿MJ老师iPad版美团（swift版），偶有bug 见谅。 CocoaChinaPlus - CocoaChina+是一款开源的第三方CocoaChina移动端。整个App都用Swift2.0编写(除部分第三方OC代码外，比如JPush和友盟)。 SimpleMemo - 易便签已经转到Swift2.0，全面适配iOS9和Watch OS2，并支持iPhone6s和iPhone6sPlus的3D Touch功能，包括图标快捷键和内容预览。 XXYAudioEngine.swift - 基于NSURLSession 和 AVAudoPlayer的在线音乐的工具，可以把音乐保存在本地，也可以支持后台播放，后台下载，最低支持iOS7，swift版本1.2。 furni-ios.swift - furni-ios.swift是由 Twitter 开发团队出品的一款用 Swift 写的 iOS 家居商城应用, 其主要目的在于让开发者从这款 Demo 应用中看出 Fabric 的强大。 SelectionOfZhihu.swift - 『看知乎』iOS 客户端, 项目说明。 WFZhiHu - WFZhiHu仿知乎日报客户端app。 NirZhihuDaily2.0_swift - 精仿了知乎日报iOS端练手，Swift2.0，注释相当详细。 Yep.swift - Yep 一个由天才开发给天才们使用的社交软件。 LoveFreshBeen.swift - 高仿爱鲜蜂 - Swift2.0 trySwiftApp.swift - trySwiftApp一款较为完整的会议原型应用。有需求的同学可以做为开发参考。 PinGo.swift - PinGo.swift：纯Swift编写的仿“随遇”App。 UmbrellaWeather.swift - UmbrellaWeather.swift使用 Swift 编写的一款天气应用,现已上架 AppStore。 SwiftWeather - SwiftWeather清新淡雅持续改进天气预报项目。 Phonetic.swift - Phonetic一个 iOS 版的 Phonetic Contacts，功能很多，其中昵称功能非常实用，已在 GitHub 开源并上架 App Store。 edhita.swift - edhita.swift支持Markdown, HTML预览的文本编辑器。 PilesSugar.swift - PilesSugar.swift:Swift高仿项目,堆糖。 react-native-gitfeed - 目前最实用简洁的github客户端了。 SoundCloudSwift - SoundCloud的Swift版本，采用Swift2.0，Reactive API with ReactiveCocoa 4.0。 LeagueofLegends - 一个关于英雄联盟的完整iOS开源项目，接口均来自多玩，腾讯各大游戏平台。 Coderpursue.swift - 一款 Github 第三方客户端，使用最新 Swift 语言编写。 BTApp - BTApp 仿半糖 iOS App 的 Demo 应用。 好的文章@ RxSwift入坑手册 - RxSwift入坑手册。 Xcode使用技巧 - SwiftGG 交流分享：Xcode使用技巧。 Swift编程的15个技巧 - Swift编程的15个技巧。 Xcode插件@ Swimat - Swimat，是一款Xcode 插件，帮你一键格式化 swift 代码。 XcodeSwiftSnippets - XcodeSwiftSnippets, 提供了很多可在 Xcode 上使用的 Swift 代码片段, 通过自动补全的方式极大的提高了开发效率。 美工资源@其他资源@开发资源@二维码@ LBXScan 赞 A barcode and qr code scanner (二维码、扫码、扫一扫、ZXing和ios系统自带扫码封装，扫码界面效果封装)(Objective-C和Swift均支持). 开发资料@ Swift 开源项目精选－v1.0 - Swift 开源项目精选－v1.0。 Swift开源项目精选 - Swift开源项目精选–推荐，每周都有更新。 Swift中文指南 - 中文版Apple官方Swift教程《The Swift Programming Language》，老码版本 历史版本更新说明。 The Swift Programming Language 中文版 - The Swift Programming Language 中文版。 swifttoolbox - swifttoolbox swift开发的开源库汇总。 SwiftGuide - 这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排– 非常不错，值得推荐。 Awesome Swift - 一个收集了很多 Swift 开发资源的网站。 Developing_iOS_8_Apps_With_Swift - Developing iOS 8 Apps with Swift 字幕简体中文翻译项目（斯坦福白胡子老头swift教学视频）。 Swift-On-iOS - JohnLui 的 Swift On iOS 代码仓库。 30DaysofSwift - 30DaysofSwift 自学 iOS - 三十天三十个 Swift 项目。 他人开源总结@学习笔记@好用的软件@设计@物联网@视频播放器@","categories":[],"tags":[]},{"title":"版本：Objective-C","slug":"版本：Objective-C","date":"2016-08-27T15:52:55.000Z","updated":"2016-08-27T16:02:53.000Z","comments":true,"path":"2016/08/27/版本：Objective-C/","link":"","permalink":"http://pro.stonepark.fun/2016/08/27/版本：Objective-C/","excerpt":"版本：Objective-Cgithub排名 https://github.com/trending,github搜索：https://github.com/search 主要工作说明： 重新整理了Xcode好用的插件，信息更详细和完整，直接搜索@“Xcode插件@”。（已经完成） 使用方法：根据目录关键字搜索，记得包含@，以保证搜索目录关键字的唯一性。 引入评价机制：根据作者们的主管评价，对库是用”赞”、“很赞”、“非常赞”这3个评价伺候，便于大家在初次选择库时有一个选择依据。 问题反馈：请广大网友只按照目录结构（即使目录结构有问题）添加三方库，并pull request。目录问题大家提出issues后楼主会及时更改的。 目录 Github用法@ 完整App@ App框架@ 响应式框架@ UI@ 日历三方库@ 下拉刷新@ 模糊效果@ 富文本@ 图表@ 颜色@ 表相关@(TabbleView、Tabbar、即时聊天界面)) TableView@ CollectionView@ 隐藏与显示@ HUD与Toast@ 对话框@ 状态栏@ 导航栏@ 设置@ Switch@ 主题@ 电影选座@ 瀑布流@ 菜单@ 其他UI@ 动画@ 侧滑与右滑返回手势@ gif动画@ 其他动画@ AutoLayout@ 网络相关@ 网络连接@ 图像获取@ 网络聊天@ 网络测试@ 网页框架@ 网络解析 CSV JSON@ XML&amp;HTML@ Other Parsing@ 二维码@ 开发资料@ 播客@ 学习资料@ 他人开源总结@ 开发博客列表@ 学习笔记、书籍@ 设计@ 好的文章@ 美工资源@ 开发工具@ Xcode插件@ 好用的软件@ Cagegory@ 测试及调试@ 数据存储@ 缓存处理@ 数据库@ 序列化@ WebView与WKWebView@ 游戏@ FaceBook@ 通讯录@ 其他库@ 三方分享、支付、登录等等@ PDF@ 图像浏览及处理@ 图像圆角@ 摄像照相视频音频处理@ 视频@ 消息相关@ 消息推送客户端@ 消息推送服务器端@ 通知相关@ 时间日期@ 设计模式@ 版本新API的Demo@ 代码安全与密码@ 动态更新@ AppleWatch@ VPN@ 未分类@","text":"版本：Objective-Cgithub排名 https://github.com/trending,github搜索：https://github.com/search 主要工作说明： 重新整理了Xcode好用的插件，信息更详细和完整，直接搜索@“Xcode插件@”。（已经完成） 使用方法：根据目录关键字搜索，记得包含@，以保证搜索目录关键字的唯一性。 引入评价机制：根据作者们的主管评价，对库是用”赞”、“很赞”、“非常赞”这3个评价伺候，便于大家在初次选择库时有一个选择依据。 问题反馈：请广大网友只按照目录结构（即使目录结构有问题）添加三方库，并pull request。目录问题大家提出issues后楼主会及时更改的。 目录 Github用法@ 完整App@ App框架@ 响应式框架@ UI@ 日历三方库@ 下拉刷新@ 模糊效果@ 富文本@ 图表@ 颜色@ 表相关@(TabbleView、Tabbar、即时聊天界面)) TableView@ CollectionView@ 隐藏与显示@ HUD与Toast@ 对话框@ 状态栏@ 导航栏@ 设置@ Switch@ 主题@ 电影选座@ 瀑布流@ 菜单@ 其他UI@ 动画@ 侧滑与右滑返回手势@ gif动画@ 其他动画@ AutoLayout@ 网络相关@ 网络连接@ 图像获取@ 网络聊天@ 网络测试@ 网页框架@ 网络解析 CSV JSON@ XML&amp;HTML@ Other Parsing@ 二维码@ 开发资料@ 播客@ 学习资料@ 他人开源总结@ 开发博客列表@ 学习笔记、书籍@ 设计@ 好的文章@ 美工资源@ 开发工具@ Xcode插件@ 好用的软件@ Cagegory@ 测试及调试@ 数据存储@ 缓存处理@ 数据库@ 序列化@ WebView与WKWebView@ 游戏@ FaceBook@ 通讯录@ 其他库@ 三方分享、支付、登录等等@ PDF@ 图像浏览及处理@ 图像圆角@ 摄像照相视频音频处理@ 视频@ 消息相关@ 消息推送客户端@ 消息推送服务器端@ 通知相关@ 时间日期@ 设计模式@ 版本新API的Demo@ 代码安全与密码@ 动态更新@ AppleWatch@ VPN@ 未分类@ ======== 具体内容 ===================================== Github用法@ git-recipes Git recipes in Chinese. 高质量的Git中文教程. lark 怎样在Github上面贡献代码 my-git有关 git 的学习资料 gitignore 非常赞 有用的.gitignore模板集合，包含了各种语言. 完整App@ HackerNews-React-Native用 React Native 完成的 HackerNews 客户端。 WeChat 实现类似微信朋友圈或者QQ空间，评论回复，九宫格布局。处理键盘弹出后定位到当前点击的被评论人处。另：滑动时候FPS在57-60之间，纵享丝滑！ iOSAppTemplate高仿微信，iOS应用开发模板，个人总结。 Bilibili_Wuxianda赞 高仿Bilibili客户端 Coding-iOS - Coding iOS 客户端源代码 Voice2Note - 懒人笔记iOS客户端 Coding-iOS - Coding iOS 客户端源代码 Coding-iPad - Coding iPad 客户端源代码 Monkey - GitHub第三方iOS客户端 firefox-ios Firefox for iOS RSSRead “已阅”（iOS上开源RSS新闻阅读器） zulip-ios Dropbox收购公司内部社交服务商Zulip,然后全部开源，这是iOS App ChatSecure-iOS - Objective-C写的XMPP聊天应用 FirebaseChat - Objective-C写的完整的聊天应用 Meizi - 豆瓣妹子图iOS客户端 PlainReader 简阅是一款 iOS(iPhone + iPad) 新闻类客户端，内容抓取自 cnBeta.COM。在售期间倍受好评，但由于版权问题已于今年一月从 AppStore 下架，下架至今，每天仍有几千人在使用这款 App。 ECMobile_iOS 基于ECShop的手机商城客户端 ECMobile_Universal基于ECShop的手机商城客户端 wikipedia-ios 维基百科官方App, 已上架 Sol 漂亮的扁平风格的天气App v2exv2ex第三方iOS客户端。V2EX是一个知名技术创意网站，由设计师、程序员及有创意的人参与的社区。 它基于兴趣将用户创建的内容组织分类成不同“节点”，网站以内容的活跃程度决定在首页排序的位置。 MyOne-iOS我的《一个》 iOS 客户端（OC） WNXHuntForCity城觅By-Objective-C viewfinder 移动支付公司 Square 将去年收购的照片应用 Viewfinder 开源了，包含服务端、iOS 和 Android 应用代码 novel-design 品趣iOS客户端 breadwallet breadwallet - bitcoin wallet GreatReader GreatReader PDF阅读客户端 Tropos天气客户端 Brushes绘图应用. Painting app for the iPhone and iPad.客户端 WordPress-iOSWordPress iOS官方客户端. 笔者强烈推荐的开源项目. TeamTalk 蘑菇街TeamTalk. 开源IM. 笔者强烈推荐. MessageDisplayKit一个类似微信App的IM应用，拥有发送文字、图片、语音、视频、地理位置消息，管理本地通信录、分享朋友 圈、漂流交友、摇一摇和更多有趣的功能。笔者推荐的学习IM的好东西. shadowsocks-iOS/tree/2.6.3翻墙工具Shadowsocks. Github目前代码已经被移除, 不过2.6.3的还是保留着. 完整项目@ GSD_WeiXin 高仿微信 v2ex - v2ex 的客户端，新闻、论坛。 wikipedia-ios - wikipedia-ios 客户端。 jetstream-ios - 一款 Uber 的 MVC 框架。它同时提供了多用户实时通讯支持，一旦启动 JetStream 后端服务，通过 WebSocket 协议可以分分钟建立多用户实时通讯应用。 DeckRocket - 在相同 WiFi 网络环境内，通过iPhone 控制并播放 Mac 中的 PDF 文档。 ScanBook - 扫扫图书:可以扫描条形码查询图书，也可以关键字搜索，遇到合乎你口味的书，还可以看看别人的读书笔记，不同角度去体会。 KYWeibo - 调用新浪API自己写的第三方微博客户端。 DouQu_IOS - 逗趣IOS手机端（一款笑话软件）,拥有完整的功能的手机应用app 。 IT江湖iOS客户端 - IT江湖iOS客户端。 CrazyPuzzle - 模仿“看图猜成语”App，功能齐全，配有音效，效果很不错。游戏使用cocoa框架完成，没有使用cocos2d的框架。 WhoCall - 谁CALL我，iOS来电信息语音提醒，无需越狱。（需要iOS 7.0及以上版本。)骚扰电话预警、来电归属地提醒、联系人姓名播报，这些有中国特色人性化的电话功能，iOS上也应该有。电话提醒、私有API。 仿iOS猎豹垃圾清理(实现原理+源码) - 仿iOS猎豹垃圾清理(实现原理+源码),用到私有API。1 DSLolita - 模仿新浪微博做的一款app，有发送博文，评论，点赞，私聊功能。 STPhotoBrowser - 高仿新浪微博的图片浏览器，极佳的编写方式，易扩展，低耦合。 GSD_ZHIFUBAO - 支付宝高仿版。 Tropos - Tropos, 由 thoughtbot 推出的一款用 Objective-C 写的开源天气类应用, 截至今天, thoughtbot 已在 GitHub 上贡献了 174 个开源项目, 实在令人敬佩。 SmileWeather -开源天气类应用,天气图标很完整。 MVVMReactiveCocoa - GitBucket 2.0 通过审核啦，她是我在公司实践了一年多 MVVM 和 RAC 的基础上，利用业余时间开发的第三方 GitHub 客户端，旨在能够对想实践 MVVM 和 RAC 的 iOS 开发者有所帮助。AppStore地址，欢迎下载使用GitBucket和收藏MVVMReactiveCocoa。 Tomate - 这个圆盘式计时器让你更专注于工作或学习。P.S. App Store 上架收费应用（0.99 欧）。 StoveFireiOSMenu - 炉火餐饮系统iPad点餐端。 WNXHuntForCity - iOS高仿城觅项目（开发思路和代码）。 ZYChat - 关于聊天界面的可消息类型扩展，响应绑定设计。 NiceAppDemo - 仿最美应用-每日最美的钢琴律动效果。 meituan - 美团5.7iOS版（高仿），功能包括，团购首页，高德地图搜索附近美食并显示在地图上，上门服务，商家，友盟分享。 MeituanDemo - 造美团应用界面构建的 iOS 应用, 第一个是 @叶孤城___ 的 MeituanDemo。 JFMeiTuan - 造美团应用界面构建的 iOS 应用, 第二个是 @tubiebutu 的 JFMeiTuan。 chuanke - 高仿百度传课iOS版。 SXNews - 模仿网易新闻做的新闻软件，完成了主导航页，新闻详情页，图片浏览页，评论页。效果不错，比网上流传的各种和网易新闻UI架构有关的代码都要完整，都要好。 Monkey - Monkey for GitHub是一个GitHub开发者和仓库排名的开源App。这次主要增加了登录GitHub的功能，随手follow和star，并且增加发现模块，包括GitHub的trending，动态，showcases等。 Uther - 跟蠢萌的外星人聊天，还能帮你记事”。itunes下载 。 高仿斗鱼TV - 高仿斗鱼TV，点击头部滚动视图可以播放视频。 LXZEALER - 模仿着做了zealer客户端,App里几乎所有请求都是Post,所以内容都是固定的URL加载的,登录功能只做了微博的第三方登录。 ShiXiSeng_ios - 完整app的UI框架。 Coding-iPad - Coding-iPad 是@Coding的官方 iPad 客户端, 又是一个完整的开源应用。 WFZhiHu - WFZhiHu仿知乎日报客户端app。 react-native-gitfeed - 目前最实用简洁的github客户端了。 phphub-ios - PHPHub的iOS客户端，同时兼容iPhone和iPad。 LeagueofLegends - 一个关于英雄联盟的完整iOS开源项目，接口均来自多玩，腾讯各大游戏平台。 BTApp - BTApp 仿半糖 iOS App 的 Demo 应用。 iOS完整App资源收集 - iOS开发学习者都希望得到实战训练，但是很多资料都是只有一小部分代码，并不能形成完成的App，笔者在此处收集了很多开源的完整的App，都有源代码哦！–标哥的技术博客 XCFApp-1 - 高仿下厨房App，Objective-C，Xcode7.2，数据通过Charles抓的，有接口也有本地数据。说明：关于代码被清空，会用git的你肯定明白，教程 XCFApp-2 - 高仿下厨房APP。 YoCelsius - 已经上线的一款天气预报的应用,几乎所有的交互动画效果，想学习动画的开发人员可以作为参考。 XiMaLaYa-by-HansRove- - 仿喜马拉雅FM, 对AVFoundation框架的一次尝试，采用MVVM模式，教程。 DayDayNews 仿网易新闻客户端，实现新闻浏览，视频播放，仿搜狐视频、百思不得姐等当前主流视频播放器，实现流媒体播放，自动监听屏幕转动，实现横屏播放 , 抓取百度图片，瀑布流显示，夜间模式，环信即时通讯 App框架 nimbus Nimbus是一个开源的iOS框架，比起Three20，Nimbus的文档更为全面、丰富，能够实现很多非常炫的界面特效。因此，开发者可以借助Nimbus来降低项目设计的复杂度。 samurai-native 是一个基于浏览器内核通过HTML+CSS 开发原生移动应用的iOS框架。 HHRouter 一言以蔽之，URL Router 即将 UIViewController 映射成 URL，从而支持通过 URL 进行界面跳转。是的，就和 Web 一样。当然，这并不是 Web Developer 转职为 iOS Developer 后所做的无聊玩具。URL Router 有着许多切实的好处。 UI@日历三方库@ TEAChart - xhacker/TEAChart 一个简洁的 iOS 图表库，支持柱状图、饼图以及日历等。 CVCalendar - 是一个方便开发者集成自定义日历视图到自己 iOS 应用的项目, 支持 Storyboard 和手动配置, 使用 CocoaPods 进行安装, 提供了丰富的 API 供开发者使用。 下拉刷新@ EGOTableViewPullRefresh - (三年未更新了)最早的下拉刷新控件。 SVPullToRefresh - (三年未更新了) 下拉刷新控件。 MJRefresh - 仅需一行代码就可以为UITableView或者CollectionView加上下拉刷新或者上拉刷新功能。可以自定义上下拉刷新的文字说明。具体使用看“使用方法”。 （国人写） XHRefreshControl - XHRefreshControl 是一款高扩展性、低耦合度的下拉刷新、上提加载更多的组件。（国人写） CBStoreHouseRefreshControl - 一个效果很酷炫的下拉刷新控件。 KYJellyPullToRefresh - 实现弹性物理效果的下拉刷新，神奇的贝塞尔曲线，配合UIDynamic写的一个拟物的下拉刷新动画。 MHYahooParallaxView - 类似于Yahoo Weather和News Digest首屏的视差滚动。 SDRefreshView - 简单易用的上拉和下拉刷新（多版本细节适配）。 可展开/收缩的下拉菜单–SvpplyTable - 一个可展开可收缩的下拉菜单，类似Svpply app。 ODRefreshControl - 原iOS6上的橡皮糖刷新样式，很有意思。现在也很多大的 App 在用，比如虾米音乐和 QQ 客户端。 PullToMakeSoup - PullToMakeSoup, 自定义下拉刷新的动画效果：煮饭, Yalantis新作！ TwitterCover - Twitter iOS客户端的下拉封面模糊效果。 Replace-iOS - Replace-iOS 让人眼前一亮的下拉刷新（iOS）。 Animations - 封装了一下，使用的时候只要两行代码。一些动画的飞机稿，都是一些单独分离出来的用于测试的子动画，现在统一归类一下。 PullToBounce - 下拉刷新的动画 for UIScrollView。 WaterDropRefresh - 仿Path 水滴的下拉刷新效果 还有视差滚动。 ESRefreshControl - 仿新浪微博、百度外卖、网易新闻下拉刷新样式Demo（仅供参考）。 WaveRefresh - 下拉刷新水波纹动画。 DGElasticPullToRefresh - 是一款带有弹性效果的 iOS 下拉刷新组件。 CALayerAnimationDemoh - 双向注水动画下拉刷新组件,使用CALayer的mask实现。 BanTangAnimation - 半糖下拉刷新的原理。简单来说是利用CGGlyph，字符图形转换成cgpath，然后绘制strokeEnd动画。把timeoffset和scrolloffset结合就行了。 SURefresh - BOSS直聘APP下拉刷新动画实现，效果展示图－&gt; 实现思路再复杂的动画都可以拆分成许多简单的动画组合起来，这个动画大概可以分成两个主体，我把它分别录制出来给大家看看 模糊效果@ FXBlurView - 是一个UIView子类，支持iOS5.0以上版本，支持静态、动态模糊效果，继承与UIView的模糊特效。 VVBlurPresentation -很简单易用的在原来viewconntroller基础上做模糊，然后present新的viewcontroller的。 UICustomActionSheet - 通过模糊背景来着重强调与菜单相关的元素–对话框 里面已经收藏。 SABlurImageView - 支持渐变动画效果的图像模糊化类库。P.S. 与前几天推存类库 SAHistoryNavigationViewController 是同一位作者。 AutoLayout@ Masonry - Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了并具有高可读性（ 使用介绍1 使用介绍2），iOS自适应前段库-Masonry的使用），Masonry、Classy、ClassyLiveLayout介绍。使用DEMO 视图居中显示、子视图含边距、视图等距离摆放、计算ScrollView的contentsize。 Classy - Classy是一个能与UIKit无缝结合stylesheet(样式)系统。它借鉴CSS的思想，但引入新的语法和命名规则，Classy官网，Masonry、Classy、ClassyLiveLayout介绍。 ClassyLiveLayout - ClassyLiveLayout通过结合Classy stylesheets与Masonry一起使用，能够在运行的模拟器中微调Auto Layout约束实时显示效果的工具，Masonry、Classy、ClassyLiveLayout介绍。 PureLayout - PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的Auto Layout API 扩展了 UIView/NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架。 UIView-AutoLayout -Deprecated in favor of PureLayout, which includes OS X support:https://github.com/smileyborg/PureLayout。 UIView-FDCollapsibleConstraints - 一个AutoLayout辅助工具，最优雅的方式解决自动布局中子View的动态显示和隐藏的问题。第二个Demo模拟了一个经典的FlowLayout，任意一个元素隐藏时，底下的元素需要自动“顶”上来，配合这个扩展，你可以在IB里连一连，选一选，不用一行代码就能搞定。 Autolayout_Demo - 在项目中用自动布局实现的类似抽屉效果。 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute - 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute，从而不用大量的代码工作。 SDAutoLayout - AutoLayout 一行代码搞定自动布局！支持Cell、Label和Tableview高度自适应，致力于做最简单易用的AutoLayout库。 富文本@ Shimmer - BlingBling闪光效果，酷炫的Label的效果，可以用于加载等待提示。 TFHpple - TFHpple解析html的轻量级框架 RTLabel - RTLabel 基于UILabel类的拓展,能够支持Html标记的富文本显示，它是基于Core Text,因此也支持Core Text上的一些东西。32位，很久没有更新了。 RTLabel - 富文本，RTLabel支持64位。 TYAttributedLabel - TYAttributedLabel。 简单易用的属性文本控件(无需了解CoreText)，支持富文本，图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示。 TQRichTextView - 用于做富文本视图控件显示，用于即时通讯的表情显示，以及资源评论的富文本显示。 TTTAttributedLabel - 一个文字视图开源组件，是UILabel的替代元件，可以以简单的方式展现渲染的属性字符串。另外，还支持链接植入，不管是手动还是使用UIDataDetectorTypes自动把电话号码、事件、地址以及其他信息变成链接。用TTTAttributedLabel创建变化丰富的UILabel - 网易新闻iOS版使用。 MLEmojiLabel - 自动识别网址、号码、邮箱、@、#话题#和表情的label。可以自定义自己的表情识别正则，和对应的表情图像。(默认是识别微信的表情符号)，继承自TTTAttributedLabel，所以可以像label一样使用。label的特性全都有，使用起来更友好更方便。 FXLabel - FXLabel是一个功能强大使用简单的类库，通过提供一个子类改进了标准的UILabel组件，为字体增加了阴影、内阴影和渐变色等，可以被用在任何标准的UILabel中。FXLabel还提供了更多控件，可以对字体行距、字体间距等进行调整。 WFReader - 一款简单的coretext阅读器，支持文本选择、高亮以及字体大小选择等。 WPAttributedMarkup - WPAttributedMarkup is a simple utility category that can be used to easily create an attributed string from text with markup tags and a style dictionary。 HHFlashSwitch - 一个另类的UISwitch，选择后，背景水波扩散变色效果。 UUColorSwitch - Switch 开关动画效果,当打开开关时，Switch可实现平滑渲染过渡到父视图的效果。 UITextViewDIYEmojiExample - UITextView编辑时插入自定义表情-简单的图文混编。 ZSSRichTextEditor - 适用于iOS的富文本WYSIWYG编辑器，支持语法高亮和源码查看。ZSSRichTextEditor包含所有WYSIWYG标准的编辑器工具。 DTCoreText - 可以解析HTML与CSS最终用CoreText绘制出来，通常用于在一些需要显示富文本的场景下代替低性能的UIWebView。DTCoreText源码解析。 CSGrowingTextView - 用作即时通讯文本框和评论文本框使用，可以显示多行输入。 MarkdownTextView - 显示Markdown的TextView。 高仿微信限定行数文字内容 - 采用Autolayout高仿微信纯文字限定行数。 FuriganaTextView - 实现复杂的日文韩文排版。 ParkedTextField - 带固定文本的输入组件。 GJCFCoreText - 图文混排。 AttributedLabel - 显示性能数量级 UILabel 的 AttributedLabel。无畏无惧、挑战权威。 FFLabel - 自动检测 URLs, @username, #topic# 等关链词（提供响应扩展）。实用的标签文本小组件。 TextFieldEffects - 标准的UITextField有些枯燥么？来认识一下TextFieldEffects吧！废话不多说，只要看几个例子,是啊，都是些简单的dropin控制器。甚至可以在storyboard中使用IBDesignables。 AutocompleteField - 可应用于 iOS 应用中文字输入框自动补全的场景, 兼容到 iOS 8。 WordPress-Editor-iOS - 一个文本编辑器 简书和新浪博客都在用。 YYText - 功能强大的 iOS 富文本框架。 placeholder_TextView - 带有placeholder的TextView：带有提示信息的textview，使用懒加载的思想，支持扩展、自定义，类似许多APP内部的意见反馈页面 。 M80AttributedLabel - M80AttributedLabel实现文字与表情的混排。一般使用气泡作为背景。 HPGrowingTextView - HPGrowingTextView聊天输入文字，可以根据输入文字的多少自动改变输入框的高度。 图表@ PNChart - 国内开源作者，动态的图表。 YOChartImageKit - 支持在watchOS上绘制图表，看它最近更新挺勤快的，可以关注一下。 RealtimeGradientText - Fun With CALayer Mask 刚好今天开源了一个有趣的项目 RealtimeGradientText，所以也好聊一下 CALayer 的 Mask，说明。 XYPieChart -XYPieChart:饼状图, 饼图, 数据统计, 数据可视化,可以在图形上标注数据。效果十分漂亮，而且没有用到一张图片。 ZFChart - 模仿PNChart写的一个图表库，用法简单，暂时有柱状图，线状图，饼图三种类型，后续可能会更新新的类型。 ios-charts - 一款优秀 Android 图表开源库 MPAndroidChart 的 Swift 语言实现版（支持 Objective-C 和 Swift 调用）。缺省提供的示例代码为 Objective-C。 JYRadarChart 一个很赞的图表库 颜色@ Colours Colours–颜色库,包含100种预定义的颜色和方法 DKNightVersion - Manage Colors, Integrate Night/Multiple Themes 表相关@、TabbleView、Tabbar、即时聊天界面@TableView@ RETableViewManager 赞 一个非常强大的使用数据驱动的 UITableView 内容管理。 DZNEmptyDataSet - 非常赞 DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的tableview和collection view。会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理。 JSQMessagesViewController 一个优秀的即时聊天UI库 folding-cell 很赞 一个比较酷炫的cell折叠动画效果 VVeboTableViewDemo 此项目由VVebo剥离，希望你能通过这个demo看到我是如何进行TableView流畅度优化的。 SWTableViewCell - 国内开源作者，带很多手势的表单元格。 MCSwipeTableViewCell - 带很多手势的表单元格。 TMQuiltView - 瀑布流。 XRWaterfallLayout - 超简单的瀑布流实现,实现说明。 WaterfallFlowDemo - 一个简单的UICollectionView瀑布流布局演示demo。 XLForm - 很多表格类的table,写法更高冷一点，推荐使用。 RETableViewManager - 可以十分方便地生成各种样式、各种功能的TableView。只要开发者能想到的列表效果或者功能，都可以利用这份代码迅速编写出来。比如，之前要实现一个填写各种资料的列表，可能需要很多代码，现在只需要几行代码就可以实现。 UIScrollSlidingPages - 允许添加多视图控件，并且可以横向滚动。有点类似于Groupon app。 HorizontalScrollCell - HorizontalScrollCell是一款使用方便的水平方向可滚动的单元格，适用于UICollectionView中实现水片方向滚动视图。 。 SYJiugonggeTableView - tableView封装的九宫格。 SYJiugonggeTableView - tableView封装的九宫格。 UUChatTableView - UUChatTableView 气泡聊天界面，支持文本、图片以及音频的气泡聊天界面。源码推荐说明。 Atlas-iOS - 快速在iOS里集成聊天功能，类似开源版本的环信。Layer家开源了一套聊天app界面的解决方案.看起来很赞，很多蛮复杂的东西直接都帮封好了。不得不说现在做app开发真是很简单，大部分时间搭积木就可以了。官方网站。 DLSlideView - DLSlideView对常见的顶部Tab页点击、滑动分页做了封装。它使用基于ViewController的container特性（而不是scrollview）来管理各个子页面，以支持无限分页，源码推荐说明。 VOVCManager - 页面管理器:1.跳转指定页面,只需要知道viewController的Class名,如果有storyboard,则需要指定storyboard名；2.无需添加基类；3.支持URLScheme跳转指定页面。 MBXPageViewController - 简洁快速的页面切换–MBXPageViewController，带有按钮控件的UIPageController，非常整洁、简单以及快速。该项目通过三种形式展示页面之间的切换，比如导航栏上的多个tab切换、页面左右两端箭头指示切换，以及使用分段控件。 PagerTab - UIScrollView实现滑动转换页面，类似网易云音乐iOS版的页面滑动切换效果。* BATabBarController - A TabBarController with a unique animation for selection GUITabPagerViewController - 多个tab滑动切换。 VOMetroLayoutDemo - Metro风格的UICollectionView, 目前只支持横向布局,仅在iPad上应用。 KYCellAnimation - 给UITableViewCell增加进入的动画。 RDVTabBarController - 一个TabBar组件，可以方便设置底部菜单的文字图片，点击效果，小红点提示等。 WXTabBarController - 在系统 UITabBarController 的基础上完美实现了安卓版微信 TabBar 的滑动切换功能，单手操作 iPhone 6 Plus 切换 TabBar 一直是一件很痛苦的事情，而滑动切换是一种不错的解决方案，支持屏幕旋转。 GooeyTabbar - 皮筋式弹性缩放工具栏示例及演示。 CYLTabBarController - 低耦合集成TabBarController,最低只需传两个数组即可完成主流App框架搭建。 横向展示文本内容的自定义cell - 可以横向展示文本内容的自定义cell，根据文本无限滚动。 UITableView-FDTemplateLayoutCell - UITableView-FDTemplateLayoutCell 是一个方便缓存 UITableViewCell 的高度的框架。 ExpandingStackCells - 采用 UIStackView 实现表格单元格扩展内容显示示例及解决方案。 FDStackView - 可以将 UIStackView 的最低支持版本拉低到 iOS6，无需配置，没有代码侵染，扔到工程里后直接用系统 UIStackView 的 API 即可，同时兼容 Storyboard。 MDIHorizontalSectionTableViewController - 根据产品需求开源了一个交互项目，可以理解为横向Section的TableView，section和cell同时支持拖拽，后续安卓版本也会开源出来。 JZNavigationExtension - 多功能导航控制器，可以透明返回栏。 QuickRearrangeTableView - 基于 UITableView 的快速重排功能扩展子类。通过长按选定单元格然后滚动移动到指定位置。 uicollectionview-reordering - UICollectionViews的拖拽(拖动、移动)效果,实例教程. LLNoDataView - 超简单的空数据提示通用View支持UIScrollView、UITableView、UICollectionView、UIWebView。 MGSwipeTableCell - 另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。 XLPlainFlowLayout - 可以让UICollectionView的header也支持悬停效果，类似于tableView的Plain风格。 WMPageController - 一个方便的 pageContrller 的控件，里面还包括滚动视图。 PSTCollectionView - PSTCollectionView。 LLRiseTabBar-iOS - 直接使用系统的特性实现的tabbar，比较简单。 MTMaterialDelete - 非常有趣的Material Design动画，动画删除表里面的单元格。 BusyNavigationBar - 进度条式NavigationBar导航条。 LGSettingView - LGSettingView仅需三句代码即可快速集成设置界面，免去每次开发新应用都要重新布置设置界面的烦恼。 微博cell自动布局 - 使用autoLayout对微博的cell进行自动布局，自适应cell的高度。 TreeTableView - ZYTreeTableView：TreeView 模仿好友列表的实现方式。 ZWSlideViewController - ZWSlideViewController多页滑动视图控制器（类似新闻类门户APP）,可以用最简单的继承方法使用，也可以不用继承，只用菜单或主视图页面，可实现丰富的定制，可以使用在多种不同形态的APP下，还可以将其做为多页或多图的滑动介绍。 XWCatergoryView - 一个轻量级的顶部分类视图控件，只需要通过简单的设置，你就可以快速集成该控件， 控件目前暂时有底部横条移动，椭圆背景移动，文字缩放，文字颜色变化，和文字颜色渐变五种效果，五种效果可以叠加使用也可以单一使用。实现教程 jingDongFenLei - 简单仿写京东分类中的多级分类页面。 RKSwipeBetweenViewControllers - 页面滑动和标签选项卡类库。 FriendSearch - 两种UI的搜索，搜索的算法可以满足中英文互搜，联想搜索等，其中还包含对一组数据自动进行按字母分组等功能。 YX_UITableView_IN_UITableView - UITableview嵌套UITableView案例实践（仿淘宝商品详情页实现），项目讲解。 TYPagerController - 简单，支持定制，页面控制器,可以滚动内容和标题栏,包含多种style。 YZHeaderScaleImage一行代码快速集成tableView中头部缩放视图 CollectionView@ SFFocusViewLayoutUICollectionView的高级使用方法哦SFFocusViewLayou RACollectionViewReorderableTripletLayout自定义的CollectionView布局，可以通过拖动进行cell的重新排序。 CollectionViewClassifyMenuCollectionView做的两级菜单，可以折叠第二级菜单 隐藏与显示@ SlideTapBar - 滚动栏菜单，向上滚动时隐藏tabbar，向下滚动马上显示tabbar。 FoldingTabBar.iOS - 可折叠Tab Bar和Tab Bar Controller。 LTNavigationBar - LTNavigationBar为app导航栏添加动态着色效果，可自定义其背景色。Demo包含：1.变换背景色；2.滚动视图，导航栏和状态栏重叠。实现教程 KMNavigationBarTransition - LTNavigationBar在右滑返回的时候NavigationBar显示都不完美,KMNavigationBarTransition一个用来统一管理导航栏转场以及当 push 或者 pop 的时候使动画效果更加顺滑的通用库，并且同时支持竖屏和横屏。 HYNavBarHidden - 导航条滚动透明，超简单好用的监听滚动,导航条渐隐的UI效果实现。 BLKFlexibleHeightBar - 非常赞，是一个使导航栏高度可以动态变化的 UI 库。固定Header的效果库，一个拥有非常灵活高度的标题栏，可以为使用软件的用户提供更多的阅读和滑动空间，现在已经被众多app所采用。 JXT_iOS_Demos - AboutNavigationBar:一些关于navigationBar的非常规的但是较为实用的操作，包括利用毛玻璃、动态透明、动态隐藏，以及头视图的动态缩放，并同时涉及了statusBar的动态设置（换色）。教程。 NavigationBarScaleViewDemo - iOS导航条自由缩放头像效果。原理剖析。 HUD与Toast@ MBProgressHUD - 最多人用的loading。 SVProgressHUD - SVProgressHUD的loading，如果你需要定制化的等待提示器，这个就是了（也许是最好的）。 EBuyCommon - 1.基于MBProgressHUD实现得图形加载提示方式，及其它标题方式提醒。2.弹窗。 WZDraggableSwitchHeaderViewShow status for transition across viewControllers. ProgressHUD - ProgressHUD的loading，使用最简单。 MMProgressHUD - 设置HUD出现和消失的方式（包括上下、左右、淡入淡出、放大缩小等等），设置HUD的内容（可以在HUD中加入帧动画、动态图片等等），设置HUD出现时的底部覆盖层颜色，等等。总而言之，这是一份集大成的HUD代码。慢慢看视频吧，囊括了所有效果。 WSProgressHUD - 一个小巧精致的HUD,支持添加到自定义View上, 还有更多小细节.。 PreLoader - 一个很有意思的HUD loading ，通过运动污点和固定污点之间的粘黏动画吸引用户的眼球跟踪，能有效分散等待注意力。PreLoader的实现讲解 FillableLoaders - 自定义加载进度UI-Completely customizable progress based loaders drawn using custom CGPaths written in Swift :large_orange_diamond:对话框@ LCActionSheet 一款简约而不失强大的 ActionSheet，微信和微博都采取了极其类似的样式。 WCAlertView - 自定义的对话框。 IOS7AlertView - IOS7AlertView的对话框。 AMSmoothAlert - 动画效果不错，最多star，但不支持arm64。 DQAlertView - 扁平化的样式不错。 HHAlertView - 一个简易的alertview 有三种样式，有成功，失败，和警告三种样式，支持Delegate和block两种回调。 MJPopupViewController - 实现弹出视图的各种弹出和消失效果，包括淡入淡出（fade in，fade out），从屏幕上方飞进，下方飞出，从屏幕左方飞进，右方飞出等等效果，弹窗。 MMPopupView - 弹出框的基类组件（弹窗）。 Menu - 项目中可能会用到的常用菜单，以后有时间会继续补充，弹窗。 EasyTipView - 弹出提示框类及演示示例。同样地，API 简单、易用。好“轮子”，弹窗。 kxmenu - kxmenu弹出菜单，点击视图上任意位置的按钮，会弹出一个菜单，并且有个小箭头指向点击的按钮，类似气泡视图。弹出的菜单位置会根据按钮的位置来进行调整。 QBPopupMenu - QBPopupMenu弹出菜单，实现类似 UIMenuItem 的弹出菜单按钮。点击按钮，会弹出一个菜单，上面可以排列多个按钮。纯代码实现，不需要任何图片。 STModalDemo - 弹出视图（通知，提示，选择，窗口）。 TAOverlay - TAOverlay可通过叠加层展示有用的信息，可自定义文本和背景色，添加阴影和模糊效果，以及更改字体大小或者用自定义图片替换页面上的icon。 UICustomActionSheet - 通过模糊背景来着重强调与菜单相关的元素–模糊效果 里面已经收藏。 ActionSheetPicker-3.0 - 该项目是此前热门项目ActionSheetPicker的新版本，快速复制了iOS 8上的下拉 UIPickerView/ActionSheet功能。 MJAlertView - 3D效果转场效果警示图–MJAlertView。 PSTAlertController - 兼容 iOS7的 XXAlertController，接口跟UIAlertController 一模一样，做到高低版本通用。 PCLBlurEffectAlert.swfit - 细节定制较丰富的弹出警报窗口组件。 GSAlert.swfit - 苹果在iOS8推出了全新的UIAlertController，旧的UIAlertView和UIActionSheet渐渐被废弃，但如果你仍然支持iOS7系统，你将不得不写两套代码。GSAlert解决了这个问题。 SweetAlert-iOS - SweetAlert-iOS 带动画效果弹窗对话框封装类。 DXPopover - DXPopover微信右上角的+点击展示列表效果，弹窗菜单。 CCActionSheet - CCActionSheet：仿照微信朋友圈自定义actionsheet，一行代码即可使用。 CustomPopOverView - 自定义弹出视图，内容支持传一组菜单标题，也支持自定义view，或者自定义viewController，支持任意按钮触发，会显示在按钮底部，也支持切换按钮的对齐方式：左对齐、居中、右对齐。 TOActionSheet 是一个 iOS UI 控件，提供一个模态提示控制，类似于 UIActionSheet。不同于 UIActionSheet 的是，它可以深度重设主题，通过对每个按钮使用块来避免委托模式 状态栏@ MTStatusBarOverlay MTStatusBarOverlay 是一个定制的 iOS 状态栏，用于覆盖系统默认的状态栏，类似 Reeder, Evernote and Google Mobile App。支持两种点击动作：1. 当用户点击状态栏时，状态栏会收缩，仅仅遮盖住状态栏右方的电池图标；2. 当用户点击状态栏时，一个有详细信息的视图会从系统状态栏中下拉出现。 导航栏@ AMScrollingNavbar 一个可以上拉隐藏导航栏和下拉显示导航栏的框架 JTNavigationController 一个拥有更平滑的navigationBar切换动画的NavigationController NavigationController 实现类似微信的 webView 导航效果，包括进度条，左滑返回上个网页或者直接关闭，就像 UINavigationController 设置@ InAppSettingsKit InAppSettingsKit 是一款功能强大的ios设置组件，可以满足各种各样的app设置需求。 ViralSwitch A UISwitch that infects its superview with its tint color. Switch@ JTMaterialSwitch A Customizable Switch UI for iOS, Inspired from Google’s Material Design 主题@ LEETheme 优雅的主题管理库- 一行代码完成多样式切换 电影选座@ ZFSeatsSelection 高仿猫眼电影选座（选票）模块（High imitation opal film seat selection (vote) module） 瀑布流@ CHTCollectionViewWaterfallLayout 赞 UICollectionViewLayout的一个子类，尽可能地模仿了UICollectionViewFlowLayout的用法，灵感来源于Pinterest，同时还兼容PSTCollectionView。 菜单@ circle-menu 赞 一个不错的旋转点击菜单，类似于遥控器的上下左右中点击样式 其他UI@ drawablebubbleQQ中未读气泡拖拽消失的实现分析分析文章 日历@ MSSCalendar A simple iOS Calendar 高性能日历控件（类似去哪网） Calendar - 日历、行程安排类的View和控制器。A set of views and controllers for displaying and scheduling events on iOS Activity Indicator@ AwesomeMenu - 最多人用的Path菜单。 DCPathButton - Path，4.0的弹出菜单，呼出或者关闭菜单时，多个小图标会分别按照逆时针和顺时针的方向进行滚动。 SphereMenu - 利用UIDynamicAnimator的有趣的菜单，path类似。 KYGooeyMenu - KYGooeyMenu 是一个具有 Gooey Effects 带粘性的扇形菜单控件(卫星菜单、path)。 LiquidFloatingActionButton - 卫星弹出菜单。 JZMultiChoicesCircleButton - 三维多选按钮。 LCUIKit - 一个button上面既有icon又有文字。也许左icon右文字，或者上icon下文字。 TwitterPaggingViewer - 多个Tableview，左右滑动。 CircularProgressControl - Circular Progress Control using CAShapeLayer ，环形进度控制条。 KYCircularProgress - 简单、实用路径可定进程条。 TextProgress - 自定义实现数字进度条：1、可以自定义数字（0-100），填充的比例为当前设置的数字，2、可以实现自定义填充颜色，上下部分都可以，3、可以自定义边界的颜色4、实现了水波动画，可以设置打开或关闭。 SDProgressView - 简便美观的进度指示器，此系列共有六种样式的进度指示器。 NVActivityIndicatorView - loading 进度条动画，有20-30多种，是在此DGActivityIndicatorView 基础上做得修改。 LoopProgressDemo - 环形渐变进度条，环形渐变进度条实现。 XLPagerTabStrip - 做的很棒的iOS下的PagerTabStrip。 ASProgressPopUpView - 弹出的进度条显示进度。 HexColorService - 将16进制颜色字符串转成UIColor。 Rainbow - 旨在提高代码可读性及易用性的 UIColor 扩展，它使原先有限的预定义颜色（方法）选择，扩展至超过 1200 种。 UIColor-ChineseTraditionalColors - 中国传统颜色引用 UIColor 扩展。“UIColor.桃红()，UIColor.竹青() …”，共158种。 类似美团的下拉菜单 - 类似美团的下拉菜单，源码推荐说明。 类似美团的下拉选项 - 类似于美团、大众点评的下拉菜单选项，code4app代码，评论代码有瑕疵。 CRMediaPickerController - 一个简单易用的图片/视频选择器。1.可同时选择照片和视频。 2.挑选范围有Camera、Camera Roll、Photo Library以及最近拍摄的照片和视频。3.可自定义UIImagePickerController属性（Camera Overlay、Camera Device、Camera View Transform以及allowsEditing）。4.支持横屏和竖屏5.原生的iOS UI。，源码推荐说明。 MDCSwipeToChoose - MDCSwipeToChoose可简单地添加滑动手势来调用UIView，并使用该行为提供了一个组件以创建类似Tinder app的like或者dislike界面的轻扫。基于轻扫的方向，你可以决定执行什么样的行为，并且你可以自定义文本颜色和图片。该项目适用于教学用的抽认卡、图片查看器以及其他等。 iOS Material Design库 - 该项目借鉴于谷歌的Material Design guideline，用户可自定义背景色。 Material-Controls-For-iOS - Material Design风格的各种控件，非常完整全面。 MediumScrollFullScreen - Medium的可扩展滚动页面，上下滚动时，全屏显示内容，并自然消隐上下菜单。由此项目感知，作者是一位很注重细节的开发者，他的另外几个菜单类项目也都不错，值得参考，比如：PathMenu, MediumMenu 等。 WZFlashButton - WZFlashButton，点击后button里面出现水波扩散效果。 ios-multi-back-button - 可替换内置的UInavigationController返回按钮，长按左上角的返回按钮，实现多层级的快速返回。 ASDayPicker - 适用于iOS (iPhone)的日期选择器(时间选择器)，类似于Calendar app的周视图。 today extension - 用纯代码构建一个Widget(today extension) 。 HSDatePickerViewController - 带有Dropbox Mailbox感觉的时间日期选择器(时间选择器)。启动是背景被模糊化。界面也是主流的扁平化风格。 HZQDatePickerView - 自定义时间选择器(日期选择器)，包括开始日期和结束日期两种类型。 CFCityPickerVC - 城市选取控制器。 JTCalendar - iOS下优美的 Calendar 组件，做 GTD 类 App 必备。 PDTSimpleCalendar - 是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。 Form - JSON 驱动的 Form表单系统，复杂的表单填写类 App 极其需要（比如淘宝呢！）。 ImagePickerSheetController - 图片或视频选择器（可多选）组件及其示例项目。 ImagePickerSheet - 图片或视频选择器（可多选）组件及其示例项目。 RKNotificationHub - 快速给 UIView 添加上炫酷的通知图标（Badge、红点、提示）。 WZLBadge - Badge，支持横竖屏支持iOS5~iOS8允许高度定制化，包括“红点”的背景颜色，文字(字体大小、颜色)，位置等。说明. BubbleTransition - 以气泡膨胀和缩小的动画效果来显示和移除 controller，Uber的就是这种取消操作的方式。 KYFloatingBubble - 类似iOS7中Game Center浮动气泡的效果。 DKNightVersion - DKNightVersion 是一个支持夜间模式切换的框架。 EasyUIControl - 一个可以简化界面ui的控件框架。 QQBtn - 仿QQ未读消息弹性按钮动画，达到和手机QQ未读信息一样的动画效果，效果基本实现。 TZStackView - OS 9 UIStackView 功能模拟实现于 iOS 7/ iOS 8 内。 HACursor - HACursor，是一个对横向ScrollView中的视图进行管理的UI控件。只要几行代码就可以集成类似于网易新闻对主题页面进行排序，删除操作的功能。 ZTPageController - 模仿网易新闻和其他新闻样式做的一个菜单栏，栏中有各自的控制器，其中有4中展示样式’网易style’ ’搜狐style’ ’腾讯style1’ ’网易style2’ 。 Ruler - 尺子。 HUMSlider - HUMSlider是一款能够自动显示刻度记号的滑竿，滑动到某处，该处的刻度会自动上升，两边还能配置图像。支持代码或storyboard中实现。 JDSelectedDemo - 仿京东筛选菜单实现。 3DTouchDemo - 详细介绍了每个参数的含义和3Dtouch的入口，保证包学包会。 3DTouchSample - 3D-Touch的功能分为两个部分：Shortcut和Preview。 SBShortcutMenuSimulator - 教你如何在模拟器上测试 3D Touch 功能! 仿LOL滚动视图 - 仿LOL滚动视图。 答题选择切换页 - 将scrollview和tableview封装在一起，在初始化的时候简单的将数据带上，就可以一页一页的左右来回滑动。 SCTrelloNavigation - 类似trello的导航动效控件实现。 XTPaster - 贴纸功能出现在很多图片社交中, 就是图片上面贴图片, 对贴纸而言就是需要控制贴纸的位置,旋转,大小,如何使用。 RGCategoryView - 仿了个苏宁易购的分类页面。 LLPieCharts - LLPieCharts iOS 绘制饼图，教程。 BEMCheckBox - BEMCheckBox 是一个用于 iOS 应用上构建漂亮, 高度可定制化动画效果的复选框类库, 最低支持到 iOS 7 系统, 有多种不同风格的动画效果可供选择。 STPopup - 提供了一个可在 iPhone 和 iPad 上使用的具有 UINavigationController 弹出效果的 STPopupController 类, 并能在 Storyboard 上很好的工。 VBFPopFlatButton - 通过几条线段实现的非常Q萌的动画按钮效果。 CustomSearchBar - 自定义searchbar,类似于instagram的搜索框效果。 LNPopupController - AppleMusic式pop up，弹出是页面，可以上下拉动。 DGRunkeeperSwitch - 动画segment，节选器。 DynamicMaskSegmentSwitch - 一个简单有趣的 SegmentedControl 节选器。 YXFilmSelectView - 仿造时光网选择电影票的UI而开发的一个自定义View。 FJTagCollectionView - 标签（适配宽度）。 DFTimelineView - DFTimelineView仿微信朋友圈 时间轴。 HYBImageCliped - 可给任意继承UIView的控件添加任意多个圆角、可根据颜色生成图片且可带任意个圆角、给UIButton设置不同状态下的图片且可带任意圆角、给UIImageView设置任意图片，支持带圆角或者直接生成圆形。 StackViewController - 方便 iOS 开发者使用 UIStackView 构建表单或其它静态内容视图。 LLBootstrapButton - Bootstrap 3.0扁平化风格按钮，自带图标，一句代码直接调用！ JMRoundedCorner - UIView设置不触发离屏渲染的圆角！ 游戏@ cocos2d-objc Cocos2d for iOS and OS X, built using Objective-C 侧滑与右滑返回手势@ ViewDeck 项目需要用到左侧右侧各有一个抽屉视图，而这个类库可以极其简单的实现这个功能，不单单是左右各一个，它可以随意设置上下左右的抽屉视图，简直是360度想怎么抽怎么抽 A-FDFullscreenPopGesture 非常棒的全屏手势侧滑，只需导入此库，就可以让你的App具备左滑返回功能，不用写一句代码。 SloppySwiper - iOS系统自带的UINavigationController要7.0才支持，但不过该手势只能从屏幕左侧边缘识别，如果要扩大到整个屏幕范围怎么办？配合一个SloppySwiper无需代码就可以轻松实现。此库支持iOS5.0以上版本（另外：Nav的title滑动不明显，本人写了2个类似的控件），SloppySwiper-demo ：代码方式与storyboard方式。 SCNavigation - UINavigation可以右滑返回，隐藏UINavigationBar。 UINavigationController-YRBackGesture - 支持右滑返回手势，标题栏不动。 GHSidebarNav - 现在比较流行使用侧开(侧滑)菜单设计。试了不少控件，感觉GHSidebarNav最成熟，尤其对纯代码创建的界面兼容性最好。在Storyboard中使用GHSidebarNav侧开菜单控件。 iOS-Slide-Menu - 能够类似Facebook和Path那样弹出左右边栏侧滑菜单,还支持手势。多种可以自定义的属性 (非常不错)。 ECSlidingViewController - 侧滑菜单。 JASidePanels - 侧滑菜单,有左右菜单，有pop功能，支持手势侧滑,本人使用中：简单。 animated-tab-bar - 让 Tabbar items能显示萌萌的动画。 tabbar图标动画 - tabbar上图标的动画实现，源码推荐说明。 RESideMenu - 侧开菜单，qq类似。 JHMenuTableViewDemo - 仿网易邮箱列表侧滑菜单。 SlideMenuView - 炫酷侧滑菜单布局框架，Android版本的一致实现。 KGFloatingDrawer - 侧滑菜单，qq类似，KyleGoddard/KGFloatingDrawer：一款适合于大屏手机或平板的浮动抽屉式导航界面组件。效果很赞- 侧开菜单，qq类似（与RESideMenu类似）。 AIFlatSwitch - 一款带平滑过渡动画的 Switch 组件类，类相同风格的 Menu/BackHamburgerButton,类似相同风格的 Menu/Closehamburger-button. JHChainableAnimations - 在应用中采用链式写出酷炫的动画效果, 使代码更加清晰易读，利用block实现的链式编程。 WXGSlideMenuDemo - 个简单实现侧拉（侧滑）菜单的小demo，供初学者共同学习、练习使用。 PKRevealController - PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷），这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。 FlipBoardNavigationController - FlipBoardNavigationController。 MMDrawerController - 最多人用的一个有关侧边“抽屉”导航框架，里面还有很多你意想不到的交互效果，侧滑。 UIWebView翻页返回效果 - UIWebView翻页返回效果（变通方法）。 LLSlideMenu - 一个弹性侧滑菜单,弹性动画原理借鉴该项目中阻尼函数实现。 ScreenShotBack 全屏返回，截图手势返回，景深效果，类似斗鱼、天天快报、腾讯新闻等APP的手势返回。 动画@gif动画@ UIImageView-PlayGIF - UIImageView-PlayGIF。 YLGIFImage - YLGIFImage。 droptogif - droptogif视频拖拽到应用窗口后自动转换为 GIF 动画（其转换进程动画效果也超赞）。 其他动画@ MMTweenAnimation一个基于 POP 的扩展，提供了 10 种自定义的动效。 pop - facebook出品的非常赞的动画引擎。 Core Animation笔记，基本的使用方法 - Core Animation笔记，基本的使用方法：1.基本动画，2.多步动画，3.沿路径的动画，4.时间函数，5.动画组。 awesome-ios-animation - iOS Animation 主流炫酷动画框架(特效)收集整理 收集整理了下iOS平台下比较主流炫酷的几款动画框架。 awesome-animation - 在内的十多位童鞋们一起发起的一起动画开源组正式成立啦~Github组织名称：Animatious，这是我们第一期成员先前开源的一些动效库，我们的第一个合作开源项目正在紧锣密鼓的准备~请大家期待设计和代码的碰撞吧。 BCMagicTransition一个动效框架，用于自定义UINavigationController的切换动画，效果类似 Keynote 软件中 Magic Move 切换。它可以用于任意两个UIViewController之间，只需指定两个VC中的相同元素即可。 popping - popping是一个POP 使用实例工程 PopMenu - 用POP动画引擎写的Sina微博的Menu菜单。 SinaMenuView - 用POP动画引擎写的Sina微博的Menu菜单。 MMTweenAnimation - facebook POP的自定义动画扩展(基于POPCustomAnimation) 提供10种函数式动画。 ZQLRotateMenu - 这是一个旋转视图的选择器。 CoolLoadAniamtion - 一个简单但是效果不错的loading动画。 SequenRotateAnimation - 一个简单的loading次序动画。 SYAppStart - App启动插画的自定义过度。 VJDeviceSpecificMedia - 如何根据设备选择不同尺寸的图片 可以通过设置不同尺寸设备的LaunchImage，来使得App适配这些设备，要是在不同不同尺寸设备上使用不同大小的图片，则需要在代码中一一判断，然后加载。 RMParallax - RMParallax是一个app启动页引导开源项目，除了细微的翻页视差效果，描述文本的过渡也非常美观（版本新特性、导航页、引导页）。 ADo_GuideView - 转动的用户引导页(模仿网易bobo) 因为没有从app包里抓到@3x的图片,建议在iPhone5模拟器运行,保证效果~ （版本新特性、导航页、引导页）。 CoreNewFeatureVC - 版本新特性（引导页），1.封装并简化了版本新特性启动视图！2.添加了版本的本地缓存功能，3.集成简单，使用方便，没有耦合度，4.支持block回调（版本新特性、导航页、引导页）。 MZGuidePages - 自己写的通用导航页，可以直接引入工程使用，请参考案例（版本新特性、导航页、引导页）。 ABCIntroView - ABCIntroView是一个易于使用的入门类，让你到达主屏幕之前介绍你的应用程序（版本新特性、导航页、引导页）。 KYBezierBounceView - 手势控制贝塞尔曲线，取消手势贝塞尔曲线会有反弹效果。 cadisplaylinkanduibezierpath - CADisplayLink结合UIBezierPath的神奇妙用。 KYCuteView - 实现类似QQ消息拖拽消失的交互+GameCenter的浮动小球效果，分析。 KYWaterWaveView - 一个内置波浪动画的UIView，里面有鱼跳跃水溅起来的效果。 WaveLoadingView - iOS 唯一完美的波浪进度加载指示器，实现说明。 KYPingTransition - 实现圆圈放大放小的转场动画，可以根据自己的需要使用Paper中的弹性效果，有Material风格。 KYNewtonCradleAnimiation - 牛顿摆动画。 LayerPlayer - 一款全面展示核心动画 API 示例项目（上架应用）。包括 CALayer, CAScrollLayer, CATextLayer, AVPlayerLayer, CAGradientLayer, CAReplicatorLayer, CATiledLayer, CAShapeLayer, CAEAGLLayer, CATransformLayer, CAEmitterLayer 等使用的互动演示。 KYShareMenu - 带弹性动画的分享菜单。 Context-Menu.iOS - 可以为app的菜单添加漂亮的动画内容，可自定义icon，并可根据自己的喜好设计单元格和布局。 DeformationButton - 一个简单的变换形状动画按钮。 UnReadBubbleView - UnReadBubbleView是一个能够拖拽并拉长的气泡视图。拖拽到一定的长度会消失，可以通过系数设置来控制拖拽的长度。气泡也支持多种属性设置。 PPDragDropBadgeView - 实现了类似于QQ 5.0 水滴拖拽效果. 支持iOS 5.0+ ARC，气泡能够带有数字标识，同时支持消失block方法。消失时还带有消失效果动画。 GiftCard-iOS - 礼品卡购买的炫酷动画。 GiftCard-Implementation - 购买的炫酷动画。 SDCycleScrollView - 无限循环自动图片轮播器(一步设置即可使用)。 HYBLoopScrollView - HYBLoopScrollView实现自动循环滚动，一般用于展示广告页。微信在贴纸宣传处就使用了轮播。 iCarousel - iCarousel是一个类，它继承于UIView。用于简化实现各种类型的旋转木马(分页滚动视图），无限轮播 ，iOS开发之多图片无缝滚动组件封装与使用。 KIPageView - 无限循环PageView，横向TableView，无限轮播。 简单实用的无限循环轮播图 - 简单实用的无限循环轮播图 。 CPInfiniteBanner - 是一个循环播放的组件，可以左右无缝滑动,3个imageview实现。高效图片轮播，两个ImageView实现。 XTLoopScroll - 用两个 timer 三个重用的 view 实现无限循环 scrollView，1自动轮播 2点击监听回调当前图片 3手动滑动后重新计算轮播的开始时间, 良好的用户体验。 HotGirls - 卡片动画。 QQPersonalInfoTransition - 仿照QQ的转场。 KYAnimatedPageControl - 除了滚动视图时PageControl会以动画的形式一起移动，点击目标页还可快速定位。支持两种样式：粘性小球和旋转方块。 Presentation - 一个类似RazzleDazzle的框架。 FillableLoaders - 基于 CGPaths 可定制个性化填空式装载类库。附水波上涨式示例。 SXWaveAnimate - 实现非常美观的灌水动画。 LSPaomaView - 可循环滚动的较长文字，跑马灯，效果很好，一句话集成。 Cheetah - 易用、高可读链式动画类库。另一个类似类库是 DKChainableAnimationKit。 CKWaveCollectionViewTransition - swift， UICollectionViewController之间切换的动画。 TKSubmitTransition - 基于 UIButton 的登录加载、返回按钮转场动画组件及示例。 ARAnimation - ARAnimation 对 Core Animation 进行了封装, 帮助 iOS 开发者能更加便捷的在项目中使用动画。 渐变特效文字 - 做了一个仿iPhone的移动滑块来解锁的渐变特效文字,还有一个类似ktv歌词显示的文字特效。 HYAwesomeTransition - 模仿格瓦拉的转场效果。 TaskSwitcherDemon - 是仿造iOS9的Task Switcher做出来的动画效果, 具体的实现思路可参照这篇文章。 RYCuteView - 用UIBezierPath实现果冻效果。 教程 MDCSwipeToChooseView - MDCSwipeToChooseView翻牌子效果。 STLBGVideo - STLBGVideo让您的视图控制器的自定义backgroundvideo,实现说明1、实现说明2。 PanelDemo - 仪表盘,模拟汽车的车速仪表盘,一些简单的数学知识。 MYBlurIntroductionView - 方便好用的引导类库，在App注册登录页面可以用到。 ZFCityGuides - 实现City Guides的动画效果，数字动态变化的动画效果。 INPopoverController - OS X可自由定制的 Popover 视图。 WZXJianShuPopDemo - 仿简书、淘宝等等的View弹出效果，已封装好，使用简单。实现原理 网络相关@网络连接@ AFNetworking - ASI不升级以后，最多人用的网络连接开源库 iOS开发下载文件速度计算 , AFNetworking 3.0迁移指南 , AFNetworking2.0源码解析&lt;一&gt; 、AFNetworking2.0源码解析&lt;二&gt;、AFNetworking源码解析&lt;三&gt;、AFNetworking源码解析&lt;四&gt;。 YTKNetwork - 是基于 AFNetworking 封装的 iOS网络库，提供了更高层次的网络访问抽象。相比AFNetworking，YTKNetwork提供了以下更高级的功能：按时间或版本号缓存网络请求内容、检查返回 JSON 内容的合法性、文件的断点续传、批量的网络请求发送、filter和插件机制等。 HYBNetworking - 基于AFN封装的网络库，可以通用。基于AFNetworking封装网络库说明目前已经提供了通用的GET/POST、上传、下载API等。 LxFTPRequest - 支持获取FTP服务器资源列表，下载/上传文件，创建/销毁ftp服务器文件/目录，以及下载断点续传，下载/上传进度，自动判断地址格式合法性跟踪等功能！国人开发，QQ：349124555。 HSDownloadManager - HSDownloadManager，下载音乐、视频、图片各种资源，支持多任务、断点下载。 MutableUploadDemo - 模拟需求：图文混编，要求用户选择图片后就上传，可选择多图，并行上传，用户确定提交后后台执行，必须全部图片上传完才能提交文字。 WTRequestCenter - 方便缓存的请求库，提供了方便的HTTP请求方法，传入请求url和参数，返回成功和失败的回调。 UIKit扩展提供了许多不错的方法，快速缓存图片，图片查看，缩放功能， 颜色创建，设备UUID，网页缓存，数据缓存等功能。 无需任何import和配置，目前实现了基础需求。 MMWormhole - Message passing between iOS apps and extensions 2个iOS设备之间通信。 STNetTaskQueue - STNetTaskQueue Objective-C 可扩展网络请求管理库。 CocoaAsyncSocket - 在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大，使用教程。 AsyncSocket - AsyncSocket。 Socket通信 - 通过AsyncSocket封装的Socket通讯方法，简单实用，通俗易懂，初学者不能错过 。 GCDAsyncSocket - GCDAsyncSocket ， 不错的Demo。 MZDownloadManager - 下载管理。 DVR - 针对网络请求的测试框架，超实用的工具。且支持 iOS, OSX, watchOS 全平台。 HFDownLoad - iOS开发网络篇之文件下载、大文件下载、断点下载:NSData方式、NSURLConnection方式、NSURLSession下载方式 下载方式具体的思路、区别见Blog 。 HYBUnicodeReadable -解决打印日志对于Unicode编码不能正常显示中文的问题，只需要将文件导入工程，不需要引用，就能达到打印日志显示Unicode编码中文数据 PPNetworkHelper - AFN3.x与YYCache的二次封装,一句话搞定网络请求与缓存,和FMDB说拜拜! 图像获取@ SDWebImage - SDWebImage 网络图片获取及缓存处理。 UIActivityIndicator-for-SDWebImage 为SDWebImage显示加载效果 FastImageCache -非常赞 FastImageCache 网络图片获取及缓存处理，iOS图片加载速度极限优化—FastImageCache解析。 EGOCache - 十分知名的第三方缓存类库，可以缓存NSString、UIImage、NSImage以及NSData。除此，如果还可以缓存任何一个实现了接口的对象。所有缓存的数据都可以自定义过期的时间，默认是1天。EGOCache 支持多线程（thread-safe），UITableView加载多张照片导致内存上涨的问题。 YYWebImage - 一个图片加载库 YYWebImage，支持 APNG、WebP、GIF 播放，支持渐进式图片加载，更高性能的缓存，更多图像处理方法，可以替代 SDWebImage 等开源库，相关文章。 SVGKit SVGKit是一个非常强大的，可以快速渲染SVG文件的框架。你可以直接把SVG文件加载至app中，并且SVG中的每个图形会变成一个CAShapeLayer，可以方便地进行缩放和动画你的图形。如果你想渲染app中的矢量图形，SVGKit是个不错的解决办法。 网络聊天@ XMPPFramework - XMPPFramework openfire聊天。 SXTheQQ - 用xmppFramework框架编写QQ程序，主要为了练习通讯的一些原理，界面比较渣 必须要先在本地配置好环境才可以运行。 环信 - 给开发者更稳定IM云功能。8200万用户考验，好用！（暂无及时语音、视频通话） 融云 - 即时通讯云服务提供商。（暂无及时语音、视频通话） 容联云通讯 - 提供基于互联网通话,视频会议,呼叫中心/IVR,IM等通讯服务。 ChatSecure-iOS - 基于XMPP的iphone、android加密式聊天软件， chatsecure官网 。 iOS代码1，iOS代码2， iOS中文版。 chatsecure - 基于XMPP的iphone、android加密式聊天软件， chatsecure官网 。 iOS代码1，iOS代码2， iOS中文版。 MessageDisplayKit - 仿微信聊天，参考JSQMessagesViewController。（国人写） JSQMessagesViewController - 聊天 。 SunFlower - 环信聊天demo，比较多功能 。 BlueTalk蓝牙聊天 - 以MultipeerConnectivity为基础， 实现了简单的蓝牙聊天。 网络测试@ Reachability - 苹果提供过一个Reachability类，用于检测网络状态。但是该类由于年代久远，并不支持ARC。该项目旨在提供一个苹果的Reachability类的替代品，支持ARC和block的使用方式。iOS网络监测如何区分2、3、4G SimpleCarrier - 简单的运营商信息获取!。 NetworkEye - 一个网络调试库，可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试。 RealReachability - iOS下的实际网络连接状态检测，解决“如何判断设备是否真正连上互联网？而不是只有网络连接”的问题。 WebView与WKWebView@ WebViewJavascriptBridge 是一个连接javascript和iOS Native交互的开源框架。使用它可以在UIWebview中响应事件并执行Native方法,也可以使用Native方法调用javascript方法, 正如其名,它好像已做桥梁连接了两端. MGTemplateEngine - MGTemplateEngine比较象 PHP 中的 Smarty、FreeMarker 和 Django的模版引擎，是一个轻量级的引擎，简单好用。只要设置很多不同的HMTL模版，就能轻松的实现一个View多种内容格式的显示，对于不熟悉HTML或者减轻 工作量而言，把这些工作让设计分担一下还是很好的，也比较容易实现设计想要的效果。 NJKWebViewProgress - 一个 UIWebView 的进度条接口库,UIWebView 本身是不提供进度条的。 GTMNSString-HTML - 谷歌开源的用于过滤HTML标签。 js-in-ios - webView与js的交互。 D3Generator - D3Generator根据dict字典生成对象。 适用webview和push推送时，根据后台传回字典实现动态跳转。实现说明 [GRMustache] (https://github.com/groue/GRMustache) 一个类似templateEngine的html渲染工具，可以更加有效的帮助大家完成数据生成HTML的过程。 iOS-WebView-JavaScript iOS UIWebView,WKWebView 与 JavaScript的深度交互 网络解析@JSON@ MJExtension - 用于json转model进行使用，转换效率很高，使用也比较简单，只要前后台约定好，json直接就转成了model。 YYModel - High performance model framework for iOS/OSX. JSONKit - JSONKit库是非常简单易用而且效率又比较高的，重要的JSONKit适用于ios 5.0以下的版本,使用JSONKit库来解析json文件，只需要下载JSONKit.h 和JSONKit.m添加到工程中；然后加入libz.dylib即可。 JSONModel - 解析服务器返回的Json数据的库,JSONModel源码解析一。 Mantle - Mantle主要用来将JSON数据模型化为OC对象, 大系统中使用。为什么选xzx1212择Mantle。 RFJModel - RFJModel是一个IOS类库，可以将JSON字典自动装填到OBJC对象。相比JSONModel有一些非常好的特性，使用上也比较简单。 XMLDictionary - ios与mac os平台下xml与NSDictionary相互转化开源类库。 DDModel - 快速搭建项目Model层，支持ORM映射关系，能从JSON/XML直接实例一个Model对象。支持SQLite本地数据持久化，封装了HTTP， 减少HTTP代码与UIViewController的代码耦合，支持Cache；类似RESTKit、Mantle的功能；使用该类库以后简化了网络层的开发工作，把更多的精力放在UI上面；目前只支持GET/POST方法的请求。使用到的第三方库有：1.SQLitePersistentObject; 2.JTObjectMapping; 3.AFNetworking; 4.XMLDictionary; TouchJSON - JSon解析库(早已停止更新) JSON-Framework - JSON解析库 Groot - From JSON to Core Data and back. KZPropertyMapper - 可以帮助你在对象与Array、Dict数据间进行转换，尤其适用于将json对象转换成objective-c中的实体对象。作者还写了一篇文章stop-writing-data-parsing-code-in-your-apps介绍它的使用。 FastEasyMapping - Serialize &amp; deserialize JSON fast. OCMapper - Objective-C &amp; Swift library to easily map NSDictionary to model objects. :large_orange_diamond: ObjectMapper - A framework written in Swift that makes it easy for you to convert your Model objects (Classes and Structs) to and from JSON. :large_orange_diamond: JASON - JSON parsing with outstanding performances and convenient operators. :large_orange_diamond: Gloss - A shiny JSON parsing library in Swift. :large_orange_diamond: Cereal - Swift object serialization :large_orange_diamond: SwiftyJSONAccelerator - Generate Swift model files from JSON using either SwiftyJSON or ObjectMapper. Supports NSCoding and provides method for JSON string representation of the model. :large_orange_diamond: JSONCodable - Hassle-free JSON encoding and decoding in Swift :large_orange_diamond: Coolie - Coolie helps you to create models (&amp; their constructors) from JSON file. :large_orange_diamond: Tailor - A super fast &amp; convenient object mapper tailored for your needs. :large_orange_diamond: alexander - An extremely simple JSON helper written in Swift. :large_orange_diamond: Freddy - A reusable framework for parsing JSON in Swift. :large_orange_diamond: mapper - Another JSON deserialization library for Swift :large_orange_diamond: AlamofireJsonToObjects - An Alamofire extension which converts JSON response data into swift objects using EVReflection :large_orange_diamond: Alembic - Functional JSON parsing, mapping to objects, and serialize to JSON :large_orange_diamond: Wrap - The easy to use Swift JSON encoder :large_orange_diamond: Arrow 🏹 - Elegant JSON Parsing in Swift. :large_orange_diamond: Genome - A simple, type safe, failure driven mapping library for serializing JSON to models in Swift 2.0 (Supports Linux) :large_orange_diamond: Tyro - Functional JSON parsing and encoding :large_orange_diamond: Unbox - The easy to use Swift JSON decoder :large_orange_diamond: JSONJoy-Swift - Convert JSON to Swift objects. :large_orange_diamond: LazyObject - Lazily deserialize JSON into strongly typed Swift objects :large_orange_diamond: JSONExport - JSONExport is a desktop application for Mac OS X which enables you to export JSON objects as model classes with their associated constructors, utility methods, setters and getters in your favorite language. :large_orange_diamond: Elevate - Elevate is a JSON parsing framework that leverages Swift to make parsing simple, reliable and composable. :large_orange_diamond: AlamofireObjectMapper - An Alamofire extension which converts JSON response data into swift objects using ObjectMapper :large_orange_diamond: XML&amp;HTML@ AEXML - Simple and lightweight XML parser written in Swift. :large_orange_diamond: Ji - XML/HTML parser for Swift. :large_orange_diamond: Ono - A sensible way to deal with XML &amp; HTML for iOS &amp; OS X AlamofireXmlToObjects - Fetch a XML feed and parse it into objects :large_orange_diamond: Fuzi - A fast &amp; lightweight XML &amp; HTML parser in Swift with XPath &amp; CSS support :large_orange_diamond: Kanna - Kanna(鉋) is an XML/HTML parser for MacOSX/iOS. :large_orange_diamond: SwiftyXMLParer - Simple XML Parser implemented in Swift :large_orange_diamond: HTMLKit - An Objective-C framework for your everyday HTML needs. SWXMLHash - Simple XML parsing in Swift :large_orange_diamond: Other Parsing@ WKZombie - WKZombie is a Swift framework for iOS/OSX to navigate within websites and collect data without the need of User Interface or API, also known as Headless browser. It can be used to run automated tests or manipulate websites using Javascript. :large_orange_diamond: URLPreview - An NSURL extension for showing preview info of webpages :large_orange_diamond: [e] FeedKit - An RSS and Atom feed parser written in Swift :large_orange_diamond: Erik - Erik is an headless browser based on WebKit. An headless browser allow to run functional tests, to access and manipulate webpages using javascript. :large_orange_diamond:Erik - Erik is an headless browser based on WebKit. An headless browser allow to run functional tests, to access and manipulate webpages using javascript. :large_orange_diamond: 通讯录@ 快速查找联系人 - 类似微信联系人搜索的界面,快速查找联系人,并支持点击查询结果 。 PPGetAddressBook - 对联系人姓名第二个字做排序处理,对AddressBook框架(iOS9之前)和Contacts框架(iOS9之后)做了对应的封装处理,一句代码搞定联系人的获取与排序。 ####三方分享、支付、登录等等@ openshare - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。 RongCloud-SDK-description 介绍融云SDK即时通讯机制和集成步骤，由于国内CSDN博客封杀带有广告性质的文章（其实不是打广告，纯粹的技术分享），所以只能在Github发表了。希望大家支持我，谢谢。Demo地址：https://github.com/zhengwenming/RCIM RCIM 融云SDK集成即时通讯。单聊，群聊，讨论组，自定义cell,自定义消息等。文章配合代码一起看，效果更佳！文章地址：https://github.com/zhengwenming/RongCloud-SDK-description 其他库 DateTimeKit - 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。 iOS私有API - 这个仓库可以调取苹果的所有私有方法头文件，相当强大。私有API，绿色 == public，红色 == private，蓝色 == dylib。 iOS源代码 - iOS源代码。 libfacedetection - C++ 人脸识别 包含正面和多视角人脸检测两个算法.优点:速度快(OpenCV haar+adaboost的2-3倍), 准确度高 (FDDB非公开类评测排名第二），能估计人脸角度。 Slidden - 一个老外开源的开发自定义键盘的库，利用这个开源库，可以方便的配置键位、颜色以及键位对应的图片。 TPKeyboardAvoiding - 用户键盘弹出自动计算高度，进行屏幕滚动操作。 CDPMonitorKeyboard - CDPMonitorKeyboard封装,可以解决输入视图(例如textField,textView等)被键盘覆盖问题，并可设置高于键盘多少。 自动监听键盘高度 - 自动监听键盘高度，初始界面，输入框在屏幕最下方，当键盘出现时，输入框随即移动到键盘上方。 ZYKeyboardUtil - 全自动处理键盘遮挡事件，只需要一个Block，全自动处理任何多层嵌套复杂界面 因键盘升降 造成的输入控件遮挡问题。第三方键盘分次弹出问题 ,说明。 KeyboardToolBar - 从此不再担心键盘遮住输入框，文档。 IQKeyboardManager - 处理键盘事件强大的库，有OC和Swift版本，纯代码、Storyboard和Xib都适用。 BlocksKit - block框架，为 OC 常用类提供了强大的 Block 语法支持，使得编写 OC 代码变得舒适、快速、优雅。 appirater - 用于提醒用户给你的 APP 打分的工具。 MotionKitr - 为核心运动框架（The Core Motion framework）提供友好的类库封装，以更方便使用三轴陀螺仪和加速感应器特性。 Review Monitor - 第一时间自动推送 Apple Store 的用户评论到你的邮件箱或者 Slack，第一时间跟进用户反馈，打造优秀 App 必备工具！类似的有：App annie 的类似功能。 WBWebViewConsole - 类似微博iPhone客户端的 “调试选项” 吗？把其中的 “内置浏览器网页调试” 开源在 Github 上了。 ios-good-practices - ios-good-practices iOS 开发最佳实践。 iOS开发最佳实践 - iOS 开发最佳实践 – 中文。 TodayExtensionSharingDefaults - TodayExtensionSharingDefaults是一个iOS 8 Today扩展示例，可以使用NSUserDefaults与其containing app分享数据。 Password-keyboard - 随机变换数字位置的密码键盘。 模仿银行类应用在付款时输入的随机密码键盘。 SemverKit - 针对符合『语义化版本规范 2.0.0』版本号的解析、比较运算类库。不仅支持 Major, Minor, Patch，还支持 Alpha 和 Beta 预发布版本，以及相应地递增运算扩展。 Tesseract-OCR-iOS - 有关OCR文字识别项目。 Screenotate - 支持 OCR 文字识别的载屏笔记 Mac 完整应用。 Olla4iOS - 过去积累的一些方便复用的类和方法，还在整理中。 DKNightVersion - 用最快的方式给你的应用加上夜间和白天的切换效果。 TouchVisualizer - 实用的多点触摸可视化组件。扩展并作用于 UIWindows，结构上提供了简单地针对触摸显示定制，比如触摸点的颜色。 RegexKitLite - 用来处理正则表达式。 XcodeServerSDK - 非官方 Xcode Server SDK 封装库。 P.S. 该 SDK 分离自之前推荐的由该作者开发的自动测试框架 Buildasaur。 Seam - 基于 CloudKit 服务器实现多终端数据同步。 IDNFeedParser - 一个简单易用的Rss解析库。 CoreUmeng - 简单：友盟分享封装。 Mirror - 通过反射（Refection）实现镜像对象封装库。从而可以更轻松获取（或输出）对象属性名、类型及值变量。 Proposer - Proposer 用单个 API 处理 iOS 上的权限请求，以便使用前确认可访问“相册”、“相机”、“麦克风”、“通讯录”或“用户位置”。 PermissionScope - 用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—&gt;更多活跃用户-&gt;更高的留存率-&gt;数据更好-&gt;下载率更高。 LocationManager - 地理位置管理封装库， CoreLocation使用起来还是比较麻烦的，需要授权，判断系统版本等等，所以推荐使用第三方框架LocationManager，使用Block，十分简单！iOS-CoreLocation：无论你在哪里，我都要找到你！ 。 pangu.objective-c - 有多种语言实现版本～ Pangu.Objective-C：格式化中英文之间的空格（OC）。 objection - 一个轻量级的依赖注入框架Objection。 ControlOrientation - 如何用代码控制以不同屏幕方向打开新页面【iOS】， 使用说明。 iRate - 问卷调查。 GameCenterManager - 在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。 SlackTextViewController - 用作极佳、定制的文本输入控制时，自适应文本区域，手势识别、自动填充、多媒体合并，快速drop-in解决方案。 IAPHelper - 应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。 IAPDemo - 应用内支付IAP全部流程, 教程。 TAPromotee - 交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。 DownloadFontOnline - 实现了在线下载一些字体的功能，不用在工程中导入字体库，下载的字体也不会保存在你的应用中，所以可以放心使用。修复了一下崩溃的bug。 STClock - 仿锤子时钟。 GitUp - GitUp是一个可视化的Git客户端，能够实时的进行编辑、合并、回滚等多种操作，更多功能，请下载体验。 获取联系人信息，通讯录 - 获取联系人信息，通讯录。 Universal-Jump-ViewController - 根据规则跳转到指定的界面(runtime实用篇一)。 打开自带地图、百度地图、腾讯地图 - 打开自带地图、百度地图、腾讯地图。 batteryLevelTest - runtime精准获取电池电量，文档。 DateTools - 用于提高Objective-C中日期和时间相关操作的效率。灵感来源于 DateTime和Time Period Library。 DDSlackFeedback - 用这个接口实现的摇一摇上传文字或者截屏反馈到你的 Slack channel，特别适合测试 app 的时候用，集成也很简单。 BabyBluetooth - 是一个非常容易使用的蓝牙库, 适用于 iOS 和 Mac OS, 基于原生 CoreBluetooth 框架封装, 可以帮开发者们更简单地使用 CoreBluetooth API, 使用链式方法体, 使得代码更简洁、优雅。iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍 YYCategories - 功能丰富的 Category 类型工具库。 YYAsyncLayers - iOS 异步绘制与显示的工具。 YYDispatchQueuePool - iOS 全局并发队列管理工具。 YYKeyboardManager - iOS 键盘监听管理工具。 ShoppingCartExample - 购物车最多star demo。 shoppingCart1 - 仿美团购物车效果。 ZFShoppingCart - 仿照美团外卖加入购物车的动态效果。 shoppingCart2 - 一个购物车demo，包含购物车动画效果、购物车多选、删除、编辑等功能。 shoppingCart-demo - 一个简单的购物车功能实现demo。 iOS_oShoppingCart_Demo - 简单实现购物车常见的筛选功能。 XNQShoppingTrolley - 购物车功能 基本功能仿照淘宝的购物车。 ShoppingDemo - iOS仿美团外卖饿了吗App点餐动画,购物车。 shopCarDemobyCX - shopCarDemobyCX一个简易购物车效果，最重要的是可以分单结算，分单个商品结算，代理是主要技术。 MVVM KVO购物车 - MVVM KVO 购物车(一处计算总价钱)。 BHBDrawBoarderDemo车 - 仿写猿题库练题画板功能，没有用drawRect，而是用CAShapeLayer来做画板绘画，特别省内存，赞1个，实现分析。 jrswizzle - runtime实现的Method Swizzling第三方框架。 Demo_ProductDetailScroll - Demo_ProductDetailScroll ：仿京东商品详情滚动翻页。 BGTaobao - ios 高仿淘宝/京东详情页 - 集合各种测试框架。 CartDemo - CartDemo比较完整的购物车界面及逻辑,商品展示,多选,单选,全选及滑动删除,价格计算。 JLRoutes - JLRoutes好用的URL map库，它的作用是让按钮的点击像网页里的链接一样，只是触发了某个URL，而没有像pushViewController这样的行为，实现解耦。 PromiseKit - 同时支持 Swift 及 Objective-C 的 Promise 类库，异步编程类库 提供了很多实用的异步函数 让异步编程更简单。 ZipArchive - 适用iOS和OS X的解压库。 HWChangeFont - 利用runtime一键改变字体。教程。 RuntimeSummary - 一个集合了常用 Objective-C Runtime 使用方法的 Playground。 GCDThrottle - 限制频率过高的调用GCD多线程。 数据存储@ CoreModel Replace CoreData WHC_ModelSqliteKit 专业的数据库存储解决方案 缓存处理@ YTKKeyValueStore - Key-Value存储工具类，说明。 TMCache - TMCache 是 Tumblr 开源的一个基于 key/value 的数据缓存类库,可以用于缓存一些临时数据或者需要频繁加载的数据,比如某些下载的数据或者一些临时处理结果。 JLKeychain - 快捷使用keychain存储数据的类，使keychain像NSUserDefaults一样工作。 UICKeyChainStore - 封装keychain，使keychain像NSUserDefaults一样简单 sskeychain - SSKeyChains对苹果安全框架API进行了简单封装,支持对存储在钥匙串中密码、账户进行访问,包括读取、删除和设置。 KeychainAccess - 管理Keychain接入的小助手。 YYCache - 高性能的 iOS 缓存框架。 RuntimeDemo - runtime自动归档/解档,源码分析。 数据库@ FMDB - sqlite的工具， 多线程FMDatabaseQueue实例，FMDB数据库的使用演示和封装工具类，基于fmdb 的基本操作 通过 fmdb 进行的数据库的 基本操作(增删改查 )查找是使用 UISearchBar 和UISearchDisplayController 进行混合使用。 GXDatabaseUtils - 在FMDB基础上的工具。 GKDatabase -基于SQLite3简单封装了下,实现了一行代码解决增删改查等常用的功能!并没有太过高深的知识,主要用了runtime和KVC:请看Demo~ 原理篇请看这里:简书地址 CoreStore - Core Data 管理类库。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。 MagicalRecord - CoreData第一库，MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。 mogenerator - mogenerator为你定义了的Core Data生成默认的数据类。与xCode不一样的是(xCode一个Entity只生成一个NSManagedObject的子类)，mogenerator会为每一个Entity生成两个类。一个为机器准备，一个为人类准备。为机器准备的类一直去匹配data model。为人类准备的类就给你轻松愉快的去修改和保存。 Presentation - 重量级好项目 Presentation，它可以方便你制作定制的动画式教程、Release Notes、个性化演讲稿等。 SQLCipher - SQLCipher使用256-bit AES加密，SQLCipher分为收费版本和免费版本。官方教程， 加密你的SQLite - 各种sqlite数据库加密介绍。 SQLCipherDemo下载 。 序列化@ FastCoding 是用来替代OSX及iOS中默认的序列化实现。它结构简单（仅头文件和.m文件两个）、支持ARC，线程安全，速度较内置实现更快。下次做项目的时候可以试着用用。 PDF@ Reader - Reader可提供类似iBooks的文档导航，支持屏幕旋转和所有方向，并通过密码保护加密PDF文件，支持PDF链接和旋转页面。 图像浏览及处理@ RMPZoomTransitionAnimator一个放大缩小的动效开源库，可以实现图片的放大缩小效果。 FLAnimatedImage - gif播放处理的工具。 CLImageEditor - 超强的图片编辑库，快速帮你实现旋转，防缩，滤镜等等一系列麻烦的事情。 ios-image-filters - 图像滤镜，库比较旧了，很容易崩溃。 XBImageFilters - 图像滤镜。 MWPhotoBrowser - 一个非常不错的照片浏览器，在github的star接近3000个，解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题。 CoreImageShop - CoreImageShop图片滤镜处理– Mac app that let you create a complete Core Image Filter usable on iOS using SCRecorder。 GPUImage - 处理图片效果。 RSKImageCropper - 适用于iOS的图片裁剪器，类似Contacts app，可上下左右移动图片选取最合适的区域。 WZRecyclePhotoStackView - 删除照片交互–WZRecyclePhotoStackView，就是模拟生活中是删除或保留犹豫不决的情形而产生的。 在上滑，下滑的部分，借鉴了TinderSimpleSwipeCards。 PhotoTweaks - 这个库挺赞的，正好是对图像操作的。 KYElegantPhotoGallery - 一个优雅的图片浏览库。 SDPhotoBrowser - 仿新浪动感图片浏览器,非常简单易用的图片浏览器，模仿微博图片浏览器动感效果，综合了图片展示和存储等多项功能。 HZPhotoBrowser - 一个类似于新浪微博图片浏览器的框架（支持显示和隐藏动画；支持双击缩放，手势放大缩小；支持图片存储；支持网络加载gif图片，长图滚动浏览；支持横竖屏显示）。 MarkingMenu - 基于手势、类似 Autodesk Maya 风格标记菜单及图片渲染。 SXPhotoShow - UICollectionViewFlowLayout流水布局 是当下collectionView中常用且普通的布局方式。本代码也写了三种好看的布局，其中LineLayout和流水布局有很大的相同点就直接继承UICollectionViewFlowLayout，然后StackLayout，CircleLayout这两种都是直接继承自最原始的UICollectionViewLayout 布局方案。 PictureWatermark - 主要实现了给图片加文字以及图片水印的功能，已封装成了UIImage的类别，方便使用。 自定义宽高比的相册框 拍照 - 取出照片时 弹出自定义view。在这个自定义view上创建一个需要的相框大小的view层 把取出的图片赋值给UIImageView按缩放添加到这个层上。对uiimageView添加捏合、移动 手势。添加按钮 选取，最后根据位移和缩放比例 裁剪image。 LGPhotoBrowser - LGPhotoBrowser:相册选择/浏览器/照相机（仿微信）,包含三个模块：照片浏览器，相册选择器，照相机。 PhotoBrowser - 一个简单的好用的的图片浏览器。 PhotoBrowser 照片浏览器 BeautyHour - 完整应用，功能与“美图秀秀”雷同。 StitchingImage - 仿微信群组封面拼接控件, 直接拖进项目就可使用，教程。 SDECollectionViewAlbumTransition - 用自定义的 push 和 pop 实现了有趣的 iOS 相册翻开动画效果。 DNImagePicker - 类似wechat的图片选择。 CocoaPicker - 仿QQ图片选择器（OC）。 JFImagePickerController - vvebo作者：多选照片、预览已选照片、针对超大图片优化。 ELCImagePickerController 相册选照片的三方库，一千多star，不过2年未更新过了。 VIPhotoView - 图片浏览，用于展示图片的工具类，因为是个 View，所以你可以放在任何地方显示。支持旋转，双击指定位置放大等。 AGImagePickerController - 是一个图片选择器，支持图片多选，支持大图横滑预览，支持放大预览，支持横竖屏，支持所有的iOS设备。 YYImage - 功能强大的 iOS 图像框架，支持大部分动画图像、静态图像的播放/编码/解码。 TZImagePickerController - 一个支持多选、选原图和视频的图片选择器，同时有预览功能，适配了iOS6789系统。教程. 更换头像 - 用户选取从相机或者相册获取图片，并且显示在View上。 ZZPhotoKit - 基于Photos和AVFoundation框架开源，相册多选与相机连拍。 BeautifyFaceDemo - 一个基于 GPUImage 的实时直播磨皮滤镜的开源实现,主要功能脸部去斑磨皮！ YUCIHighPassSkinSmoothing - 磨皮滤镜！ YUGPUImageHighPassSkinSmoothing - 一个基于 GPUImage 的磨皮滤镜！ YLFaceuDemo - 在直播应用中添加Faceu贴纸效果。Faceu贴纸效果其实就是在人脸上贴一些图片，同时这些图片是跟随着人脸的位置改变的。说明 [XHImageViewer] (https://github.com/JackTeam/XHImageViewer) XHImageViewer is images viewer, zoom image. 图像圆角 ZYCornerRadius 赞 一句代码，圆角风雨无阻。A Category to make cornerRadius for UIImageView have no Offscreen-Rendered, be more efficiency. http://zyden.vicp.cc/zycornerradius/ 摄像照相视频音频处理@ LLSimpleCamera - A simple, customizable camera control for iOS， 摄像头。 EZAudio - EZAudio 是一个 iOS 和 OSX 上简单易用的音频框架，根据音量实时显示波形图，基于Core Audio，适合实时低延迟音频处理，非常直观。中文介绍,官网。 ffmpeg - ffmpeg官网，FFmpeg在iOS上完美编译。 VLC - VCL官网,VLC for iOS 2.7.2 source code。 kxmovie - 使用ffmpeg的影片播放器，修改说明， 修改代码，基于FFmpeg的kxMoive艰难的编译运行。 ijkplayer - B站开源的视频播放器，支持Android和iOS。 iOS中集成ijkplayer视频直播框架。 StreamingKit - StreamingKit流媒体音乐播放器。 FreeStreamer - FreeStreamer流媒体音乐播放器，cpu占用非常小。 DOUAudioStreamer - DOUAudioStreamer豆瓣的音乐流媒体播放器。 fmpro - 电台播放器，支持锁屏歌词，支持基本播放流程，歌词展示，后台锁屏播放和控制以及锁屏后封面+歌词，fmpro_R 。 IPDFCameraViewController - 支持相机定焦拍摄、滤镜、闪光、实时边框检测以及透视矫正功能，并有简单易用的API。 SCRecorder - 酷似 Instagram/Vine 的音频/视频摄像记录器，以 Objective-C 为基础的过滤器框架。 你可以做很多如下的操作：记录多个视频录像片段。删除任何你不想要的记录段。可以使用任何视频播放器播放片段。保存的记录可以在序列化的 NSDictionary 中使用。（在 NSUserDefaults 的中操作）添加使用 Core Image 的视频滤波器。可自由选择你需要的 parameters 合并和导出视频。 Cool-iOS-Camera - Cool-iOS-Camera。 FastttCamera - FastttCamera 快速照相。 ICGVideoTrimmer - ICGVideoTrimmer提供提供视频剪切的视图（类似系统相册中浏览视频时顶部那个条状视图）。左右两个边界选择器还能够自定义。 IOS录音和播放功能demo - 比较完整的ios录音和播放功能的实现。 MCAudioInputQueue - 简易录音类，基于AudioQueue的。 DraggableYoutubeFloatingVideo - 展示像类似Youtube移动应用的那种浏览视频的效果，当点击某视频时能够从右下方弹出一个界面，并且该界面能够通过手势，再次收缩在右下方并继续播放。这是通过AutoLayout设计实现。 amr - 做即时通讯的音频处理，录音文件是m4a，便于web端的音频播放。 边录音边转码 - 一边录音，一边将录制成的 wav 格式音频文件转码成 amr 音频格式。只支持真机运行调试。 FSVoiceBubble - 一个轻量级播放录音音频的气泡：1.支持短时间的音频播放（支持网络音频）；2.播放时的声波动画；3.自定义包括声波的颜色，气泡的背景等。 KRVideoPlayer - 类似Weico的播放器，支持竖屏模式下全屏播放。 自定义视频播放器AVPlayer - 利用系统类AVPlayer实现完全自定义视频播放器，显示播放时间，缓存等功能。代码清晰，注释详细。 VideoBeautify - 功能酷似美拍,秒拍等应用的源码：对视频进行各种美化处理，采用主题形式进行分类，内含各种滤镜，动画特效和音效等。 HTY360Player - 是一款提供在 iOS 中使用 360 度无死角拖拽视频进行不同角度播放的视频播放器。 ALCameraViewController - ALCameraViewController 摄像头视图控制器（含可定制照片选择器，图片简单裁切功能）及演示。 Eleven - Eleven Player - 一个使用 FFmpeg 实现的简单强大的 iOS 开源播放器。 iFrameExtractor - 开源视频播放器， ffmpeg在iOS的使用-iFrameExtractor源码解析，文章。 MusicPlayert - MusicPlayert本地音乐播放+音乐信息显示+在线歌词搜索显示（千千静听服务器）。 MusicPlayert - MusicPlayert音乐播放器，用reveal可以查看层次关系，主要实现了歌词的同步显示。 音乐播放器 - 音乐播放器：显示歌词。 TBPlayer - 视频变下变播，把播放器播放过的数据流缓存到本地，支持拖动。采用avplayer。实现说明 IWatch - 一个视频日报类的app 播放器用到了AVFoudation。 ZFPlayer - 基于AVPlayer，支持横屏、竖屏（全屏播放还可锁定屏幕方向），上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。 [MiaowShow] (https://github.com/SunLiner/MiaowShow) iOS视频直播项目 [KrVideoPlayerPlus] (https://github.com/PlutusCat/KrVideoPlayerPlus) 根据36Kr开源的KRVideoPlayer 进行修改和补充实现一个轻量级的视频播放器，满足大部分视频播放需求 TBPlayer 视频变下变播，把播放器播放过的数据流缓存到本地，支持拖动。采用avplayer 520Linkee 本项目实现了作为一个直播App的基本功能，比如本地视频流采集、播放、美颜、礼物、点赞出心等。 视频@ ZFPlayer - 基于AVPlayer，支持横屏、竖屏（全屏播放还可锁定屏幕方向），上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。 MRVLCPlayer - 相信Mac用户都很熟悉一款VLC播放器，这款播放器在Mac上表现异常优异，支持的格式几乎涵盖了所有格式（就是这么屌！）。没错，就是它创造者–VideoLAN，开源了一款牛逼的视频播放框架MobileVLCKit！[介绍信息：] (http://gold.xitu.io/entry/578c304b2e958a0054320503?from=singlemessage&amp;isappinstalled=1) plask Plask is a multimedia programming environment. WMPlayer 赞 WMPlayer视频播放器，AVPlayer的封装，继承UIView，想怎么玩就怎么玩。支持播放mp4、m3u8、3gp、mov，网络和本地视频同时支持。全屏和小屏播放同时支持。 cell中播放视频，全屏小屏切换自如。 HJDanmakuDemo iOS端视频弹幕 SCRecorder - SCRecorder 短视频录制。 VideoPushDemo - 视频剪辑 视频特效制作1 视频特效制作2。 响应式框架@ ReactiveCocoa - ReactiveCocoa 受函数响应式编程激发。不同于使用可变的变量替换和就地修改，RAC提供Signals来捕获当前值和将来值（ 使用介绍 ），不错的例子,入门好教程：ReactiveCocoa入门教程：第一部分 。Reactive Cocoa 3.0 在 MVVM 中的应用 ,小码哥：快速让你上手ReactiveCocoa之基础篇。 LoginWithReactiveCocoa - ReactiveCocoa - 登录交互效果的实现。 BeeFramework - 与ReactiveCocoa类似，BeeFramework用户指南 v1.0。 Objective-Chain - Objective-Chain是一个面向对象的响应式框架，作者表示该框架吸收了 ReactiveCocoa 的思想，并且想做得更面向对象一些。 MVVMFramework - (OC版)总结整理下一个快速开发框架，分离控制器中创建tableView和collectionView的代码，已加入cell自适应高度，降低代码耦合，提高开发效率。 消息相关@消息推送客户端@ Orbiter - 消息推送客户端:Push Notification Registration for iOS. PushDemo - 客户端消息接收消息代码，IOS开发之 —- IOS8推送消息注册 ， 分分钟搞定IOS远程消息推送。 消息推送服务端@ javapns源代码 - 消息推送的java服务端代码，注意：DeviceToken中间不能有空格。 pushMeBaby - Mac端消息推送端代码，注意：DeviceToken中间要有空格。 通知相关@ JSQNotificationObserverKit - 一款轻量、易用的通知发送及响应框架类库。作者是知名开源项目 JSQMessagesViewController（Objective-C 版即时聊天）的作者 Jesse Squires. GLPubSub - 一个简短实用的 NSNotificationCenter 的封装。 JDStatusBarNotification - 在状态栏顶部显示通知。可以自定义颜色字体以及动画。支持进度显示以及显示状态指示器。 时间日期@ iso-8601-date-formattercocoaNSFormatter子类日期转换为从ISO- 8601格式的字符串。支持日历，星期，和序格式。 设计模式@ [KVOController] (https://github.com/facebook/KVOController) 是一个简单安全的KVO（Key-value Observing，键-值观察）工具，用于iOS 和OS X 应用开发中，开源自facebook。 在项目中有使用 KVO ，那么 KVOController 绝对是个好选择。 版本新API的Demo@ appleSample - iOS 苹果官方Demo合集， 官方demo. iOS7-Sampler - 整合了iOS7.0的一些十分有用的特性，比如：Dynamic Behaviors、碰撞检测、语音合成、视图切换、图像滤镜、三维地图、Sprite Kit（动画精灵）、Motion Effect（Parallax）、附近蓝牙或者wifi搜索连接、AirDrop、运动物体追踪（iPhone 5S以上，需要M7处理器）等等。对于日常的应用开发十分实用。 iOS8-Sampler - 日本的shuさん制作的 iOS8 参考代码集。01.Audio Effects ；02.New Image Filters；03.Custom Filters；04.Metal Basic；05.Metal Uniform Streaming；06.SceneKit；07.HealthKit；08.TouchID；09.Visual Effects；10.WebKit；11.UIAlertController；12.User Notification；13.Pedometer；14.AVKit；15.Histogram；16.Code Generator；17.New Fonts；18.Popover；19.Accordion Fold Transition iOS-9-Sampler - 通过实例介绍了iOS 9 SDK中重要新特性的使用。 iOS 9 分屏多任务 - iOS 9 分屏多任务：Slide Over &amp; Split View快速入门（中文版）。 Search-APIs - iOS 9 学习系列: SearchAPIs。教程 代码安全与密码@ ios-class-guard - 一个用于混淆iOS的类名、方法名以及变量名的开源库–有人反映编译出来的app运行不了。 《Protecting iOS Applications》：文章系统地介绍了如何保护iOS程序的代码安全，防止反汇编分析。 fishhook - fishhook是Facebook开源的一个可以hook系统方法的工具。 GesturePassword - 一个iOS手势密码功能实现，iPad/iPhone 都可以用，没有使用图片，里面可以通过view自己添加。keychain做的数据持久化，利用苹果官方KeychainItemWrapper类。操作部分都在controller了。删除直接用一下clear。 JMPasswordView - 简单实用的手势密码，效果可自行调控。 仿密码锁-九宫格 - 仿密码锁-九宫格，主要是使用UIButton 手势事件 UIBezierPath画图，解锁失败弹出“密码错误”。 CoreLock - 本框架是高仿支付宝，并集成了所有功能，并非一个简单的解锁界面展示。个人制作用时1周多，打造解锁终结者框架。 LikeAlipayLockCodeView - 高仿支付宝手势解锁（超级版）。 Smile-Lock.swfit - 一个类似于iOS的解锁界面。 PCGestureUnlock - 目前最全面最高仿支付宝的手势解锁，而且提供方法进行参数修改，能解决项目开发中所有手势解锁的开发。 ICPayPassWordDemo - CPayPassWordDemo，一个模仿支付宝支付密码输入对话框小demo。 RSAESCryptor - 加密 RSA+AES Encryption/Decryption library for iOS. This library uses 2048-bit RSA and 256-bit key with 128-bit block size AES for encryption/decryption。 TouchID - 用法简单的TouchID验证框架：两行代码搞定。 [SFHFKeychainUtils] (https://github.com/ldandersen/scifihifi-iphone)iOS中使用SFHFKeychainUtils保存用户密码，比如项目中需要保存用户密码，以实现自动登录的功能可以使用。 测试及调试@ chisel Chisel扩展了一些列的lldb的命令来帮助iOS开发者调试iOS应用程序。 dSYMTools友盟 dSYM analyze HeapInspector - HeapInspector是一个用于检测应用中的内存泄漏的开源调试工具。 Crashlytics - Crashlytics 崩溃报告 崩溃日志 使用说明 。 UIViewController-Swizzled - 把你进入的每一个controller的类名打出来,如果看一些特别复杂的项目的时候直接运行demo就可以知道执行次序了。 snoop-it - snoop-it比UIViewController-Swizzled好用，代码托管在google上。 Versions - 版本比较小工具。 MobileWebPageTest - MobileWebPageTest是用来测试移动网页性能的软件，它可以对页面的加载和渲染过程进行截屏，协助开发者分析出页面性能瓶颈。 KKLog - 一个日志管理系统。 Buildasaur - 自动测试框架 Buildasaur。 使用Quick框架和Nimble来测试ViewControler - Quick是一个用于创建BDD测试的框架。配合Nimbl，可以为你创建更符合预期目标的测试。 fastlane - 一套iOS开发和持续集成的命令行工具fastlane，可以用来快速搭建CI甚至自动提交的开发环境。这套工具中包括了上传ipa文件，自动截取多语言截屏，生成推送证书，管理产品证书等一系列实用工具。 KIF - 是一个开源的用户界面UI测试框架. 使用 KIF, 并利用 iOS中的辅助功能 API, 你将能够编写模拟用户输入，诸如点击，触摸和文本输入，自动化的UI测试. Quick - 用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。 KSCrash - iOS Crash 捕获上报工具， 可以自己配置服务器， 也可以与它推荐的服务器搭配使用 AppleWatch Tesla汽车AppleWatch app demo演示 - 通过AppleWatch控制特斯拉汽车，同时可以看到汽车的相关信息，比如剩余电量、可续行里程等，以及解锁/上锁车门、调节司机和乘客的四区域空调温度、开启车辆大灯、定位汽车等。源码推荐说明。 WatchKit-Apps - WatchKit 开源小项目示例集锦。是不可多得地学习 WatchKit 的示例式教程（1.如何创建一个简单的交互式计数器；2.如何从手表上控制iOS app；3.如何在WatchKit app和iOS app之间共享数据；4.如何创建一个拥有不同背景色的数字时钟；5.展示不同的UI层；6.如何创建支持滑动手势的应用程序。）。 kiwi-bdd - TDD或BDD，objective-c语言的测试框架，最流行的BDD测试框架了，Kiwi最受欢迎（根据github上的star数来推断，行为描述和期望写起来也比较易懂，至少我是这么认为的） iOS开发中的测试框架。 specta - TDD或BDD，objective-c语言的测试框架，用的人多。 cedar - TDD或BDD，objective-c语言的测试框架，用的人少。 ViewMonitor - 能够帮助 iOS 开发者们精确的测量视图, 可直接在调试应用中查看具体某个视图的坐标, 宽高等参数。 MMPlaceHolder - 一行代码显示UIView的位置及相关参数。 KMCGeigerCounter - KMCGeigerCounter通过复杂和简单的视图演示了类似盖革计数器的帧速计算功能。掉帧通常是可见的，但是很难区分55fps和60fps之间的不同，而KMCGeigerCounter可以让你观测到掉落5帧的情况。 MSLeakHunter - 自动检测 UIViewController 和 UIView 对象的内存泄露。MLeaksFinder 的使用参照 CocoaLumberjack - 是一个快速、简单，但很强大的日志框架。 CocoaLumberjack - 是一个快速、简单，但很强大的日志框架。 ipapy - iOS项目自动打包脚本，并且上传到fir.im，然后发送邮件给测试人员。 fbretaincycledetector - Facebook出品,通过Runtime监测循环引用。 FBMemoryProfiler - Facebook出品,内存检测库。FBMemoryProfiler 基础教程。 FBAllocationTracker - Facebook出品,跟踪oc对象的分配情况。 xctool - Facebook出的自动化打包工具，它规范了输出的log日志，而且一些错误信息也更为清晰一些。 JxbDebugTool 一个iOS调试工具，监控所有HTTP请求，自动捕获Crash分析。 KSCrash - iOS Crash 捕获上报工具， 可以自己配置服务器， 也可以与它推荐的服务器搭配使用 动态更新@ waxPatch - 大众点评的屠毅敏同学在基于wax的基础上写了waxPatch，这个工具的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。 JSPatch - JSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。官网。(JSPatchX)[https://github.com/bang590/JSPatchX] JSPatch的XCode 代码补全插件。 CTJSBridge - JCTJSBridge：a javascript bridge for iOS app to interact with h5 web view。 AppleWatch@ Tesla汽车AppleWatch app demo演示 - 通过AppleWatch控制特斯拉汽车，同时可以看到汽车的相关信息，比如剩余电量、可续行里程等，以及解锁/上锁车门、调节司机和乘客的四区域空调温度、开启车辆大灯、定位汽车等。源码推荐说明。 WatchKit-Apps - WatchKit 开源小项目示例集锦。是不可多得地学习 WatchKit 的示例式教程（1.如何创建一个简单的交互式计数器；2.如何从手表上控制iOS app；3.如何在WatchKit app和iOS app之间共享数据；4.如何创建一个拥有不同背景色的数字时钟；5.展示不同的UI层；6.如何创建支持滑动手势的应用程序。）。 KYVoiceCurve - 类似Apple Watch中语音的声音曲线动画。 IGInterfaceDataTable - IGInterfaceDataTable是WKInterfaceTable对象的一个类别，可以让开发者更简单地配置多维数据。该项目使用类似UITableViewDataSource的数据源模式配置Apple Watch表格，而不是将数据结构扁平化成为数组。 watchOS-2-Sampler - 基于 watchOS 2 若干新特性，写了相应的示例代码供大家学习、参考。 HMWatch - HMWatch是个有待完善的watchOS 2.0 HomeKit 应用示例。 CocoaMultipeer - CocoaMultipeer这个开源框架支持OS X, iOS和watchOS设备间的点对点通信，解决watchOS和Mac之间通信的方案还是很有用的。 HighstreetWatchApp - 是电商平台Highstreet针对App Watch的一款应用，该demo中加载的是虚拟数据。 NKWatchChart - NKWatchChart是一个基于PNChart专门为Apple Watch 开发的图表库,目前支持 line, bar, pie, circle 和 radar 等 图表形式。 BeijingAirWatch - 国人的开源项目代码 ！WatchOS 2.0 Complication of Real-time Air Quality for Major Chinese Cities 苹果表盘实时刷新北上广沈蓉空气质量。 VPN完整项目@ Hydro.network - Hydro.network 的开发旅程, gitcafe。 Potatso 基于iOS 9 的 NetworkExtension 框架实现 Shadowsocks 代理，由国人开发，虽然还有很多问题不过确实值得期待。 好的文章@ 自定义转场动画 - 3 种方法～ 关于自定义转场动画。 iOS提高效率的方法和工具 - iOS提高效率的方法和工具。 用 JSON 构建 API 的标准指南 - 用 JSON 构建 API 的标准指南。 iOS创建半透明ViewController - iOS创建半透明ViewController。 iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍 - iOS蓝牙开发（一）蓝牙相关基础知识,iOS蓝牙开发（二）：iOS连接外设的代码实现,iOS蓝牙开发（三）：App作为外设被连接的实现。 统计项目中图片使用情况 - 统计项目中图片使用情况;工具：Unused:找出项目中未使用的图片, Unused 的基础上改了一下的LSUnusedResources;工具：ImageOptim 图片保真压缩。【iOS图片压缩工具】效率最高的是tiny-png:在线压缩，前500张免费。 iOS推送之远程推送 、iOS推送之本地推送。 动态部署方案 - iOS应用架构谈动态部署方案。 awesome-github - awesome-github:收集这个列表，只是为了更好地使用亲爱的GitHub。 ReactiveCocoa 4 文档翻译目录 - ReactiveCocoa 4 文档翻译目录。 每个Xcode开发者应该知道的七个使用技巧 - 每个Xcode开发者应该知道的七个使用技巧。 腾讯力作！超实用的iOS 9人机界面指南 - 腾讯力作！超实用的iOS 9人机界面指南。 iOS开发-超链接富文本案 - iOS开发-超链接富文本。 UIView+RedPoint实现底部UITabBarItem和控件的右上角显示和隐藏红点/数字的需求 - 使用GCD实现和封装分组并发网络请求 - 使用GCD实现和封装分组并发网络请求。 微信语音连播的实现思路 - 微信语音连播的实现思路。 UITableView 手势延迟导致subview无法完成两次绘制 - UITableView 手势延迟导致subview无法完成两次绘制。 Xcode插件@ 首先学习使用Xcode - 学习使用Xcode构建出色的应用程序！在Xcode启动的时候，Xcode将会寻找位于~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中的后缀名为.xcplugin的bundle作为插件进行加载（运行其中的可执行文件）。 RPAXU 每当 Xcode 升级之后，都会导致原有的 Xcode 插件不能使用，这是因为每个插件的 Info.plist 中记录了该插件兼容的 Xcode 版本的DVTPlugInCompatibilityUUID，而每个版本的 Xcode 的 DVTPlugInCompatibilityUUID 都是不同的。如果想让原来的插件继续工作，我们就得将新版 Xcode 的 DVTPlugInCompatibilityUUID 加入到每一个插件的 Info 文件中，手动添加的话比较费时间还可能出错，所以作者写了一个脚本来做这件事。 FLEX 非常赞的一个Xcode工具，FLEX是一个需要注入式的一种框架，从描述来看，功能非常多。主要来讲的话能够对正在运行的应用进行样式的修改和控件的读取。FLEX会赐予你SuperPower！！！ 可以查看控件的坐标和属性 看任何一个对象的属性和成员变量 动态修改属性和成员变量 动态的调用实例和类方法FLEX正因为是注入式的，所以不需要在链接LLDB或者Xocde，或者是远程的调试服务器，它可以在本地随时随地的进行自有的操作和调试 Alcatraz -使用Alcatraz来管理Xcode插件 Polychromatic 为不同的变量类型赋予不同的颜色 ClangFormat-Xcode clang-format 代码格式化 BBUncrustifyPlugin-Xcode 代码格式化 HOStringSense-for-Xcode有图，点进去一看就明白了，代码编辑器里的字符串编辑器，粘贴大段 HTML 字符串之类的很方便，自动转义。 ZLGotoSandboxPlugin - 支持Xcode快捷键了跳转当前应用沙盒了！快捷键是 Shift+Common+w。 cocoapods-xcode-plugin - 该CocoaPods的插件增加了一个CocoaPods菜单到Xcode的产品菜单。如果你不喜欢命令行，那么你一定会喜欢这个插件。 CarthageCarthage是一个新的第三方库管理工具，它轻耦合，使用很灵活，不会修改项目文件，使用xcodebuild工具来编译第三方库。跟cocoaPod有些类似。 KSImageNamed - 自动完成，特别是如果你正在写Objective-C，如果Xcode能自动完成文件名难道不会很伟大吗？比如图像文件的名称。 KFCocoaPodsPlugin Xcode插件 cocoapod, 方便编辑Podfile，显示构建日志 XCActionBar 是一个用于 Xcoded 的通用生产工具。 XcodeBoost XcodeBoost 是一款可以让开发者轻而易举地检查和修改 Objective-C 代码的插件。XcodeBoost 能够自动进行一些繁琐的操作，比如方法的定义与声明、添加基于命令行的代码处理（剪切/复制/粘贴/重复/删除行）、持续高亮等。 SCXcodeSwitchExpander在写switch时，自动补全所有选项 (只支持NS_ENUM) ColorSense-for-XcodeColorSense是一款Xcode颜色插件，可让UIColor和NSColor更加可视化。虽然已经有很多工具允许你从取色板插入UIColor/NSColor或者从屏幕上取色，但这些工具并不会记忆你此前你的常用选择。不过ColorSense可以解决这个问题，把插入符放在代码上即可展示实际颜色，并可以使用标准的Mac OS X颜色选择器进行调整。此外，该插件还在编辑菜单上添加了可插入颜色或者暂时禁用颜色高亮的项目，这些菜单项目没有默认的快捷键，但是你可以通过系统的键盘设置偏好进行设置。 tween-o-matic 编辑CAMediaTimingFunction动画曲线 [iOS-Universal-Framework] (https://github.com/kstenerud/iOS-Universal-Framework) 编译iOS的Framework的通用模板 支持armv7s iOS-Framework 编译iOS的Framework的通用模板Xcode-Plugin-Template 解析和操作Xcode工程文件 fui Fui 可以用来查找 Xcode 项目中无用的 import 并予以删除 SCStringsUtility 让你在一个清爽的界面编辑不同的语言，简单地输入/输出NSLocalizedString数据。 Lin 一个开源的Mac基础工具，可以让你在一个清爽的界面编辑不同的语言，简单地输入/输出NSLocalizedString数据。提供了一个非常不错的操作界面，并且为不同的语言提供了不同的区域。 Transformifier Transformifier是一款通用的交互式的3D转换调整工具，用于iOS开发。开发者可以通过它以可视化的方式变换各维度上的值，还可以把使用CATransform3D输出的代码导入自己的app中。 UIEffectDesignerViewiOS和OSX原生粒子系统效果图搭载QuartzCore Xcode5 Plugins 开发简介 写个自己的Xcode4插件 Xcode 4 插件制作入门 - Xcode 4 插件制作入门:Xcode所使用的所有库都包含在Xcode.app/Contents/的Frameworks，SharedFrameworks和OtherFrameworks三个文件夹下。其中和Xcode关系最为直接以及最为重要的是Frameworks中的IDEKit和IDEFoundation，以及SharedFrameworks中的DVTKit和DVTFoundation四个。 RTImageAssets - 一个 Xcode 插件，用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本。Asset Catalog Creator 功能强大，能自动生成全部尺寸：包括App Icons、Image Sets、Launch Screens Generator。 VVDocumenter-Xcode - 一个Xcode插件，build后，随手打开一个你之前的项目，然后在任意一个方法上面连按三下”/“键盘，就ok了。 java2Objective-c - Google公司出得java转Obje-C转换工具，转换逻辑，不转换UI。 RegX - 专治代码强迫症的 Xcode 插件，使用 Swift 和 Objective-C 编写。其用竖向对齐特定源代码的元素，使得代码更易读和易理解。说明 ； 菜单：xcode——》Edit-》Regx 。 CodePilot Code Pilot是一款在项目中快速方便地查找文件、方法和符号，Xcode 5的扩充开源插件，开发者无需鼠标进行操作。 XVim 支持绑定VIM快捷键 CATweaker CATweaker – 一个用于创建漂亮的CAMediaTimingFunction 曲线的插件. XcodeWay – 便捷地导航到多个地方 FuzzyAutocomplete - Xcode的实现自动完成还不完美，此插件能给出你所期望或想要的建议，设置：xcode-》Editor-》FuzzyAutocomplete-》plugin settings。 GitDiff - Xcode的代码编辑器的一个微妙的补强，加上了足够的可见信息以了解上次git提交以来发生了什么变化，设置：xcode-》Edit-》GitDiff。 XToDo - 这个插件不仅凸显TODO，FIXME，???，以及！！！注释，也在便利列表呈现他们。 菜单：xcode-》view-》snippets; 调出列表显示: xcode-》view-》ToDo List ： ctrl + T 。 Backlight - 突出显示当前正在编辑的行。菜单：xcode-》view-》Backlight 。 Peckham - 添加import语句比较麻烦，此插件 按Command-Control-P，给出的选项列表中选择要的头文件。先要安装 Auto-Importer - Auto-Importer是一个自动导入类对应的头文件的Xcode插件。 KSHObjcUML -KSHObjcUML 是一个 Objective-C 类引用关系图的 Xcode 插件。 Dash-Plugin-for-Xcode。 ESJsonFormat-Xcode - 将Json格式化输出为模型的属性。 SCXcodeMiniMap - Xcode迷你小地图-SCXcodeMiniMap。 xTransCodelation - XCODE中英文翻译插件，提供API查询模式和网页模式，都是利用的百度翻译。另外集成了一个可以一键关闭其他所有APP的实用功能，方便开发者！目前只有30多颗星。 jazzy 通过代码注释生成doc文档,支持ObjC/Swift,分析准确 CoPilot - 通过此插件， Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。 SuggestedColors - Xcode 插件SuggestedColors，用于 IB颜色设置 辅助插件，非常好用。 Crayons - Xcode调色板增强插件。 injectionforxcode - Injection for Xcode：成吨的提高开发效率,使用说明。 IconMaker - 只需要一步，自动生成不同尺寸的App icon。超级方便。 BuildTimeAnalyzer-for-Xcode - 实用的编译时间分析 Xcode 插件。 FastStub-Xcode - 一只快速生成代码的Xcode插件，说明。 ESTranslate-Xcode - 一个快速翻译Xcode代码里面单词(我主要用于翻译句子～)的插件，快捷键：Ctrl+Shift+T。 好用的软件@ gitbook GitBook 是一个基于Node.js 的命令行工具，可使用Github/Git 和Markdown 来制作精美的电子书。 GitBook需要使用markdown格式编写，如果你不了解可以看看这里。 crashlytics Twitter出的一个崩溃分析软件 Knuff调试iOS App远程推送(APNs)的工具 Cagegory@ JKCategories 非常棒的分类 NullSafe NullSafe is a simple category on NSNull that returns nil for any unrecognised messages instead of throwing an exception pod ‘NullSafe’, ‘~&gt; 1.2.2’ 用于防止项目中数组为空时越界访问崩溃。 iOS-Categories - 收集了许多有助于开发的iOS扩展,各种category分类。 cocoacats - 【分类汇总】里面收集了 iOS 中常用的分类文件，一直在更新。 [libextobjc](https://github.com/jspahrsummers/libextobjc Libextobjc是一个非常强大的Objective-C库的扩展,为Objective-C提供诸如Safe categories、Concrete protocols、简单和安全的key paths以及简单使用block中的弱变量等功能。libextobjc非常模块化，只需要一个或者两个依赖就能使用大部分类和模块。 SFJumpToLine Xcode plugin that moves the instruction pointer to the selected line 美工资源@ TWG_Retina_Icons - 一套支持 Retina 高清屏的 iPhone 免费图标集。 ASCIImage - 使用 NSString 创建 image，说明。 my-sketch-colors - 配色。 Font Awesome - Font Awesome：一套绝佳的图标字体库和CSS框架，详细的安装方法请参考官方网站中文网站,GitHub地址 。 DynamicColor - 强大的颜色操作扩展类。通过该类，你可以通过扩展方法基于某个颜色得到不同深浅、饱和度、灰度、色相，以及反转后的新颜色。是不可多得的好类库。 Chameleon - Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。 FontBlaster - 载入定制字体时更简单。 其他资源@ githuber - 最好用的GitHub人才搜索工具。 codatlas - 源代码搜索利器。 searchcode - 源代码搜索利器：来自悉尼的代码搜索引擎汇聚了 Github, Bitbucket, Sourceforge…等多家开源站点超20万个项目、180亿行源代码，能以特殊字符、语言、仓库和源方式从90多种语言找到函数、API的真实代码。 kitematic - Mac 上使用 Docker 最简单的方案。 二维码 ZXingObjC 赞 An Objective-C Port of ZXing LBXScan 赞 A barcode and qr code scanner (二维码、扫码、扫一扫、ZXing和ios系统自带扫码封装，扫码界面效果封装)(Objective-C和Swift均支持). 原生实现扫描二维码条码 - iOS原生实现扫描二维码条码. ZFScan - 仿微信 二维码/条形码 扫描。 QRCatcher - 一个简洁美观的二维码扫描应用， [iOS学习：AVFoundation 视频流处理–二维码 BarcodeScanner](https://github.com/hyperoslo/BarcodeScanner) 带状态控制的条码扫描库，支持处理相机权限、自定义颜色和提示信息，不依赖其他第三方库。扫描。 MQRCodeReaderViewController - 二维码扫描控件, UI 做了优化, 仿造微信, 直接拖进项目就可使用。 MQRCodeReaderViewController iOS 二维码扫描控件, UI 做了优化, 仿造微信, 直接拖进项目就可使用, 支持 CocoaPods 安装. WeChat-like QRCode reader, drop-in version, support for CocoaPods 开发资料@播客@ The Ray Wenderlich Podcast Debug iDeveloper App Story Mobile Couch iOS Bytes iPhreaks Under the Radar 学习资料@ growth-ebook Growth Engineering: The Definitive Guide。全栈增长工程师指南 ideabook一个全栈增长工程师的练手项目集. A Growth Engineering Idea in Action. objc-zen-book-cn 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译） Show 成都地区一个公司开源项目目录 A-awesome-awesomeness GitHub上所有Awesome Awesomeness 系列集合. 这个系列集合收集上GitHub上优秀的开源项目、框架、书籍、网站、类库等实用资源的集合。 豆瓣iOS开源库列表 - 豆瓣iOS开源库列表，很多开源项目。 iOS-Core-Animation-Advanced-Techniques - 中文版iOS 高级动画技术。 iOS9AdaptationTips iOS9适配系列教程 iOS开发的一些奇巧淫技1 - TableView不显示没内容的Cell怎么办; 键盘事件：IQKeyboardManager; app不流畅:KMCGeigerCounter; CoreData用起来好烦:MagicalRecord; CollectionView实现悬停的header:CSStickyHeaderFlowLayout。 iOS开发的一些奇巧淫技2 - 用一个pan手势来代替UISwipegesture的各个方向、拉伸图片、播放GIF、上拉刷新、把tableview里cell的小对勾的颜色改变、navigationbar弄成透明的而不是带模糊的效果、改变uitextfield placeholder的颜色和位置。 cocoapods安装指南 - cocoapods安装指南。 RemoteControl - Control your iPhone from inside Xcode for end-to-end testing 。 MVVM 介绍 - 替换MVC的开发模式。 第三方接口 - 基本所有第三方接口都在这，再也不用那么麻烦去找了。 提高iOS开发效率的方法和工具 - 提高iOS开发效率的方法和工具。 禅与 Objective-C 编程艺术 - 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）。 Objective-C编码规范：26个方面解决iOS开发问题 - 【Objective-C编码规范：26个方面解决iOS开发问题：“我们制定Objective-C编码规范的原因是我们能够在我们的书，教程和初学者工具包的代码保持优雅和一致。”今天分享的规范来自raywenderlich.com团队成员共同完成的，希望对学习OC的朋友们有所指导和帮助。 demo 刘彦玮的技术博客中文章对应的demo awesome-growth IT技能图谱 他人开源总结@ awesome-osx - Awesome OS X。 code4app - 最多国人用的代码库。 cocoachina - 国内最热门的iOS社区的代码库。 awesome-ios - 一个老外整理的，中文版。 awesome-ios-ui - 收集了不少 iOS UI/UX 库, 包含了很多酷炫的动画效果。 ios-cosmos - The iOS Cosmos：收录了iOS绝大部分的开源框架和工具。 Awesome Haskell资料大全 - Awesome Haskell 资料大全：框架，库和软件。 Cosmos - The iOS Cosmos：收录了IOS绝大部分的开源框架和工具。 cocoacontrols - 收集了很多UI控件效果代码，缺点是需要翻墙，而且代码分类不够好。 lexrus - lexrus国内出名的iOS开源coder，非常酷的label动画、textfield动画。 open-source-ios-apps - iOS App集合，分：swift与Objective-C–国外人整理。 适合iOS开发者的15大网站推荐 - 适合 iOS 开发者的 15 大网站推荐 — 英文网站。 Objective-C GitHub 排名前 100 项目简介 - 主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况。 Github-iOS备忘 -整理了比较常用的iOS第三方组件，以及github上的统计。 超全！整理常用的iOS第三方资源 - 超全！整理常用的iOS第三方资源。 MyGithubMark - Github上的iOS资料-个人记录（持续更新）。 Github 上的 iOS 开源项目 - Github 上的 iOS 开源项目总结。 iOS资源大全中文版 - iOS资源大全中文版。 开发博客列表@ 唐巧整理 - 猿题库唐巧整理。 11个超棒的iOS开发学习国外网站 - 11个超棒的iOS开发学习网站:objc.io ;subjc.com ;NSHipster ;Peter Steinberger ;Ole Begemann ;Florian Kugler ;NSBlog ;Cocoa ;iOS Dev Weekly ;iOS Developer Tips ;iOS Goodies ;AppCoda 香港人创建;Krzysztof Zab?ocki ;iOS Development tips ; 博客地址 RSS地址 南峰子的技术博客 南峰子的技术博客。 唐巧的技术博客 http://blog.devtang.com/atom.xml OneV’s Den https://onevcat.com/atom.xml objc 中国 为中国 Objective-C 社区带来最佳实践和先进技术。 破船之家 http://beyondvincent.com/atom.xml NSHipster http://nshipster.cn/feed.xml Limboy 无网不剩 http://feeds.feedburner.com/lzyy Lex iOS notes http://ios.lextang.com/rss 念茜的博客 http://nianxi.net/feed.xml Xcode Dev http://blog.xcodev.com/atom.xml Ted’s Homepage http://wufawei.com/feed txx’s blog http://blog.t-xx.me/atom.xml KEVIN BLOG http://imkevin.me/rss 阿毛的蛋疼地 http://xiangwangfeng.com/atom.xml 亚庆的 Blog http://billwang1990.github.io/atom.xml Nonomori http://nonomori.farbox.com/feed 言无不尽 http://tang3w.com/atom.xml Wonderffee’s Blog http://wonderffee.github.io/atom.xml I’m TualatriX http://imtx.me/feed/latest/ vclwei http://www.vclwei.com/posts.rss Cocoabit http://blog.cocoabit.com/atom.xml nixzhu on scriptogr.am http://nixzhu.me/feed 不会开机的男孩 http://studentdeng.github.io/atom.xml Nico http://www.taofengping.com/rss.xml 阿峰的技术窝窝 http://hufeng825.github.io/atom.xml answer_huang http://answerhuang.duapp.com/index.php/feed/ webfrogs http://webfrogs.me/feed/ 代码手工艺人 http://joeyio.com/atom.xml Lancy’s Blog http://gracelancy.com/atom.xml I’m Allen http://imallen.com/atom.xml Travis’ Blog http://imi.im/feed 王中周的技术博客 http://wangzz.github.io/atom.xml 会写代码的猪 http://gaosboy.com/feed/atom/ 克伟的博客 http://feed.cnblogs.com/blog/u/23857/rss 摇滚诗人 http://feed.cnblogs.com/blog/u/35410/rss Luke’s Homepage http://geeklu.com/feed/ 萧宸宇 http://iiiyu.com/atom.xml Yuan博客 http://www.heyuan110.com/?feed=rss2 Shining IO http://shiningio.com/atom.xml YIFEIYANG–易飞扬的博客 http://www.yifeiyang.net/feed KooFrank’s Blog http://koofrank.com/rss hello it works http://helloitworks.com/feed 码农人生 http://msching.github.io/atom.xml 玉令天下的Blog http://yulingtianxia.com/atom.xml 不掏蜂窝的熊 http://www.hotobear.com/?feed=rss2 猫·仁波切 https://andelf.github.io/atom.xml 煲仔饭 http://ivoryxiong.org/feed.xml 里脊串的开发随笔 http://adad184.com/atom.xml ibireme伽蓝之堂 http://blog.ibireme.com/feed/ 学习笔记@ iOS-NoteA@ 非常好的学习笔记，主要目录1.Core Data 笔记2.Photos 笔记3.转场动画详解4.自定义容器控制器转场5.交互式动画 设计@ design-resource 设计师资源列表 Reveal：分析iOS UI的利器 Reveal-Plugin-for-XCode - 一个Reveal插件，可以使工程不作任何修改的情况下使用Reveal，该插件已在Alcatraz上架。 物联网@ awesome-iot - 这份物联网学习参考大全太给力。从物联网协议、嵌入式系统、相关开源库、相关书籍、博客、学习笔记、标准应有尽有。 未分类@ Form Form 是一个方便开发者创建表单填写工作的 UI 库。","categories":[],"tags":[]},{"title":"非常赞 有用的.gitignore模板集合，包含了各种语言.","slug":"非常赞-有用的-gitignore模板集合，包含了各种语言","date":"2016-08-27T15:51:38.000Z","updated":"2016-08-27T15:52:24.000Z","comments":true,"path":"2016/08/27/非常赞-有用的-gitignore模板集合，包含了各种语言/","link":"","permalink":"http://pro.stonepark.fun/2016/08/27/非常赞-有用的-gitignore模板集合，包含了各种语言/","excerpt":"","text":"gitignore 非常赞 有用的.gitignore模板集合，包含了各种语言.","categories":[],"tags":[]},{"title":"IQKeyboardManager第三方库的使用","slug":"IQKeyboardManager第三方库的使用","date":"2016-07-20T15:38:39.000Z","updated":"2016-07-20T15:38:39.000Z","comments":true,"path":"2016/07/20/IQKeyboardManager第三方库的使用/","link":"","permalink":"http://pro.stonepark.fun/2016/07/20/IQKeyboardManager第三方库的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"iOS、mac开源项目及库","slug":"iOS、mac开源项目及库-1","date":"2016-06-08T00:59:34.000Z","updated":"2016-06-08T01:02:16.000Z","comments":true,"path":"2016/06/08/iOS、mac开源项目及库-1/","link":"","permalink":"http://pro.stonepark.fun/2016/06/08/iOS、mac开源项目及库-1/","excerpt":"TimLiu-iOS========自己总结的iOS、mac开源项目及库，持续更新。。。。github排名 https://github.com/trending,github搜索：https://github.com/search 目录 UI 下拉刷新 模糊效果 AutoLayout 富文本 图表 表相关与Tabbar 隐藏与显示 HUD与Toast 对话框 其他UI 动画 侧滑与右滑返回手势 gif动画 其他动画 网络相关 网络连接 图像获取 网络聊天 网络测试 网页框架 WebView与WKWebView Model 通讯录 其他库 数据库 缓存处理 PDF 图像浏览及处理 摄像照相视频音频处理 响应式框架 消息相关 消息推送客户端 消息推送服务器端 通知相关 版本新API的Demo 代码安全与密码 测试及调试 动态更新 AppleWatch VPN 完整项目 好的文章 Xcode插件 美工资源 开发资源 开发资料 swift 他人开源总结 开发博客列表","text":"TimLiu-iOS========自己总结的iOS、mac开源项目及库，持续更新。。。。github排名 https://github.com/trending,github搜索：https://github.com/search 目录 UI 下拉刷新 模糊效果 AutoLayout 富文本 图表 表相关与Tabbar 隐藏与显示 HUD与Toast 对话框 其他UI 动画 侧滑与右滑返回手势 gif动画 其他动画 网络相关 网络连接 图像获取 网络聊天 网络测试 网页框架 WebView与WKWebView Model 通讯录 其他库 数据库 缓存处理 PDF 图像浏览及处理 摄像照相视频音频处理 响应式框架 消息相关 消息推送客户端 消息推送服务器端 通知相关 版本新API的Demo 代码安全与密码 测试及调试 动态更新 AppleWatch VPN 完整项目 好的文章 Xcode插件 美工资源 开发资源 开发资料 swift 他人开源总结 开发博客列表 ======== 具体内容 ===================================== UI下拉刷新 EGOTableViewPullRefresh - 最早的下拉刷新控件。 SVPullToRefresh - 下拉刷新控件。 MJRefresh - 仅需一行代码就可以为UITableView或者CollectionView加上下拉刷新或者上拉刷新功能。可以自定义上下拉刷新的文字说明。具体使用看“使用方法”。 （国人写） XHRefreshControl - XHRefreshControl 是一款高扩展性、低耦合度的下拉刷新、上提加载更多的组件。（国人写） CBStoreHouseRefreshControl - 一个效果很酷炫的下拉刷新控件。 BreakOutToRefresh - 一个下拉刷新打砖块的开源 Swift 库，能让用户在等待下拉刷新的时候边玩撞球游戏边等待。 KYJellyPullToRefresh - 实现弹性物理效果的下拉刷新，神奇的贝塞尔曲线，配合UIDynamic写的一个拟物的下拉刷新动画。 MHYahooParallaxView - 类似于Yahoo Weather和News Digest首屏的视差滚动。 SDRefreshView - 简单易用的上拉和下拉刷新（多版本细节适配）。 ZLSwiftRefresh - swift下拉刷新/上拉加载更多，支持自定义动画，集成简单，兼容UITableView/CollectionView/ScrollView/WebView。 BreakOutToRefresh - swift，上拉和下拉刷新。 GearRefreshControl - swift，上拉和下拉刷新。 refresher - swift，上拉和下拉刷新。 可展开/收缩的下拉菜单–SvpplyTable - 一个可展开可收缩的下拉菜单，类似Svpply app。 ODRefreshControl - 原iOS6上的橡皮糖刷新样式，很有意思。现在也很多大的 App 在用，比如虾米音乐和 QQ 客户端。 PullToMakeSoup - PullToMakeSoup, 自定义下拉刷新的动画效果：煮饭, Yalantis新作！ TwitterCover - Twitter iOS客户端的下拉封面模糊效果。 Replace-iOS - Replace-iOS 让人眼前一亮的下拉刷新（iOS）。 ReplaceAnimation.swift - 基于 @ZeeYoung欧阳哲 同学的创意下拉刷新动画实现。值得称赞还有额外增加了“取消及滚动”效果支持。 Animations - 封装了一下，使用的时候只要两行代码。一些动画的飞机稿，都是一些单独分离出来的用于测试的子动画，现在统一归类一下。 PullToBounce - 下拉刷新的动画 for UIScrollView。 WaterDropRefresh - 仿Path 水滴的下拉刷新效果 还有视差滚动。 ESRefreshControl - 仿新浪微博、百度外卖、网易新闻下拉刷新样式Demo（仅供参考）。 WaveRefresh - 下拉刷新水波纹动画。 DGElasticPullToRefresh - 是一款带有弹性效果的 iOS 下拉刷新组件。 CALayerAnimationDemoh - 双向注水动画下拉刷新组件,使用CALayer的mask实现。 BanTangAnimation - 半糖下拉刷新的原理。简单来说是利用CGGlyph，字符图形转换成cgpath，然后绘制strokeEnd动画。把timeoffset和scrolloffset结合就行了。 PullToReflesh-Swift - 一款炫酷的下拉刷新封装库（Mobile page refresh concept inspired by Google and for something like a news app）。源码分析 pull-to-refresh.swift - 是一款非常易于开发者使用的下拉刷新和加载更多组件。通过一个 UIScrollView 的扩展，可以轻松为 UIScrollView 的所有子类添加下拉刷新功能。 模糊效果 FXBlurView - 是一个UIView子类，支持iOS5.0以上版本，支持静态、动态模糊效果，继承与UIView的模糊特效。 VVBlurPresentation -很简单易用的在原来viewconntroller基础上做模糊，然后present新的viewcontroller的。 UICustomActionSheet - 通过模糊背景来着重强调与菜单相关的元素–对话框 里面已经收藏。 SABlurImageView - 支持渐变动画效果的图像模糊化类库。P.S. 与前几天推存类库 SAHistoryNavigationViewController 是同一位作者。 Blurable.swift - swift模糊组件。 AutoLayout Masonry - Masonry是一个轻量级的布局框架，拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了并具有高可读性（ 使用介绍1 使用介绍2），iOS自适应前段库-Masonry的使用），Masonry、Classy、ClassyLiveLayout介绍。使用DEMO 视图居中显示、子视图含边距、视图等距离摆放、计算ScrollView的contentsize。 Classy - Classy是一个能与UIKit无缝结合stylesheet(样式)系统。它借鉴CSS的思想，但引入新的语法和命名规则，Classy官网，Masonry、Classy、ClassyLiveLayout介绍。 ClassyLiveLayout - ClassyLiveLayout通过结合Classy stylesheets与Masonry一起使用，能够在运行的模拟器中微调Auto Layout约束实时显示效果的工具，Masonry、Classy、ClassyLiveLayout介绍。 Snap - Snap是Masonry Auto Layout DSL的Swift版本，是一款轻量级的布局框架，使用了更良好的语法封装了AutoLayout。Snap支持iOS和OS X。 SnapKit - 就是“snap”， –swift 喜欢自动布局吗？当然喜欢！至少在storyboard中创建时会喜欢。 在代码中纯手工创建约束灰常痛苦，但幸运的是我们有了SnapKit，在board中用上它，你可以简单直观地编写约束了。 PureLayout - PureLayout 是 iOS &amp; OS X Auto Layout 的终极 API——非常简单，又非常强大。PureLayout 通过一个全面的Auto Layout API 扩展了 UIView/NSView, NSArray 和 NSLayoutConstraint，仿照苹果自身的框架。 UIView-AutoLayout -Deprecated in favor of PureLayout, which includes OS X support:https://github.com/smileyborg/PureLayout。 Cartography - Cartography 是用来声明 Swift 中的 Auto Layout，无需输入任何 stringly 就可设置自己 Auto Layout 的约束声明。 Auto-Layout-Showcase - swift,AutoLayout 进阶 Demo，宽高比约束、比例约束、不等约束、视差约束、低优先级约束等高级用法，无需写码即可进行复杂页面布局，Demo 还动态模拟了各屏幕下的效果。来自百度知道 iOS 小组的内部分享。 UIView-FDCollapsibleConstraints - 一个AutoLayout辅助工具，最优雅的方式解决自动布局中子View的动态显示和隐藏的问题。第二个Demo模拟了一个经典的FlowLayout，任意一个元素隐藏时，底下的元素需要自动“顶”上来，配合这个扩展，你可以在IB里连一连，选一选，不用一行代码就能搞定。 Autolayout_Demo - 在项目中用自动布局实现的类似抽屉效果。 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute - 当view隐藏的时候也隐藏其autolayout的NSLayoutAttribute，从而不用大量的代码工作。 SDAutoLayout - AutoLayout 一行代码搞定自动布局！支持Cell、Label和Tableview高度自适应，致力于做最简单易用的AutoLayout库。 Neon.swift - 功能强大的 UI 布局神器。 EasyPeasy.swift - 编程方式自动布局框架库。 富文本 TFHpple - TFHpple解析html的轻量级框架 RTLabel - RTLabel 基于UILabel类的拓展,能够支持Html标记的富文本显示，它是基于Core Text,因此也支持Core Text上的一些东西。32位，很久没有更新了。 RTLabel - 富文本，RTLabel支持64位。 TYAttributedLabel - TYAttributedLabel。 简单易用的属性文本控件(无需了解CoreText)，支持富文本，图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示。 TQRichTextView - 用于做富文本视图控件显示，用于即时通讯的表情显示，以及资源评论的富文本显示。 TTTAttributedLabel - 一个文字视图开源组件，是UILabel的替代元件，可以以简单的方式展现渲染的属性字符串。另外，还支持链接植入，不管是手动还是使用UIDataDetectorTypes自动把电话号码、事件、地址以及其他信息变成链接。用TTTAttributedLabel创建变化丰富的UILabel - 网易新闻iOS版使用。 MLEmojiLabel - 自动识别网址、号码、邮箱、@、#话题#和表情的label。可以自定义自己的表情识别正则，和对应的表情图像。(默认是识别微信的表情符号)，继承自TTTAttributedLabel，所以可以像label一样使用。label的特性全都有，使用起来更友好更方便。 FXLabel - FXLabel是一个功能强大使用简单的类库，通过提供一个子类改进了标准的UILabel组件，为字体增加了阴影、内阴影和渐变色等，可以被用在任何标准的UILabel中。FXLabel还提供了更多控件，可以对字体行距、字体间距等进行调整。 WFReader - 一款简单的coretext阅读器，支持文本选择、高亮以及字体大小选择等。 WPAttributedMarkup - WPAttributedMarkup is a simple utility category that can be used to easily create an attributed string from text with markup tags and a style dictionary。 KMPlaceholderTextView - 可显示多行 placeholder 的 textView，可以在IB里面设置 – swift。 HHFlashSwitch - 一个另类的UISwitch，选择后，背景水波扩散变色效果。 UUColorSwitch - Switch 开关动画效果,当打开开关时，Switch可实现平滑渲染过渡到父视图的效果。 UITextViewDIYEmojiExample - UITextView编辑时插入自定义表情-简单的图文混编。 Shimmer - BlingBling闪光效果，酷炫的Label的效果，可以用于加载等待提示。 ZSSRichTextEditor - 适用于iOS的富文本WYSIWYG编辑器，支持语法高亮和源码查看。ZSSRichTextEditor包含所有WYSIWYG标准的编辑器工具。 RichEditorView - swift，一套可定制富文本编辑器组件及示例。功能完整、代码简练、实现逻辑巧妙（编辑器核心与 WebView 结合，采用 HTML5 contentEditable 编辑模式，执行JS 配套命令 execCommand 实现富文本编辑功能）。 DTCoreText - 可以解析HTML与CSS最终用CoreText绘制出来，通常用于在一些需要显示富文本的场景下代替低性能的UIWebView。DTCoreText源码解析。 CSGrowingTextView - 用作即时通讯文本框和评论文本框使用，可以显示多行输入。 MarkdownTextView - 显示Markdown的TextView。 SwiftyMarkdown.swift - 用swift写的markdown解析库。 Marklight.swift - Markdown 语法高亮显示编辑库（Swift）。 高仿微信限定行数文字内容 - 采用Autolayout高仿微信纯文字限定行数。 FuriganaTextView - 实现复杂的日文韩文排版。 ParkedTextField - 带固定文本的输入组件。 LTMorphingLabel - swift 能够实现文字变形动画效果的Label，用Swift写的一个能够实现文字变形动画效果的Label，很炫。 GJCFCoreText - 图文混排。 AttributedLabel - 显示性能数量级 UILabel 的 AttributedLabel。无畏无惧、挑战权威。 FFLabel - 自动检测 URLs, @username, #topic# 等关链词（提供响应扩展）。实用的标签文本小组件。 TextFieldEffects - 标准的UITextField有些枯燥么？来认识一下TextFieldEffects吧！废话不多说，只要看几个例子,是啊，都是些简单的dropin控制器。甚至可以在storyboard中使用IBDesignables。 AutocompleteField - 可应用于 iOS 应用中文字输入框自动补全的场景, 兼容到 iOS 8。 Splitflap.swift - 可用于快速给 iOS 应用创建文字翻转的动画效果。 WordPress-Editor-iOS - 一个文本编辑器 简书和新浪博客都在用。 YYText - 功能强大的 iOS 富文本框架。 placeholder_TextView - 带有placeholder的TextView：带有提示信息的textview，使用懒加载的思想，支持扩展、自定义，类似许多APP内部的意见反馈页面 。 FloatLabelFields.swift - FloatLabelFields.swift浮动标签输入效果类。 M80AttributedLabel - M80AttributedLabel实现文字与表情的混排。一般使用气泡作为背景。 HPGrowingTextView - HPGrowingTextView聊天输入文字，可以根据输入文字的多少自动改变输入框的高度。 cleartext-mac.swift - 提供一千个常用单词的编辑器。 GlitchLabel.swift - 可定制“黑（故障）文字标签”类库，熟称晃瞎你的眼文字标签。 图表 PNChart - 国内开源作者，动态的图表。 swift-linechart - 功能完整、实用的折线图组件。使用方便，参数配置简单。是不可多得的优质组件–swift。 ios-charts - 一款优秀 Android 图表开源库 MPAndroidChart 的 Swift 语言实现版（支持 Objective-C 和 Swift 调用）。缺省提供的示例代码为 Objective-C。 TEAChart - xhacker/TEAChart 一个简洁的 iOS 图表库，支持柱状图、饼图以及日历等。 YOChartImageKit - 支持在watchOS上绘制图表，看它最近更新挺勤快的，可以关注一下。 RealtimeGradientText - Fun With CALayer Mask 刚好今天开源了一个有趣的项目 RealtimeGradientText，所以也好聊一下 CALayer 的 Mask，说明。 XYPieChart -XYPieChart:饼状图, 饼图, 数据统计, 数据可视化,可以在图形上标注数据。效果十分漂亮，而且没有用到一张图片。 ZFChart - 模仿PNChart写的一个图表库，用法简单，暂时有柱状图，线状图，饼图三种类型，后续可能会更新新的类型。 Scrollable-GraphView.swift - 灵动感十足的自适应、可定制滚动曲（折）线图表库。 表相关与Tabbar SWTableViewCell - 国内开源作者，带很多手势的表单元格。 MCSwipeTableViewCell - 带很多手势的表单元格。 TMQuiltView - 瀑布流。 XRWaterfallLayout - 超简单的瀑布流实现,实现说明。 WaterfallFlowDemo - 一个简单的UICollectionView瀑布流布局演示demo。 XLForm - 很多表格类的table,写法更高冷一点，推荐使用。 Eureka.swift - Eureka 是 XLForm 的 Swift 的移植版本, 一个可以帮助开发者们快速构建 iOS 各种复杂表单的库, 具有较高的可扩展性, 方便自定制样式。 RETableViewManager - 可以十分方便地生成各种样式、各种功能的TableView。只要开发者能想到的列表效果或者功能，都可以利用这份代码迅速编写出来。比如，之前要实现一个填写各种资料的列表，可能需要很多代码，现在只需要几行代码就可以实现。 UIScrollSlidingPages - 允许添加多视图控件，并且可以横向滚动。有点类似于Groupon app。 HBHorizontalTableView - swift，TableView 横向滚动小示例（仿照 AppStore 应用展示）。 HorizontalScrollCell - HorizontalScrollCell是一款使用方便的水平方向可滚动的单元格，适用于UICollectionView中实现水片方向滚动视图。 。 SYJiugonggeTableView - tableView封装的九宫格。 UUChatTableView - UUChatTableView 气泡聊天界面，支持文本、图片以及音频的气泡聊天界面。源码推荐说明。 Chats - 聊天 UI 示例程序。此项目应该只为演示或学习之用，没有服务器 – swift。 Atlas-iOS - 快速在iOS里集成聊天功能，类似开源版本的环信。Layer家开源了一套聊天app界面的解决方案.看起来很赞，很多蛮复杂的东西直接都帮封好了。不得不说现在做app开发真是很简单，大部分时间搭积木就可以了。官方网站。 Chatto.swift - Chatto.swift:轻量级聊天应用框架及示例。文字及图片可扩展输入栏，汽泡效果等聊天核心特性，分页及自动布局完善。 DLSlideView - DLSlideView对常见的顶部Tab页点击、滑动分页做了封装。它使用基于ViewController的container特性（而不是scrollview）来管理各个子页面，以支持无限分页，源码推荐说明。 VOVCManager - 页面管理器:1.跳转指定页面,只需要知道viewController的Class名,如果有storyboard,则需要指定storyboard名；2.无需添加基类；3.支持URLScheme跳转指定页面。 MBXPageViewController - 简洁快速的页面切换–MBXPageViewController，带有按钮控件的UIPageController，非常整洁、简单以及快速。该项目通过三种形式展示页面之间的切换，比如导航栏上的多个tab切换、页面左右两端箭头指示切换，以及使用分段控件。 PagerTab - UIScrollView实现滑动转换页面，类似网易云音乐iOS版的页面滑动切换效果。 GUITabPagerViewController - 多个tab滑动切换。 VOMetroLayoutDemo - Metro风格的UICollectionView, 目前只支持横向布局,仅在iPad上应用。 KYCellAnimation - 给UITableViewCell增加进入的动画。 COBezierTableView - swift，通过编辑 Bezier 曲线四点位置设置 TableView 内 Cell 及对应按扭位置。实验效果很赞。 RDVTabBarController - 一个TabBar组件，可以方便设置底部菜单的文字图片，点击效果，小红点提示等。 LxTabBarController - 改变了原生tabbar切换tab时的生硬效果，并加入滑动切换手势（有和界面上的其它手势发生冲突的风险，可根据具体项目予以关闭），swift版本。 WXTabBarController - 在系统 UITabBarController 的基础上完美实现了安卓版微信 TabBar 的滑动切换功能，单手操作 iPhone 6 Plus 切换 TabBar 一直是一件很痛苦的事情，而滑动切换是一种不错的解决方案，支持屏幕旋转。 GooeyTabbar - 皮筋式弹性缩放工具栏示例及演示。 CYLTabBarController - 低耦合集成TabBarController,最低只需传两个数组即可完成主流App框架搭建。 横向展示文本内容的自定义cell - 可以横向展示文本内容的自定义cell，根据文本无限滚动。 UITableView-FDTemplateLayoutCell - UITableView-FDTemplateLayoutCell 是一个方便缓存 UITableViewCell 的高度的框架。 ExpandingStackCells - 采用 UIStackView 实现表格单元格扩展内容显示示例及解决方案。 FDStackView - 可以将 UIStackView 的最低支持版本拉低到 iOS6，无需配置，没有代码侵染，扔到工程里后直接用系统 UIStackView 的 API 即可，同时兼容 Storyboard。 Sapporo - swift 单元格模型驱动的集合视图管理器组件。又一个超实用的“轮子”。 MDIHorizontalSectionTableViewController - 根据产品需求开源了一个交互项目，可以理解为横向Section的TableView，section和cell同时支持拖拽，后续安卓版本也会开源出来。 JZNavigationExtension - 多功能导航控制器，可以透明返回栏。 NavTopImage.swift - NavigationController动态缩放titleView。 QuickRearrangeTableView - 基于 UITableView 的快速重排功能扩展子类。通过长按选定单元格然后滚动移动到指定位置。 uicollectionview-reordering - UICollectionViews的拖拽(拖动、移动)效果,实例教程. DZNEmptyDataSet - DZNEmptyDataSet算是一个很标准的iOS内建方式，适合用来处理空的table view和collection view。会自动将collection view处理完善，并将用户消息以合适美观的方式显示出来。每个iOS项目都可以自动处理。 LLNoDataView - 超简单的空数据提示通用View支持UIScrollView、UITableView、UICollectionView、UIWebView。 MGSwipeTableCell - 另一个常见于很多应用中的UI组件，苹果应该考虑在标准的iOS SDK中加入一些类似的内容。Swipeable表格cell是这个pod的最佳描述，也是最好的。 XLPlainFlowLayout - 可以让UICollectionView的header也支持悬停效果，类似于tableView的Plain风格。 WMPageController - 一个方便的 pageContrller 的控件，里面还包括滚动视图。 PSTCollectionView - PSTCollectionView。 LLRiseTabBar-iOS - 直接使用系统的特性实现的tabbar，比较简单。 MTMaterialDelete - 非常有趣的Material Design动画，动画删除表里面的单元格。 paper-onboarding.swift - 漂亮的 material design 风格页面滑块。示例完整，易用。 Material.swift - 基于 Material Design 动画和图像框架库 （作者 Daniel Dahan）。 BusyNavigationBar - 进度条式NavigationBar导航条。 ReorderableGridView-Swift - 拖拽排序卡片。 LGSettingView - LGSettingView仅需三句代码即可快速集成设置界面，免去每次开发新应用都要重新布置设置界面的烦恼。 微博cell自动布局 - 使用autoLayout对微博的cell进行自动布局，自适应cell的高度。 TreeTableView - ZYTreeTableView：TreeView 模仿好友列表的实现方式。 ZWSlideViewController - ZWSlideViewController多页滑动视图控制器（类似新闻类门户APP）,可以用最简单的继承方法使用，也可以不用继承，只用菜单或主视图页面，可实现丰富的定制，可以使用在多种不同形态的APP下，还可以将其做为多页或多图的滑动介绍。 ZYThumbnailTableView.swift - 可展开型预览TableView，开放接口，完全自由定制。实现教程 XWCatergoryView - 一个轻量级的顶部分类视图控件，只需要通过简单的设置，你就可以快速集成该控件， 控件目前暂时有底部横条移动，椭圆背景移动，文字缩放，文字颜色变化，和文字颜色渐变五种效果，五种效果可以叠加使用也可以单一使用。实现教程 jingDongFenLei - 简单仿写京东分类中的多级分类页面。 WHC_CollectionViewFramework.swift - 高仿支付宝可拖拽排序编辑动画效果cell的CollectionView集合视图。 SwipeViewController.swift - 一款好用的页面滑动和标签选项卡类库及示例。功能相当于 Objective-C 版 RKSwipeBetweenViewControllers。 RKSwipeBetweenViewControllers - 页面滑动和标签选项卡类库。 FriendSearch - 两种UI的搜索，搜索的算法可以满足中英文互搜，联想搜索等，其中还包含对一组数据自动进行按字母分组等功能。 YX_UITableView_IN_UITableView - UITableview嵌套UITableView案例实践（仿淘宝商品详情页实现），项目讲解。 TabDrawer.swift - 更适合单手操作的可定制 Tab Bar 组件库。P.S. 自动布局选择了 EasyPeasy。 SFFocusViewLayout.swift - UICollectionViewLayout实现的图片浏览器。 TYPagerController - 简单，支持定制，页面控制器,可以滚动内容和标题栏,包含多种style。 ESTabBarController.swift - 自定义TabBarController组件，继承自UITabBarControlle，可添加动画和自定义样式。swift 高度自定义TabBarController，支持自定义TabBarItem样式或添加动画 隐藏与显示 SlideTapBar - 滚动栏菜单，向上滚动时隐藏tabbar，向下滚动马上显示tabbar。 FoldingTabBar.iOS - 可折叠Tab Bar和Tab Bar Controller。 LTNavigationBar - LTNavigationBar为app导航栏添加动态着色效果，可自定义其背景色。Demo包含：1.变换背景色；2.滚动视图，导航栏和状态栏重叠。实现教程 KMNavigationBarTransition - LTNavigationBar在右滑返回的时候NavigationBar显示都不完美,KMNavigationBarTransition一个用来统一管理导航栏转场以及当 push 或者 pop 的时候使动画效果更加顺滑的通用库，并且同时支持竖屏和横屏。 HYNavBarHidden - 导航条滚动透明，超简单好用的监听滚动,导航条渐隐的UI效果实现。 BLKFlexibleHeightBar - 固定Header的效果库，一个拥有非常灵活高度的标题栏，可以为使用软件的用户提供更多的阅读和滑动空间，现在已经被众多app所采用。 JXT_iOS_Demos - AboutNavigationBar:一些关于navigationBar的非常规的但是较为实用的操作，包括利用毛玻璃、动态透明、动态隐藏，以及头视图的动态缩放，并同时涉及了statusBar的动态设置（换色）。教程。 NavigationBarScaleViewDemo - iOS导航条自由缩放头像效果。原理剖析。 HUD与Toast MBProgressHUD - 最多人用的loading。 EBuyCommon - 1.基于MBProgressHUD实现得图形加载提示方式，及其它标题方式提醒。2.弹窗。 SVProgressHUD - SVProgressHUD的loading，如果你需要定制化的等待提示器，这个就是了（也许是最好的）。 ProgressHUD - ProgressHUD的loading，使用最简单。 MMProgressHUD - 设置HUD出现和消失的方式（包括上下、左右、淡入淡出、放大缩小等等），设置HUD的内容（可以在HUD中加入帧动画、动态图片等等），设置HUD出现时的底部覆盖层颜色，等等。总而言之，这是一份集大成的HUD代码。慢慢看视频吧，囊括了所有效果。 WSProgressHUD - 一个小巧精致的HUD,支持添加到自定义View上, 还有更多小细节.。 PreLoader - 一个很有意思的HUD loading ，通过运动污点和固定污点之间的粘黏动画吸引用户的眼球跟踪，能有效分散等待注意力。PreLoader的实现讲解 Toast-Swift - 高可定制易用的 Toast 弹出信息或通知用户界面组件类。 对话框 WCAlertView - 自定义的对话框。 IOS7AlertView - IOS7AlertView的对话框。 AMSmoothAlert - 动画效果不错，最多star，但不支持arm64。 DQAlertView - 扁平化的样式不错。 HHAlertView - 一个简易的alertview 有三种样式，有成功，失败，和警告三种样式，支持Delegate和block两种回调。 MJPopupViewController - 实现弹出视图的各种弹出和消失效果，包括淡入淡出（fade in，fade out），从屏幕上方飞进，下方飞出，从屏幕左方飞进，右方飞出等等效果，弹窗。 MMPopupView - 弹出框的基类组件（弹窗）。 Menu - 项目中可能会用到的常用菜单，以后有时间会继续补充，弹窗。 EasyTipView - 弹出提示框类及演示示例。同样地，API 简单、易用。好“轮子”，弹窗。 kxmenu - kxmenu弹出菜单，点击视图上任意位置的按钮，会弹出一个菜单，并且有个小箭头指向点击的按钮，类似气泡视图。弹出的菜单位置会根据按钮的位置来进行调整。 QBPopupMenu - QBPopupMenu弹出菜单，实现类似 UIMenuItem 的弹出菜单按钮。点击按钮，会弹出一个菜单，上面可以排列多个按钮。纯代码实现，不需要任何图片。 STModalDemo - 弹出视图（通知，提示，选择，窗口）。 TAOverlay - TAOverlay可通过叠加层展示有用的信息，可自定义文本和背景色，添加阴影和模糊效果，以及更改字体大小或者用自定义图片替换页面上的icon。 UICustomActionSheet - 通过模糊背景来着重强调与菜单相关的元素–模糊效果 里面已经收藏。 ActionSheetPicker-3.0 - 该项目是此前热门项目ActionSheetPicker的新版本，快速复制了iOS 8上的下拉 UIPickerView/ActionSheet功能。 MJAlertView - 3D效果转场效果警示图–MJAlertView。 SwiftyDrop - 轻量、易用的小清新弹出列表及信息提示组件真心不错。 PSTAlertController - 兼容 iOS7的 XXAlertController，接口跟UIAlertController 一模一样，做到高低版本通用。 PCLBlurEffectAlert.swfit - 细节定制较丰富的弹出警报窗口组件。 GSAlert.swfit - 苹果在iOS8推出了全新的UIAlertController，旧的UIAlertView和UIActionSheet渐渐被废弃，但如果你仍然支持iOS7系统，你将不得不写两套代码。GSAlert解决了这个问题。 SweetAlert-iOS - SweetAlert-iOS 带动画效果弹窗对话框封装类。 DXPopover - DXPopover微信右上角的+点击展示列表效果，弹窗菜单。 CCActionSheet - CCActionSheet：仿照微信朋友圈自定义actionsheet，一行代码即可使用。 TKSwarmAlert.swift - TKSwarmAlert.swift:模仿 Swarm app 的 Alert 提醒框动画工具。 CustomPopOverView - 自定义弹出视图，内容支持传一组菜单标题，也支持自定义view，或者自定义viewController，支持任意按钮触发，会显示在按钮底部，也支持切换按钮的对齐方式：左对齐、居中、右对齐。 PMAlertController.Swift - 可定制弹窗组件替代官版不可定制的 UIAlertController。 TBActionSheet.swift - 支持Carthage，可自定义度100%的 ActionSheet，支持微信样式。 其他UI AwesomeMenu - 最多人用的Path菜单。 DCPathButton - Path，4.0的弹出菜单，呼出或者关闭菜单时，多个小图标会分别按照逆时针和顺时针的方向进行滚动。 SphereMenu - 利用UIDynamicAnimator的有趣的菜单，path类似。 KYGooeyMenu - KYGooeyMenu 是一个具有 Gooey Effects 带粘性的扇形菜单控件(卫星菜单、path)。 LiquidFloatingActionButton - 卫星弹出菜单。 JZMultiChoicesCircleButton - 三维多选按钮。 LCUIKit - 一个button上面既有icon又有文字。也许左icon右文字，或者上icon下文字。 TwitterPaggingViewer - 多个Tableview，左右滑动。 CircularProgressControl - Circular Progress Control using CAShapeLayer ，环形进度控制条。 KYCircularProgress - 简单、实用路径可定进程条。 KDCircularProgress - KDCircularProgress是使用swift制作的色彩炫丽的进度条，可以加入多种颜色来控制进度条的渐变效果。 TextProgress - 自定义实现数字进度条：1、可以自定义数字（0-100），填充的比例为当前设置的数字，2、可以实现自定义填充颜色，上下部分都可以，3、可以自定义边界的颜色4、实现了水波动画，可以设置打开或关闭。 SDProgressView - 简便美观的进度指示器，此系列共有六种样式的进度指示器。 NVActivityIndicatorView - loading 进度条动画，有20-30多种，是在此DGActivityIndicatorView 基础上做得修改。 LoopProgressDemo - 环形渐变进度条，环形渐变进度条实现。 XLPagerTabStrip - 做的很棒的iOS下的PagerTabStrip。 ASProgressPopUpView - 弹出的进度条显示进度。 RandomColorSwift - 一个自动生成好看的颜色的 Swift 库，RandomColorSwift。 Hue.Swift - Hue.Swift：颜色常规功能集于一身的定义、使用 Color 工具类库（含图片取色）。 KtColor.swift - 利用 Swift 的语法特性简化创建 UIColor对象的过程。具体文章可以参考博客：当UIColor遇上 Swift。 HexColorService - 将16进制颜色字符串转成UIColor。 Rainbow - 旨在提高代码可读性及易用性的 UIColor 扩展，它使原先有限的预定义颜色（方法）选择，扩展至超过 1200 种。 UIColor-ChineseTraditionalColors - 中国传统颜色引用 UIColor 扩展。“UIColor.桃红()，UIColor.竹青() …”，共158种。 YPDropMenuViewDemo.swift - 一款DropMenu,menuView,类似之前美团的下拉菜单，支持swift2.2，因为用到iOS8.的毛玻璃。所以想支持到iOS8.0,支持自定义，支持等宽排列，支持从左向右排列。 类似美团的下拉菜单 - 类似美团的下拉菜单，源码推荐说明。 类似美团的下拉选项 - 类似于美团、大众点评的下拉菜单选项，code4app代码，评论代码有瑕疵。 CRMediaPickerController - 一个简单易用的图片/视频选择器。1.可同时选择照片和视频。 2.挑选范围有Camera、Camera Roll、Photo Library以及最近拍摄的照片和视频。3.可自定义UIImagePickerController属性（Camera Overlay、Camera Device、Camera View Transform以及allowsEditing）。4.支持横屏和竖屏5.原生的iOS UI。，源码推荐说明。 MDCSwipeToChoose - MDCSwipeToChoose可简单地添加滑动手势来调用UIView，并使用该行为提供了一个组件以创建类似Tinder app的like或者dislike界面的轻扫。基于轻扫的方向，你可以决定执行什么样的行为，并且你可以自定义文本颜色和图片。该项目适用于教学用的抽认卡、图片查看器以及其他等。 iOS Material Design库 - 该项目借鉴于谷歌的Material Design guideline，用户可自定义背景色。 Material-Controls-For-iOS - Material Design风格的各种控件，非常完整全面。 ZMaterialDesignUIButton - Swift Material Design UIButton。 MediumScrollFullScreen - Medium的可扩展滚动页面，上下滚动时，全屏显示内容，并自然消隐上下菜单。由此项目感知，作者是一位很注重细节的开发者，他的另外几个菜单类项目也都不错，值得参考，比如：PathMenu, MediumMenu 等。 WZFlashButton - WZFlashButton，点击后button里面出现水波扩散效果。 Twinkle - 为字体加上钻石版闪耀的效果。使用Swift编写。 ios-multi-back-button - 可替换内置的UInavigationController返回按钮，长按左上角的返回按钮，实现多层级的快速返回。 ASDayPicker - 适用于iOS (iPhone)的日期选择器(时间选择器)，类似于Calendar app的周视图。 today extension - 用纯代码构建一个Widget(today extension) 。 FSCalendar - 日历视图，带有微妙和平滑的滚动效果，可自定义外观–国人。 CVCalendar - 是一个方便开发者集成自定义日历视图到自己 iOS 应用的项目, 支持 Storyboard 和手动配置, 使用 CocoaPods 进行安装, 提供了丰富的 API 供开发者使用。 HSDatePickerViewController - 带有Dropbox Mailbox感觉的时间日期选择器(时间选择器)。启动是背景被模糊化。界面也是主流的扁平化风格。 HZQDatePickerView - 自定义时间选择器(日期选择器)，包括开始日期和结束日期两种类型。 CFCityPickerVC - 城市选取控制器。 JTCalendar - iOS下优美的 Calendar 组件，做 GTD 类 App 必备。 Persei - 动画隐藏或显示顶部菜单支持库及示例项目。–swift PDTSimpleCalendar - 是iOS最棒的日历组件了。你可以在各个方面对它进行定制，无论是运行逻辑还是外观方面。 DateRangePicker.swift - 可能是目前最好的 OS X 日期选择器,高扩展性，界面风格看起来很舒服，不过注意，是 OS X 开发专用。 Form - JSON 驱动的 Form表单系统，复杂的表单填写类 App 极其需要（比如淘宝呢！）。 SwiftyFORM - swift 表单输入框架（亮点是表单验证规则引擎），是我见过地最易用的 Swift 表单组件。 SwiftSpinner - SwiftSpinner是使用swift制作的一款精致带感的指示器，并且连带有字体信息显示，模糊背景，半透明，扁平化等IOS8的效果。 AKPickerView-Swift - 一款小而美的 3D 效果选择器。 ImagePickerSheet - 图片或视频选择器（可多选）组件及其示例项目。 iOS-RatingBar - iOS-RatingBar swift版的评分控件,跟Android的RatingBar一样有两种模式，评分模式和只读模式’支持视图编辑，自定义星星数量，评分等级,另外还能支持非整数星，0.5颗星，0.1颗星,可以开启动画效果。 RKNotificationHub - 快速给 UIView 添加上炫酷的通知图标（Badge、红点、提示）。 * WZLBadge - Badge，支持横竖屏支持iOS5~iOS8允许高度定制化，包括“红点”的背景颜色，文字(字体大小、颜色)，位置等。说明. BubbleTransition - 以气泡膨胀和缩小的动画效果来显示和移除 controller，Uber的就是这种取消操作的方式。 KYFloatingBubble - 类似iOS7中Game Center浮动气泡的效果。 DKNightVersion - DKNightVersion 是一个支持夜间模式切换的框架。 EasyUIControl - 一个可以简化界面ui的控件框架。 LxGridView-oc LxGridView-swift - 利用UICollectionView模仿iOS系统桌面图标的交互，作用如动图。 QQBtn - 仿QQ未读消息弹性按钮动画，达到和手机QQ未读信息一样的动画效果，效果基本实现。 GMStepper - swift 带动画效果、支持手势滑动操作的步进标签。 TZStackView - OS 9 UIStackView 功能模拟实现于 iOS 7/ iOS 8 内。 LayoutTrait - swift 一个小类库。 做iPad 多任务分屏 适配的同学可以看一下。 HACursor - HACursor，是一个对横向ScrollView中的视图进行管理的UI控件。只要几行代码就可以集成类似于网易新闻对主题页面进行排序，删除操作的功能。 ZTPageController - 模仿网易新闻和其他新闻样式做的一个菜单栏，栏中有各自的控制器，其中有4中展示样式’网易style’ ’搜狐style’ ’腾讯style1’ ’网易style2’ 。 Ruler - 尺子。 HUMSlider - HUMSlider是一款能够自动显示刻度记号的滑竿，滑动到某处，该处的刻度会自动上升，两边还能配置图像。支持代码或storyboard中实现。 JDSelectedDemo - 仿京东筛选菜单实现。 BTNavigationDropdownMenu - 下拉列表暨导航标题组件。简单、直接、易用 -swift。 3DTouchDemo - 详细介绍了每个参数的含义和3Dtouch的入口，保证包学包会。 3DTouchSample - 3D-Touch的功能分为两个部分：Shortcut和Preview。 SBShortcutMenuSimulator - 教你如何在模拟器上测试 3D Touch 功能! InceptionTouch.swift - 让没有 3D Touch 设备也有类似交互体验的 InceptionTouch 类（基于 UITextView 实现，支持日期，链接，电话号码，地址触摸响应）。 仿LOL滚动视图 - 仿LOL滚动视图。 答题选择切换页 - 将scrollview和tableview封装在一起，在初始化的时候简单的将数据带上，就可以一页一页的左右来回滑动。 SCTrelloNavigation - 类似trello的导航动效控件实现。 XTPaster - 贴纸功能出现在很多图片社交中, 就是图片上面贴图片, 对贴纸而言就是需要控制贴纸的位置,旋转,大小,如何使用。 RGCategoryView - 仿了个苏宁易购的分类页面。 TWControls.swift - 简单的开关和按钮控制器,使用闭包来执行由控件触发的操作。 Instructions.swift - 可定制嵌入式操作指引框架及演示。 LLPieCharts - LLPieCharts iOS 绘制饼图，教程。 BEMCheckBox - BEMCheckBox 是一个用于 iOS 应用上构建漂亮, 高度可定制化动画效果的复选框类库, 最低支持到 iOS 7 系统, 有多种不同风格的动画效果可供选择。 STPopup - 提供了一个可在 iPhone 和 iPad 上使用的具有 UINavigationController 弹出效果的 STPopupController 类, 并能在 Storyboard 上很好的工。 VBFPopFlatButton - 通过几条线段实现的非常Q萌的动画按钮效果。 ZSeatSelector - 电影院位置排座位。 CustomSearchBar - 自定义searchbar,类似于instagram的搜索框效果。 LNPopupController - AppleMusic式pop up，弹出是页面，可以上下拉动。 DGRunkeeperSwitch - 动画segment，节选器。 DynamicMaskSegmentSwitch - 一个简单有趣的 SegmentedControl 节选器。 SMSegmentView.swift - 高可定制化，既支持横向，也支持纵向布局的图文 Segment Control 组件，节选器。 YXFilmSelectView - 仿造时光网选择电影票的UI而开发的一个自定义View。 FJTagCollectionView - 标签（适配宽度）。 Gecco.Swift - Gecco.Swift 是一款支持对视图进行局部高亮的 Swift 库, 帮助 iOS 开发者快速创建产品的新手指导界面。 DFTimelineView - DFTimelineView仿微信朋友圈 时间轴。 AsyncDisplayKit.swift - AsyncDisplayKit.swift是 facebook的提供异步的界面高流畅性切换及更灵敏的响应框架。 SubtleVolume.swift - 更隐蔽的系统音量替代指示器。 InkKit.swift - 该类库帮助开发者绘制简单图形更容易。 HYBImageCliped - 可给任意继承UIView的控件添加任意多个圆角、可根据颜色生成图片且可带任意个圆角、给UIButton设置不同状态下的图片且可带任意圆角、给UIImageView设置任意图片，支持带圆角或者直接生成圆形。 SwiftSVG - 支持多种接口（String, NS/UIBezierPath, CAShapeLayer, and NS/UIView）绘制 SVG 类库。 LeeGo.swift - 带来更 声明式的，可配置的和易复用的UI开发方式，让UI开发变得像玩乐高积木一样简单直观，某种程度上取代ComponentKit。用 struct 和 enum 来构建你的整套 UI Caishen.swift - 简易、实用的付款输入及校验 UI 组件。 SwiftTweaks - 不用重新编译即可调整 UI 配置（按钮颜色、背景、动画延迟，简单布局等）的解决方案库。实现了发布生产版本前 UI 的简单配置，省却反复调试代码的麻烦。类似 OC 版 Facebook Tweats。 StackViewController - 方便 iOS 开发者使用 UIStackView 构建表单或其它静态内容视图。 LLBootstrapButton - Bootstrap 3.0扁平化风格按钮，自带图标，一句代码直接调用！ JMRoundedCorner - UIView设置不触发离屏渲染的圆角！ JMRoundedCornerSwift - swift版本：UIView设置不触发离屏渲染的圆角！ ======== 动画 Core Animation笔记，基本的使用方法 - Core Animation笔记，基本的使用方法：1.基本动画，2.多步动画，3.沿路径的动画，4.时间函数，5.动画组。 awesome-ios-animation - iOS Animation 主流炫酷动画框架(特效)收集整理 收集整理了下iOS平台下比较主流炫酷的几款动画框架。 awesome-animation - 在内的十多位童鞋们一起发起的一起动画开源组正式成立啦~Github组织名称：Animatious，这是我们第一期成员先前开源的一些动效库，我们的第一个合作开源项目正在紧锣密鼓的准备~请大家期待设计和代码的碰撞吧。 侧滑与右滑返回手势 SloppySwiper - iOS系统自带的UINavigationController要7.0才支持，但不过该手势只能从屏幕左侧边缘识别，如果要扩大到整个屏幕范围怎么办？配合一个SloppySwiper无需代码就可以轻松实现。此库支持iOS5.0以上版本（另外：Nav的title滑动不明显，本人写了2个类似的控件），SloppySwiper-demo ：代码方式与storyboard方式。 SCNavigation - UINavigation可以右滑返回，隐藏UINavigationBar。 UINavigationController-YRBackGesture - 支持右滑返回手势，标题栏不动。 GHSidebarNav - 现在比较流行使用侧开(侧滑)菜单设计。试了不少控件，感觉GHSidebarNav最成熟，尤其对纯代码创建的界面兼容性最好。在Storyboard中使用GHSidebarNav侧开菜单控件。 iOS-Slide-Menu - 能够类似Facebook和Path那样弹出左右边栏侧滑菜单,还支持手势。多种可以自定义的属性 (非常不错)。 ECSlidingViewController - 侧滑菜单。 JASidePanels - 侧滑菜单,有左右菜单，有pop功能，支持手势侧滑,本人使用中：简单。 animated-tab-bar - 让 Tabbar items能显示萌萌的动画。 tabbar图标动画 - tabbar上图标的动画实现，源码推荐说明。 SideMenu - swift实现，一款带动画效果可定制 Slide Menu，可以学习其动画实现思路。P.S. 对于Hamburger式菜单，虽然很常用，不过，苹果并不鼓励使用，甚至有开发小组对其弊病用自家上线应用前后数据对比进行了抨击。 RESideMenu - 侧开菜单，qq类似。 JHMenuTableViewDemo - 仿网易邮箱列表侧滑菜单。 SlideMenuView - 炫酷侧滑菜单布局框架，Android版本的一致实现。 QQConfiguration - swift，QQ-iPhone端框架，左侧菜单栏拖动手势。 KGFloatingDrawer - 侧滑菜单，qq类似，KyleGoddard/KGFloatingDrawer：一款适合于大屏手机或平板的浮动抽屉式导航界面组件。效果很赞- 侧开菜单，qq类似（与RESideMenu类似）。 AIFlatSwitch - 一款带平滑过渡动画的 Switch 组件类，类相同风格的 Menu/BackHamburgerButton,类似相同风格的 Menu/Closehamburger-button. JHChainableAnimations - 在应用中采用链式写出酷炫的动画效果, 使代码更加清晰易读，利用block实现的链式编程。 WXGSlideMenuDemo - 个简单实现侧拉（侧滑）菜单的小demo，供初学者共同学习、练习使用。 PKRevealController - PKRevealController是一个可以滑动的侧边栏菜单（可向左、向右或者同时向两侧），只需手指轻轻一点（或者按一下按钮，但是这样滑动时不够炫酷），这类控制的其他库，而PKRevealController是最棒的。安装简便，高度定制且对手势识别良好。可以当做一个标准控件用在iOS SDK中。 SwiftPages - 高可定制类似 Instagram 视图滑动切换功能类库。API 简单、易用。 FlipBoardNavigationController - FlipBoardNavigationController。 MMDrawerController - 最多人用的一个有关侧边“抽屉”导航框架，里面还有很多你意想不到的交互效果，侧滑。 UIWebView翻页返回效果 - UIWebView翻页返回效果（变通方法）。 LLSlideMenu - 一个弹性侧滑菜单,弹性动画原理借鉴该项目中阻尼函数实现。 FlowingMenu.swift - 菜单如此出场方式（橡皮筋弹跳式动画）好玩又有趣。 gif动画 UIImageView-PlayGIF - UIImageView-PlayGIF。 YLGIFImage - YLGIFImage。 YLGIFImage-Swift - YLGIFImage-Swift。 gifu.Swift - gifu.Swift高性能GIF显示类库。 droptogif - droptogif视频拖拽到应用窗口后自动转换为 GIF 动画（其转换进程动画效果也超赞）。 JWAnimatedImage.swift - JWAnimatedImage.swift集中了目前主流的 GIF 显示库(如 FLAnimatedImage,Gifu 等)的优点，进行重构，代码短小精悍。而且使用了新的 frame 提取算法。 SwiftyGif - 高性能 Gif 播放引擎。 PHImageKit.swift - 出自 Product Hunter 开发小组的带下载、缓存的 GIF 播放组件库。使用简单又方便。 其他动画 popping - popping是一个POP 使用实例工程 SinaMenuView - 用POP动画引擎写的Sina微博的Menu菜单。 MMTweenAnimation - facebook POP的自定义动画扩展(基于POPCustomAnimation) 提供10种函数式动画。 ZQLRotateMenu - 这是一个旋转视图的选择器。 CoolLoadAniamtion - 一个简单但是效果不错的loading动画。 SequenRotateAnimation - 一个简单的loading次序动画。 ParticlesLoadingView.swift - 通过 SpriteKit 内置工具粒子动画实现酷炫的可定制装载动画。loading动画。 SYAppStart - App启动插画的自定义过度。 VJDeviceSpecificMedia - 如何根据设备选择不同尺寸的图片 可以通过设置不同尺寸设备的LaunchImage，来使得App适配这些设备，要是在不同不同尺寸设备上使用不同大小的图片，则需要在代码中一一判断，然后加载。 RMParallax - RMParallax是一个app启动页引导开源项目，除了细微的翻页视差效果，描述文本的过渡也非常美观（版本新特性、导航页、引导页）。 ADo_GuideView - 转动的用户引导页(模仿网易bobo) 因为没有从app包里抓到@3x的图片,建议在iPhone5模拟器运行,保证效果~ （版本新特性、导航页、引导页）。 CoreNewFeatureVC - 版本新特性（引导页），1.封装并简化了版本新特性启动视图！2.添加了版本的本地缓存功能，3.集成简单，使用方便，没有耦合度，4.支持block回调（版本新特性、导航页、引导页）。 MZGuidePages - 自己写的通用导航页，可以直接引入工程使用，请参考案例（版本新特性、导航页、引导页）。 Wizardry.swift - 可重用的方法和框架实现向导式用户界面管理。（版本新特性、导航页、引导页）。 ABCIntroView - ABCIntroView是一个易于使用的入门类，让你到达主屏幕之前介绍你的应用程序（版本新特性、导航页、引导页）。 Spring - Spring是一个Swift编写的开源库，可简化Swift编写的iOS动画。支持shake、pop、morph、squeeze、wobble、swing、flipX、flipY、fall、squeezeLeft、squeezeRight以及squeezeDown等多种动画形式，用 IBDesignable 让使用者可以在 Xcode 中快速设置动画效果。 KYBezierBounceView - 手势控制贝塞尔曲线，取消手势贝塞尔曲线会有反弹效果。 cadisplaylinkanduibezierpath - CADisplayLink结合UIBezierPath的神奇妙用。 KYCuteView - 实现类似QQ消息拖拽消失的交互+GameCenter的浮动小球效果，分析。 KYWaterWaveView - 一个内置波浪动画的UIView，里面有鱼跳跃水溅起来的效果。 WaveLoadingView - iOS 唯一完美的波浪进度加载指示器，实现说明。 KYPingTransition - 实现圆圈放大放小的转场动画，可以根据自己的需要使用Paper中的弹性效果，有Material风格。 KYNewtonCradleAnimiation - 牛顿摆动画。 LayerPlayer - 一款全面展示核心动画 API 示例项目（上架应用）。包括 CALayer, CAScrollLayer, CATextLayer, AVPlayerLayer, CAGradientLayer, CAReplicatorLayer, CATiledLayer, CAShapeLayer, CAEAGLLayer, CATransformLayer, CAEmitterLayer 等使用的互动演示。 JGTransitionCollectionView - swift，基于集合视图扩展实现完成自动布局及单元项 Flip式动画效果（效果很赞）。组件使用方便、自然（只需设置集合视图数据源的标准方式即可）。 KYShareMenu - 带弹性动画的分享菜单。 Context-Menu.iOS - 可以为app的菜单添加漂亮的动画内容，可自定义icon，并可根据自己的喜好设计单元格和布局。 DeformationButton - 一个简单的变换形状动画按钮。 UnReadBubbleView - UnReadBubbleView是一个能够拖拽并拉长的气泡视图。拖拽到一定的长度会消失，可以通过系数设置来控制拖拽的长度。气泡也支持多种属性设置。 PPDragDropBadgeView - 实现了类似于QQ 5.0 水滴拖拽效果. 支持iOS 5.0+ ARC，气泡能够带有数字标识，同时支持消失block方法。消失时还带有消失效果动画。 GiftCard-Implementation - 购买的炫酷动画。 SDCycleScrollView - 无限循环自动图片轮播器(一步设置即可使用)。 HYBLoopScrollView - HYBLoopScrollView实现自动循环滚动，一般用于展示广告页。微信在贴纸宣传处就使用了轮播。 BuildAnInfiniteCarousel - 自己动手造无限循环图片轮播，教程。 iCarousel - iCarousel是一个类，它继承于UIView。用于简化实现各种类型的旋转木马(分页滚动视图），无限轮播 ，iOS开发之多图片无缝滚动组件封装与使用。 KIPageView - 无限循环PageView，横向TableView，无限轮播。 简单实用的无限循环轮播图 - 简单实用的无限循环轮播图 。 CPInfiniteBanner - 是一个循环播放的组件，可以左右无缝滑动,3个imageview实现。高效图片轮播，两个ImageView实现。 XTLoopScroll - 用两个 timer 三个重用的 view 实现无限循环 scrollView，1自动轮播 2点击监听回调当前图片 3手动滑动后重新计算轮播的开始时间, 良好的用户体验。 HotGirls - 卡片动画。 tispr-card-stack - swift 卡片风格动画切换组件及完整交互示例。 ZLSwipeableViewSwift - swift 卡片堆叠效果的实现（ZLSwipeableView)】可实现类似Tinder和Potluck应用程序的卡片堆叠效果，该项目基于ZLSwipeableView objective-c实现。1.自定义动画。2.自定义滑动切换。3.自定义方向。4.撤销。 Koloda - 基于卡片的 Tinder-style 动画效果示例。精细绝人。更赞的是额外附了详细开发教程 How We Built Tinder-Like Koloda Animation in Swift 网页链接 。Yalantis 出品动画程序款款精品。 QQPersonalInfoTransition - 仿照QQ的转场。 KYAnimatedPageControl - 除了滚动视图时PageControl会以动画的形式一起移动，点击目标页还可快速定位。支持两种样式：粘性小球和旋转方块。 KDIntroView - swift 动态介绍视图框架及演示。另外两个相似的类库是 RazzleDazzle和 Presentation，择需使用。 RazzleDazzle - 【IFTTT开源Swift编写的帧动画框架–RazzleDazzle】RazzleDazzle 是IFTTT开源的一个iOS帧动画框架，非常适用于APP初次使用时的介绍和引导信息。JazzHands是UIKit一个简单的关键帧基础动画框架，可通过手势、scrollview、KVO等控制动画，被IFTTT应用在IFTTT for iPhone上。 Presentation - 一个类似RazzleDazzle的框架。 FillableLoaders - 基于 CGPaths 可定制个性化填空式装载类库。附水波上涨式示例。 SXWaveAnimate - 实现非常美观的灌水动画。 LSPaomaView - 可循环滚动的较长文字，跑马灯，效果很好，一句话集成。 SIFloatingCollection_Swift - 可定制的 Apple Music 风格浮动形状动画组件及演示。 Cheetah - 易用、高可读链式动画类库。另一个类似类库是 DKChainableAnimationKit。 CKWaveCollectionViewTransition - swift， UICollectionViewController之间切换的动画。 TKSubmitTransition - 基于 UIButton 的登录加载、返回按钮转场动画组件及示例。 ARAnimation - ARAnimation 对 Core Animation 进行了封装, 帮助 iOS 开发者能更加便捷的在项目中使用动画。 CardsAnimationDemo - swift， 《使用 UICollectionView 实现的一个卡片动画》不是直接操作所有 UIView 和 CALayer 的 transform3D 属性来实现整个效果的，而是使用 UICollectionView 来完成所有的视图管理和实现。 TKRubberIndicator.swift - 一个很不错的 page control。 渐变特效文字 - 做了一个仿iPhone的移动滑块来解锁的渐变特效文字,还有一个类似ktv歌词显示的文字特效。 TTGEmojiRate.swift - TTGEmojiRate.swift以Emoji表情为基础绘图，Swift开源项目: TTGEmojiRate的实现。 HYAwesomeTransition - 模仿格瓦拉的转场效果。 CardAnimation.swift - CardAnimation 是国人开发的一个用 Swift 实现卡片垂直翻转动画的 Demo, 实现思路。 TaskSwitcherDemon - 是仿造iOS9的Task Switcher做出来的动画效果, 具体的实现思路可参照这篇文章。 CoreAnimationCode.swift - 提供了 “iOS Core Animation Advanced Techniques” 书籍中的代码实例, 方便开发者们进行参考学习。 UIViewXXYBoom.swift - 一个炫酷好玩的爆炸效果，如何实现这个效果。 ZLSwipeableViewSwift - ZLSwipeableView - ZLSwipeableViewSwift在Tinder and Potluck中的动画效果实现思路（连续卡片翻页效果），最贴心的是作者提供了OC和Swift两个版本来供开发者使用，非常丝滑顺畅的效果。 RYCuteView - 用UIBezierPath实现果冻效果。 教程 IBAnimatable.swift - 第三方开源库IBAnimatable可以帮助我们在Interface Builder和Swift Playground里面设计UI, 交互, 导航模式, 换场和动画。 circle-menu.swift - 动画效率很赞的圆形缩放菜单演示及类库。 BWWalkthrough.swift - BWWalkthrough.swift界面切换中加入灵动的动画效果。 hamburger-button.swift - hamburger-button.swift一个汉堡包动画关闭按钮。 HamburgerButton.swift - HamburgerButton.swift一个汉堡包动画返回按钮。 MDCSwipeToChooseView - MDCSwipeToChooseView翻牌子效果。 STLBGVideo - STLBGVideo让您的视图控制器的自定义backgroundvideo,实现说明1、实现说明2。 Advance.swift - 简单易用、功能强大的动画框架库。在手势交互、帧动画、自定义动画及仿真类型将是不错的选择。 PanelDemo - 仪表盘,模拟汽车的车速仪表盘,一些简单的数学知识。 HWAnimationTransition_Swift 、HWAnimationTransition_OC - 类似于格瓦拉启动页中的放大转场动画（objective-C &amp;&amp; Swift）。教程 MYBlurIntroductionView - 方便好用的引导类库，在App注册登录页面可以用到。 ZFCityGuides - 实现City Guides的动画效果，数字动态变化的动画效果。 NumberMorphView.swift - 可爱的数字补间（变身）动画类库。 DisplaySwitcher.swift - 两个集合视图在不同布局（平铺和列表）间平滑切换。Yalantis 出品。 DynamicButton.swift - 一套完整、且带动画过渡的图标按钮库。 TKDotSegment.swift - 是一个带有圆点动画的 segment。 LiquidLoader.swift - 液态加载动画的轻量级 UI 组件。 15DaysofAnimationsinSwift - 15DaysofAnimationsinSwift动画。 Interpolate.swift - 手势驱动交互式转场动画框架库。这个很专业，且非常有意思。 INPopoverController - OS X可自由定制的 Popover 视图。 WZXJianShuPopDemo - 仿简书、淘宝等等的View弹出效果，已封装好，使用简单。实现原理 PeekPop.swift - 3DTouch动画组件。 fantastic-ios-animation.swift - 基于 UI 组件类别分类，且带精彩动画效果的 iOS 组件库集合。 ======== 网络相关网络连接 AFNetworking - ASI不升级以后，最多人用的网络连接开源库，iOS网络编程之AFNetworking使用,iOS开发下载文件速度计算 , AFNetworking 3.0迁移指南 , AFNetworking2.0源码解析&lt;一&gt; 、AFNetworking2.0源码解析&lt;二&gt;、AFNetworking源码解析&lt;三&gt;、AFNetworking源码解析&lt;四&gt;。 Alamofire.swift - Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。Alamofire 最佳实践 AlamofireObjectMapper.swift - 将Alamofire JSON响应数据 转为swift对象。 RxAlamofire.swift - 为Alamofire提供函数响应式（FRP）调用接口,以优雅的方式使用Alamofire进行网络请求。 YTKNetwork - 是基于 AFNetworking 封装的 iOS网络库，提供了更高层次的网络访问抽象。相比AFNetworking，YTKNetwork提供了以下更高级的功能：按时间或版本号缓存网络请求内容、检查返回 JSON 内容的合法性、文件的断点续传、批量的网络请求发送、filter和插件机制等。 HYBNetworking - 基于AFN封装的网络库，可以通用。基于AFNetworking封装网络库说明目前已经提供了通用的GET/POST、上传、下载API等。 LxFTPRequest - 支持获取FTP服务器资源列表，下载/上传文件，创建/销毁ftp服务器文件/目录，以及下载断点续传，下载/上传进度，自动判断地址格式合法性跟踪等功能！国人开发，QQ：349124555。 HSDownloadManager - HSDownloadManager，下载音乐、视频、图片各种资源，支持多任务、断点下载。 MutableUploadDemo - 模拟需求：图文混编，要求用户选择图片后就上传，可选择多图，并行上传，用户确定提交后后台执行，必须全部图片上传完才能提交文字。 WTRequestCenter - 方便缓存的请求库，提供了方便的HTTP请求方法，传入请求url和参数，返回成功和失败的回调。 UIKit扩展提供了许多不错的方法，快速缓存图片，图片查看，缩放功能， 颜色创建，设备UUID，网页缓存，数据缓存等功能。 无需任何import和配置，目前实现了基础需求。 MMWormhole - Message passing between iOS apps and extensions 2个iOS设备之间通信。 socket.io-client-swift - WebSockect 客户端类库。开放的通讯协议，有利于构建强大地跨平台应用。 Transporter - swift， 短小、精悍、易用的多文件（并发或顺序）上传和下载传输库。还支持后台运行、传输进程跟踪、暂停/续传/取消/重试控制等功能。 STNetTaskQueue - STNetTaskQueue Objective-C 可扩展网络请求管理库。 CocoaAsyncSocket - 在iOS开发中使用socket，一般都是用第三方库AsyncSocket，不得不承认这个库确实很强大，使用教程。 AsyncSocket - AsyncSocket。 Socket通信 - 通过AsyncSocket封装的Socket通讯方法，简单实用，通俗易懂，初学者不能错过 。 GCDAsyncSocket - GCDAsyncSocket ， 不错的Demo。 Just - 小而美的 HTTP 类。功能简单、直接、完整且健壮性高– swift。 Future - 基于微框架设计思想的异步执行及结果响应类，代码即简单又干净– swift。 MZDownloadManager - 下载管理。 DVR - 针对网络请求的测试框架，超实用的工具。且支持 iOS, OSX, watchOS 全平台。 HFDownLoad - iOS开发网络篇之文件下载、大文件下载、断点下载:NSData方式、NSURLConnection方式、NSURLSession下载方式 下载方式具体的思路、区别见Blog 。 Pitaya.swift - Pitaya 是纯 Swift 写的 iOS 网络库，支持 Basic Authorization、SSL 钢钉、HTTP raw body / JSON body、快速文件上传等特性，并通过内置 JSONNeverDie 实现了对 JSON 的完全支持，开箱即用。 中文文档 starscream.swift - starscream.swift:WebSocket客户端类库。 SwiftNet.swift - 基于 RxSwift 和 Alamofire 的网络请求简易封装库。 Networking.Swift - 使用简单、功能惊喜，基于 NSURLSession 的网络封装。 图像获取 SDWebImage - SDWebImage 网络图片获取及缓存处理。 Kingfisher - 纯 Swift 实现的类 SDWebImage 库，实现了异步下载和缓存图片。 KFSwiftImageLoader - Swift，一个图像缓存加载库。 FastImageCache - FastImageCache 网络图片获取及缓存处理，iOS图片加载速度极限优化—FastImageCache解析。 EGOCache - 十分知名的第三方缓存类库，可以缓存NSString、UIImage、NSImage以及NSData。除此，如果还可以缓存任何一个实现了接口的对象。所有缓存的数据都可以自定义过期的时间，默认是1天。EGOCache 支持多线程（thread-safe），UITableView加载多张照片导致内存上涨的问题。 YYWebImage - 一个图片加载库 YYWebImage，支持 APNG、WebP、GIF 播放，支持渐进式图片加载，更高性能的缓存，更多图像处理方法，可以替代 SDWebImage 等开源库，相关文章。 网络聊天 XMPPFramework - XMPPFramework openfire聊天。 SXTheQQ - 用xmppFramework框架编写QQ程序，主要为了练习通讯的一些原理，界面比较渣 必须要先在本地配置好环境才可以运行。 环信 - 给开发者更稳定IM云功能。8200万用户考验，好用！（暂无及时语音、视频通话） 融云 - 即时通讯云服务提供商。（暂无及时语音、视频通话） 容联云通讯 - 提供基于互联网通话,视频会议,呼叫中心/IVR,IM等通讯服务。 chatsecure - 基于XMPP的iphone、android加密式聊天软件， chatsecure官网 。 iOS代码1，iOS代码2， iOS中文版。 MessageDisplayKit - 仿微信聊天，参考JSQMessagesViewController。（国人写） JSQMessagesViewController - 聊天 。 MessageKit.swift - 消息 UI 库 JSQMessagesViewController 的 Swift 版。 SunFlower - 环信聊天demo，比较多功能 。 BlueTalk蓝牙聊天 - 以MultipeerConnectivity为基础， 实现了简单的蓝牙聊天。 jchat-swift - 一个聊天 App,具有完备的即时通讯功能,JChat 的功能基于极光 JMessage SDK 来开发。 网络测试 Reachability - 苹果提供过一个Reachability类，用于检测网络状态。但是该类由于年代久远，并不支持ARC。该项目旨在提供一个苹果的Reachability类的替代品，支持ARC和block的使用方式。iOS网络监测如何区分2、3、4G Reachability.swift - 用于替换苹果的 Reachability 类，可以方便地检测当前是否联网以及具体的联网状态。 SimpleCarrie - 简单的运营商信息获取!。 NetReachability - swift2.0 简单的方法检查网络连接的连通性，提供通知中心集成接口。 NetworkEye - 一个网络调试库，可以监控App内HTTP请求并显示请求相关的详细信息，方便App开发的网络调试。 SimpleBS.swift - 网络测试小工具。 RealReachability - iOS下的实际网络连接状态检测，解决“如何判断设备是否真正连上互联网？而不是只有网络连接”的问题。 ======== 网页框架 Perfect.swift - Perfect 致力于 Swift 服务端应用，从打造专业应用服务器开始。Swift服务端编程：Perfect项目上手指南 swift-http - Swift HTTP Server，又一个 Swift 服务器，最大的亮点是支持 Docker 部署。 Swifton - Swifton是一个优秀的Swift on Rails 的Web Framework。 Taylor.swift - Taylor一个swift的轻量级的http服务器的库。 NetworkObjects.swift - NetworkObjects.swift轻量版HttpServer框架，跨平台解决方案。 vapor.swift - vapor.swift：swift的服务器库 vapor。 Kitura.swift - Kitura.swift：安装、使用步骤及文档最为清晰地来自 IBM Swift 开发组的开源 Web 服务器。此外，IBM 云服务 Bluemix 也为 Swift 打开通路。 ======== WebView与WKWebView MGTemplateEngine - MGTemplateEngine比较象 PHP 中的 Smarty、FreeMarker 和 Django的模版引擎，是一个轻量级的引擎，简单好用。只要设置很多不同的HMTL模版，就能轻松的实现一个View多种内容格式的显示，对于不熟悉HTML或者减轻 工作量而言，把这些工作让设计分担一下还是很好的，也比较容易实现设计想要的效果。 NJKWebViewProgress - 一个 UIWebView 的进度条接口库,UIWebView 本身是不提供进度条的。 GTMNSString-HTML - 谷歌开源的用于过滤HTML标签。 js-in-ios - webView与js的交互。 D3Generator - D3Generator根据dict字典生成对象。 适用webview和push推送时，根据后台传回字典实现动态跳转。实现说明 IOSCallJsOrJsCallIOS - IOSCallJsOrJsCallIOS：利用iOS7.0后出来的JavaScriptCore framework，webview与Js交互是常见的需求。OC版本与swift版本。《OC JavaScriptCore与js交互》,《Swift JavaScriptCore与js交互》。 WKWebViewTestDemo.swift - WKWebViewTestDemo：WKWebView新特性及JS交互,文章讲解。 React.swift - 启发自 React 的纯 Swift 函数版基于 UIKit 封装类库。这种结构是否似曾相识。 ======== Model JSONKit - JSONKit库是非常简单易用而且效率又比较高的，重要的JSONKit适用于ios 5.0以下的版本,使用JSONKit库来解析json文件，只需要下载JSONKit.h 和JSONKit.m添加到工程中；然后加入libz.dylib即可。 JSONModel - 解析服务器返回的Json数据的库,JSONModel源码解析一。 Mantle - Mantle主要用来将JSON数据模型化为OC对象, 大系统中使用。为什么选择Mantle。 RFJModel - RFJModel是一个IOS类库，可以将JSON字典自动装填到OBJC对象。相比JSONModel有一些非常好的特性，使用上也比较简单。 XMLDictionary - ios与mac os平台下xml与NSDictionary相互转化开源类库。 AEXML.swift - AEXML.swift简单又易于的XML解析类及示例。 MJExtension - 用于json转model进行使用，转换效率很高，使用也比较简单，只要前后台约定好，json直接就转成了model。 CFRuntime - “Swift 版的 MJExtension，运行时、反射与一键字典模型互转”。 DDModel - 快速搭建项目Model层，支持ORM映射关系，能从JSON/XML直接实例一个Model对象。支持SQLite本地数据持久化，封装了HTTP， 减少HTTP代码与UIViewController的代码耦合，支持Cache；类似RESTKit、Mantle的功能；使用该类库以后简化了网络层的开发工作，把更多的精力放在UI上面；目前只支持GET/POST方法的请求。使用到的第三方库有：1.SQLitePersistentObject; 2.JTObjectMapping; 3.AFNetworking; 4.XMLDictionary; protobuf-swift - Protocol Buffers 的 Swift 语言实现库。P.S. Protocol Buffers 是 Google 开源项目，主要功能是实现直接序列化结构化的对象数据，方便跨平台快速传递，开发者也可以直接修改 protobuf 中的数据。相比 XML 和 JSON，protobuf 解析更快，存储更小。 JSONCodable - 基于 Swift 2.0 新特性（Protocol Extensions and Error Handling）的JSON 解析类。 SwiftyJSON - 使Swift的JSON解析变得简单。 JSONNeverDie.swift - JSON 到 Model 类的自动映射工具。 Fuzi.swift - Swift实现的轻量快速的 XML/HTML 解析器。 SWXMLHash.swift - 易用的 XML 解析类库。非常实用的“轮子”。 YYModel - 高性能的 iOS JSON 模型框架。 TidyJSON.swift - TidyJSON.swift一款简单、易用、明了的 JSON 解析小类库。 PMJSON.swift - PMJSON.swift简单、实用、高效的 JSON 解析类库。 Unbox.swift - 极为易用、轻量，更少辅助代码的 JSON 解析类。 Wrap.swift - 方便、易用的对象转 JSON 类库。 ======== 通讯录 快速查找联系人 - 类似微信联系人搜索的界面,快速查找联系人,并支持点击查询结果 。 ======== 其他库 DateTimeKit - 一个超赞的时间处理的库，Joda-Time ！ 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。 SwiftDate - 特别完整、强大的日期时间操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性。 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。 iOS私有API - 私有API，绿色 == public，红色 == private，蓝色 == dylib。 iOS源代码 - iOS源代码。 libfacedetection - C++ 人脸识别 包含正面和多视角人脸检测两个算法.优点:速度快(OpenCV haar+adaboost的2-3倍), 准确度高 (FDDB非公开类评测排名第二），能估计人脸角度。 Slidden - 一个老外开源的开发自定义键盘的库，利用这个开源库，可以方便的配置键位、颜色以及键位对应的图片。 TPKeyboardAvoiding - 用户键盘弹出自动计算高度，进行屏幕滚动操作。 CDPMonitorKeyboard - CDPMonitorKeyboard封装,可以解决输入视图(例如textField,textView等)被键盘覆盖问题，并可设置高于键盘多少。 自动监听键盘高度 - 自动监听键盘高度，初始界面，输入框在屏幕最下方，当键盘出现时，输入框随即移动到键盘上方。 ZYKeyboardUtil - 全自动处理键盘遮挡事件，只需要一个Block，全自动处理任何多层嵌套复杂界面 因键盘升降 造成的输入控件遮挡问题。第三方键盘分次弹出问题 ,说明。 KeyboardToolBar - 从此不再担心键盘遮住输入框，文档。 SYKeyboardTextField - SYKeyboardTextField 是一个轻巧,简单,非侵入式的键盘附随输入框! 采用Swift编写。 IQKeyboardManager - 处理键盘事件强大的库，有OC和Swift版本，纯代码、Storyboard和Xib都适用。 BlocksKit - block框架，为 OC 常用类提供了强大的 Block 语法支持，使得编写 OC 代码变得舒适、快速、优雅。 KVOController - 在项目中有使用 KVO ，那么 KVOController 绝对是个好选择。它是 facebook 开源的一个 KVO 增强框架。 appirater - 用于提醒用户给你的 APP 打分的工具。 MotionKitr - 为核心运动框架（The Core Motion framework）提供友好的类库封装，以更方便使用三轴陀螺仪和加速感应器特性。 Review Monitor - 第一时间自动推送 Apple Store 的用户评论到你的邮件箱或者 Slack，第一时间跟进用户反馈，打造优秀 App 必备工具！类似的有：App annie 的类似功能。 WBWebViewConsole - 类似微博iPhone客户端的 “调试选项” 吗？把其中的 “内置浏览器网页调试” 开源在 Github 上了。 ios-good-practices - ios-good-practices iOS 开发最佳实践。 iOS开发最佳实践 - iOS 开发最佳实践 – 中文。 TodayExtensionSharingDefaults - TodayExtensionSharingDefaults是一个iOS 8 Today扩展示例，可以使用NSUserDefaults与其containing app分享数据。 原生实现扫描二维码条码 - iOS原生实现扫描二维码条码. ZFScan - 仿微信 二维码/条形码 扫描。 QRCodeReader.swift - QRCodeReader.swift一款简单的 QR 二维码阅读组件及示例，提供前后相机切换功能。 swiftScan - 具有丰富功能的二维码扫描组件及类库。对应OC版本LBXScan。 QR-Code-Generator.swift - 生成二维码。 QRCatcher - 一个简洁美观的二维码扫描应用， iOS学习：AVFoundation 视频流处理–二维码扫描。 MQRCodeReaderViewController - 二维码扫描控件, UI 做了优化, 仿造微信, 直接拖进项目就可使用。 Parsimmon - swift，小而美的语言学类库封装工具包。提供分词、标记词性、词形归并、朴素贝页斯分类、决策树等自然语言分析小工具。P.S. 英语分词效果好于中文，感兴趣的同学可以针对中文做一些优化开发。参考译文 NSHipster - NSLinguistic​Tagger。 Password-keyboard - 随机变换数字位置的密码键盘。 模仿银行类应用在付款时输入的随机密码键盘。 MKMapView-Extension - 这是关于 MKMapView 写的一个基于swift的扩展，可以扩展 MKMapView 的相关功能，减少复用代码量。 SemverKit - 针对符合『语义化版本规范 2.0.0』版本号的解析、比较运算类库。不仅支持 Major, Minor, Patch，还支持 Alpha 和 Beta 预发布版本，以及相应地递增运算扩展。 SwiftValidator - 基于规则的输入验证类库。项目良好的面向对象设计思想，使规则的扩展及自定义非常方便。更专业的规则引擎（甚至是基于自然语言的规则配置）解决方案，比如：开源的 Drools，商用的 ILOG 等。 Validated.swift - Validated.swift通过值验证或限定，快速定义新类型的微类库（约50行代码）。 Tesseract-OCR-iOS - 有关OCR文字识别项目。 Screenotate - 支持 OCR 文字识别的载屏笔记 Mac 完整应用。 SwiftOCR - 识别字母和数字相较于 Tesseract 有压倒性优势（附图）的 OCR 类库。 cocoacats - 【分类汇总】里面收集了 iOS 中常用的分类文件，一直在更新。 Olla4iOS - 过去积累的一些方便复用的类和方法，还在整理中。 DKNightVersion - 用最快的方式给你的应用加上夜间和白天的切换效果。 TouchVisualizer - 实用的多点触摸可视化组件。扩展并作用于 UIWindows，结构上提供了简单地针对触摸显示定制，比如触摸点的颜色。 RegexKitLite - 用来处理正则表达式。 Regex.swift - 实用的正则表达式微框架类库。 PySwiftyRegex.swift - 像Python一样简洁高效地作正则处理。 PhoneNumberKit.swift - 解析、格式化及验证国际电话号码工具库（相当于 Google 的 libphonenumber 库的 Swift 版本）。 XcodeServerSDK - 非官方 Xcode Server SDK 封装库。 P.S. 该 SDK 分离自之前推荐的由该作者开发的自动测试框架 Buildasaur。 BFKit-Swift - BFKit-Swift 这套工具库可以提高应用开发效率。 CKSIncrementalStore - 基于 CloudKit 服务器实现多终端数据同步。 SwiftSequence - 简洁、灵活、多变的操作 SequenceType 的类库（基于微框架（μframework）设计思想）。 IDNFeedParser - 一个简单易用的Rss解析库。 CoreUmeng - 简单：友盟分享封装。 openshare - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。 Swifternalization - 一套实用的本地化工具库。使用教程及 API 文档完整。值得收入项目的“轮子”。 Localize-Swift - Localize-Swift一款开发者不可或缺的国际化及本地化字符串框架支持类库。同样地，使用简单、直观又方便。 apous - 一款有趣的 Swift 应用 － 让 Swift 成为脚本语言。 Mirror - 通过反射（Refection）实现镜像对象封装库。从而可以更轻松获取（或输出）对象属性名、类型及值变量。 Proposer - Proposer 用单个 API 处理 iOS 上的权限请求，以便使用前确认可访问“相册”、“相机”、“麦克风”、“通讯录”或“用户位置”。 PermissionScope - 用这个库可以在询问用户前，就告知用户所需的系统权限，为用户带来更好的体验。接受度更高—&gt;更多活跃用户-&gt;更高的留存率-&gt;数据更好-&gt;下载率更高。 LocationManager - 地理位置管理封装库， CoreLocation使用起来还是比较麻烦的，需要授权，判断系统版本等等，所以推荐使用第三方框架LocationManager，使用Block，十分简单！iOS-CoreLocation：无论你在哪里，我都要找到你！ 。 pangu.objective-c - 有多种语言实现版本～ Pangu.Objective-C：格式化中英文之间的空格（OC）。 objection - 一个轻量级的依赖注入框架Objection。 ControlOrientation - 如何用代码控制以不同屏幕方向打开新页面【iOS】， 使用说明。 iRate - 问卷调查。 GameCenterManager - 在iOS上管理GameCenter vanilla并不算难，但是有了这个库会更简单也更快。好上加好不是更好么。 SlackTextViewController - 用作极佳、定制的文本输入控制时，自适应文本区域，手势识别、自动填充、多媒体合并，快速drop-in解决方案。 IAPHelper - 应用内付费给我们提供了很多样本代码，而这个库丢掉了那些代码，将金钱交易相关的大多通用任务做了简单的封装。 IAPDemo - 应用内支付IAP全部流程, 教程。 SwiftyStoreKit - 一款轻量级的 iOS 应用内购买框架。 TAPromotee - 交叉推广应用是你可以免费实现的最佳市场推广策略之一。使用这个库做起来非常简单，不用都不可能——将TAPromotee加入你的podfile中，免费配置与享受更多下载吧。 DownloadFontOnline - 实现了在线下载一些字体的功能，不用在工程中导入字体库，下载的字体也不会保存在你的应用中，所以可以放心使用。修复了一下崩溃的bug。 STClock - 仿锤子时钟。 GitUp - GitUp是一个可视化的Git客户端，能够实时的进行编辑、合并、回滚等多种操作，更多功能，请下载体验。 获取联系人信息，通讯录 - 获取联系人信息，通讯录。 Universal-Jump-ViewController - 根据规则跳转到指定的界面(runtime实用篇一)。 Device-swift - 可以非常方便的获取设备型号和屏幕尺寸，实现起来难度不大，大家可以学习一下源码。 RunKit.swift - 针对 GCD 框架的一个友好访问封装库（支持方法链式调用）。 Plum-O-Meter - swift 称重应用， (3D Touch之我见)[http://swift.gg/2015/10/23/3d-touch-impressions-and-thoughts/]。 打开自带地图、百度地图、腾讯地图 - 打开自带地图、百度地图、腾讯地图。 MapManager.swift - MapManager.swift地图及路径管理封装库。 eviltransform.swift - eviltransform.swift解决国内GPS地图坐标偏移问题,它将政府加密过的GCJ-02坐标，转成世界通用的WGS-84坐标。 batteryLevelTest - runtime精准获取电池电量，文档。 openshare - 不用官方SDK，利用社交软件移动客户端(微信/QQ/微博/人人/支付宝)分享/登录/支付。 DateTools - 用于提高Objective-C中日期和时间相关操作的效率。灵感来源于 DateTime和Time Period Library。 DDSlackFeedback - 用这个接口实现的摇一摇上传文字或者截屏反馈到你的 Slack channel，特别适合测试 app 的时候用，集成也很简单。 BabyBluetooth - 是一个非常容易使用的蓝牙库, 适用于 iOS 和 Mac OS, 基于原生 CoreBluetooth 框架封装, 可以帮开发者们更简单地使用 CoreBluetooth API, 使用链式方法体, 使得代码更简洁、优雅。iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍 RxBluetoothKit.swift - 基于 RxSwift 的蓝牙通讯库。 BluetoothKit.swift - 基于 CoreBluetooth API 实现iOS/OS X 设备间蓝牙通讯封装类库。功能强大、传输稳定，示例完整，很酷。 CoreDataStack.swift - 存储栈。 SYNQueue.swift - 执行队列类库。 DDMathParser.swift - 相比 NSExpression 和 GCMathPaser，功能更强大的数学表达式解析器。 RateLimit.swift - 简单、实用定时执行任务工具类库。 iOS-Categories - 收集了许多有助于开发的iOS扩展,各种category分类。 YYCategories - 功能丰富的 Category 类型工具库。 YYAsyncLayers - iOS 异步绘制与显示的工具。 YYDispatchQueuePool - iOS 全局并发队列管理工具。 YYKeyboardManager - iOS 键盘监听管理工具。 shoppingCart.swift - swift的购物车demo，采用纯代码UI，autolayout自动布局，core animation动画效果。 ShoppingCartExample - 购物车最多star demo。 shoppingCart1 - 仿美团购物车效果。 ZFShoppingCart - 仿照美团外卖加入购物车的动态效果。 shoppingCart2 - 一个购物车demo，包含购物车动画效果、购物车多选、删除、编辑等功能。 shoppingCart-demo - 一个简单的购物车功能实现demo。 OC_ShoppingCart_Demo - 简单实现购物车常见的筛选功能。 XNQShoppingTrolley - 购物车功能 基本功能仿照淘宝的购物车。 ShoppingDemo - iOS仿美团外卖饿了吗App点餐动画,购物车。 shopCarDemobyCX - shopCarDemobyCX一个简易购物车效果，最重要的是可以分单结算，分单个商品结算，代理是主要技术。 MVVM KVO购物车 - MVVM KVO 购物车(一处计算总价钱)。 BHBDrawBoarderDemo车 - 仿写猿题库练题画板功能，没有用drawRect，而是用CAShapeLayer来做画板绘画，特别省内存，赞1个，实现分析。 SwiftyGPIO - 通过 Swift 语言去控制基于 Linux 主板（比如：C.H.I.P. 和 树莓派） 的 GPIO（General Purpose Input Output ），去完成简单的工控功能（比如 LED 灯的显示）。 Scale.swifty - 简单直观的单位计算及换算类库（支持常用计量类型）。代码简洁性、直观性杠杠的。 swift-pons - 面向协议的不受长度限制数字类型及数学计算扩充类库。用它做一款最牛科学计算器妥妥地。 SwiftString - SwiftString:String 扩展功能很丰富（无论格式化杂乱字符串，还是子串查找，亦或是格式转换都很强大）。 jrswizzle - runtime实现的Method Swizzling第三方框架。 FileBrowser.swift - FileBrowser.swift 一款开源的 iOS 文件浏览器, 支持文件搜索, 文件预览和 3D touch 功能。 AFBrushBoard.swift - AFBrushBoard.swift基于swift的毛笔画板Demo。包含多阶贝塞尔曲线的抽取、模拟画笔速度等算法。 SwiftForms - SwiftForms表单递交库，快速开发利器。 Design-Patterns-In-Swift - Design-Patterns-In-Swift如何使用常用设计模式及示例。 Dollar.swift - Dollar.swift是一个Swift库，无需扩展任何内置对象就为Swift语言提供有效的函数式编程辅助方法，类似于Lo-Dash或JavaScript中的Underscore。而Cent则是通过扩展功能来扩展Swift中的特定对象类型。 Underscore.swift - 函数式编程辅助方法，可靠性上压倒目标对手是 Dollar。 PathKit.swift - PathKit.swift小而美的路径管理类。 Surge.swift - Surge.swift基于苹果Accelerate高性能计算数学框架封装库。 Async.swift - Async.swift简洁的后台执行代码的异步封装库。 AlecrimAsyncKit.swift - 一款很优雅的异步执行框架库。 BrightFutures.swift - BrightFutures.swift漫长或复杂计算由独立线程异步来完成。 Euler.swift - Euler.swift直观、简洁的数学表达式∛27÷3+∑[3,1,2]。 Siren.swift - Siren.swift当应用更新时，通知用户并提供App Store链接。 Demo_ProductDetailScroll - Demo_ProductDetailScroll ：仿京东商品详情滚动翻页。 BGTaobao - ios 高仿淘宝/京东详情页 - 集合各种测试框架。 CartDemo - CartDemo比较完整的购物车界面及逻辑,商品展示,多选,单选,全选及滑动删除,价格计算。 JLRoutes - JLRoutes好用的URL map库，它的作用是让按钮的点击像网页里的链接一样，只是触发了某个URL，而没有像pushViewController这样的行为，实现解耦。 BTree.swift - BTree.swift:相对于标准集合类型具有更优执行性能的基于B-Tree的优化集合类型实现类库。 PromiseKit - 同时支持 Swift 及 Objective-C 的 Promise 类库，异步编程类库 提供了很多实用的异步函数 让异步编程更简单。 ZipArchive - 适用iOS和OS X的解压库。 Duration.swift - 测量代码片段执行时间工具类库（Swift）。 Bolts-Swift - 全平台（所有支持 Swift 的设备）任务管理 futures/promises 异步实现类库。 BCColor.swift - 轻量而强大的颜色处理库，纯 Swift 版。 支持从图片拾取一套主题色，类似AppleMusic；支持图片黑白化、对颜色的加深和变浅、生成渐变颜色等。 AIToolbox.swift - AI 主流模块集工具箱库。其中涉及 AI 知识实在广阔又高端。 HWChangeFont - 利用runtime一键改变字体。教程。 RuntimeSummary - 一个集合了常用 Objective-C Runtime 使用方法的 Playground。 EZSwiftExtensions - 对Swift标准库， Foundation， UIKit 提供了很多高级扩展函数。 TempiBeatDetection.swift - Swift 语言写的音乐节奏节拍检测库。 Venice.swift - 让 Swift 3 提前支持协程（Coroutine）。P.S. Chris 曾答疑过，Coroutine 不在 Swift 3 支持范围中，将在更晚时候讨论语言级支持。 FlatBuffersSwift - Swift 版 FlatBuffers 实现类库。P.S. FlatBuffers 是跨平台、高效，提供了 C++/Java 接口的序列化开源工具库。 Lyft.swift - 一套面向 Lyft 开发者的 Swift API 类库。 Up-Down.swift - Up-Down.swift:在 OS X 菜单栏上实时显示网络上传和下载速度小工具。 Algorithm.swift - 算法和概率模型工具集。（作者 Daniel Dahan） GCDThrottle - 限制频率过高的调用GCD多线程。 Spots.swift - 一套为了加速开发效率、将 view models 采用 JSON 格式存储于云端 view controller 框架库。 ======== 数据库 FMDB - sqlite的工具， 多线程FMDatabaseQueue实例，FMDB数据库的使用演示和封装工具类，基于fmdb 的基本操作 通过 fmdb 进行的数据库的 基本操作(增删改查 )查找是使用 UISearchBar 和UISearchDisplayController 进行混合使用。 GXDatabaseUtils - 在FMDB基础上的工具。 realm-cocoa - Realm是一个真正为移动设备打造的数据库，同时支持Objective-C和Swfit。Realm宣称其相比Sqlite，在移动设备上有着更好的性能表现,官方中文 ，iOS：选择 Realm 而不是 CoreData, 使用 Realm 和 Swift 创建 ToDo 应用。 RealmIncrementalStore.swift - RealmIncrementalStore.swift:集 Realm 数据库和 CoreData 对象模型两者优势的 Realm 数据库访问类库。 Breeze - 用Swift写的一个轻量级的CoreData管理工具，并且还支持iCloud 。 AlecrimCoreData - Swift，更容易地访问 CoreData 对象封装类库。除了 CRUD，还提供指针定位，强大的排序、筛选，异步数据获取，以及独立线程后台存取数据。 CoreStore - Core Data 管理类库。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。 MagicalRecord - CoreData第一库，MagicalRecord就像是给Core Data提供了一层外包装，隐藏掉所有不相关的东西。 其中事务管理及查询是其比较大的亮点，整套 API 功能完整。 mogenerator - mogenerator为你定义了的Core Data生成默认的数据类。与xCode不一样的是(xCode一个Entity只生成一个NSManagedObject的子类)，mogenerator会为每一个Entity生成两个类。一个为机器准备，一个为人类准备。为机器准备的类一直去匹配data model。为人类准备的类就给你轻松愉快的去修改和保存。 Presentation - 重量级好项目 Presentation，它可以方便你制作定制的动画式教程、Release Notes、个性化演讲稿等。 CoreValue - Swift 2 版 Core Data 封装库。相比另外两个 SwiftRecord和 CoreStore更轻量。 SQLCipher - SQLCipher使用256-bit AES加密，SQLCipher分为收费版本和免费版本。官方教程， 加密你的SQLite - 各种sqlite数据库加密介绍。 SQLCipherDemo下载 。 SQLite.swift - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。 fluent.swift - 纯swift实现的类型安全的SQLite3封装，数据存储和JSON解析是永恒的话题。 swiftydb - 是一个第三方 SQLite 工具，能够大大简化数据库操作。如果你不放心 Realm，那就用 SwiftyDB 吧。使用教程、demo Graph.swift - 设计新颖、使用简单基于 Core Data 的数据驱动框架库 （作者Daniel Dahan）。 ======== 缓存处理 YTKKeyValueStore - Key-Value存储工具类，说明。 TMCache - TMCache 是 Tumblr 开源的一个基于 key/value 的数据缓存类库,可以用于缓存一些临时数据或者需要频繁加载的数据,比如某些下载的数据或者一些临时处理结果。 JLKeychain - 快捷使用keychain存储数据的类，使keychain像NSUserDefaults一样工作。 sskeychain - SSKeyChains对苹果安全框架API进行了简单封装,支持对存储在钥匙串中密码、账户进行访问,包括读取、删除和设置。 KeychainAccess - 管理Keychain接入的小助手。 YYCache - 高性能的 iOS 缓存框架。 RuntimeDemo - runtime自动归档/解档,源码分析。 Cache.swift - 一款简单、易用的缓存库。支持 MemoryCache, DiskCache 以及前两项组合的 MultiCache。 Cache.swift - Nothing but Cache。 AwesomeCache.swift - Delightful on-disk cache (written in Swift)。 Track.swift - 基于文件系统和链表的 Cache。分为 Disk 和 Memory，线程安全，支持 LRU 淘汰，性能尚可。 ======== PDF Reader - Reader可提供类似iBooks的文档导航，支持屏幕旋转和所有方向，并通过密码保护加密PDF文件，支持PDF链接和旋转页面。 ======== 图像浏览及处理 FLAnimatedImage - gif播放处理的工具。 CLImageEditor - 超强的图片编辑库，快速帮你实现旋转，防缩，滤镜等等一系列麻烦的事情。 ios-image-filters - 图像滤镜，库比较旧了，很容易崩溃。 XBImageFilters - 图像滤镜。 MWPhotoBrowser - 一个非常不错的照片浏览器，在github的star接近3000个，解决MWPhotoBrowser中的SDWebImage加载大图导致的内存警告问题。 core-image-explorer - Core Image 滤镜处理图片– swift ，Core Image 介绍。 CoreImageShop - CoreImageShop图片滤镜处理– Mac app that let you create a complete Core Image Filter usable on iOS using SCRecorder。 GPUImage - 处理图片效果。 GPUImage2.swift - Swift 版基于 GPU 图像和视频处理框架库。 RSKImageCropper - 适用于iOS的图片裁剪器，类似Contacts app，可上下左右移动图片选取最合适的区域。 WZRecyclePhotoStackView - 删除照片交互–WZRecyclePhotoStackView，就是模拟生活中是删除或保留犹豫不决的情形而产生的。 在上滑，下滑的部分，借鉴了TinderSimpleSwipeCards。 TimingFunctionEditor - TimingFunctionEditor用swift编写， 贝塞尔曲线编辑器，编辑后可以预览或拷贝代码片段直接使用。P.S. 该项目采用更简单的依赖管理器。 Carthage ，而非常用的 CocoaPods。Carthage介绍中文。 AAFaceDetection - AAFaceDetection–swift，简单、实用的面部识别封装库。虽然该技术从 iOS 5 发展，不过真正有趣的应用还不多。 PhotoTweaks - 这个库挺赞的，正好是对图像操作的。 Concorde - swift, Concorde, 一个可用于下载和解码渐进式 JPEG 的库, 可用来改善应用的用户体验。 ZoomTransition - swift, 通过手势操控图片的放大、缩小、旋转等自由变化效果的组件及示例。 AFImageHelper - swift,一套针对 UIImage 和 UIImageView 的实用扩展库，功能包含填色和渐变、裁剪、缩放以及具有缓存机制的在线图片获取。 PinterestSwift - swift,Pinterest 风格图片缩放、切换示例。 KYElegantPhotoGallery - 一个优雅的图片浏览库。 SDPhotoBrowser - 仿新浪动感图片浏览器,非常简单易用的图片浏览器，模仿微博图片浏览器动感效果，综合了图片展示和存储等多项功能。 HZPhotoBrowser - 一个类似于新浪微博图片浏览器的框架（支持显示和隐藏动画；支持双击缩放，手势放大缩小；支持图片存储；支持网络加载gif图片，长图滚动浏览；支持横竖屏显示）。 PhotoStackView-Swift - PhotoStackView——照片叠放视图，使用说明。 MarkingMenu - 基于手势、类似 Autodesk Maya 风格标记菜单及图片渲染。 SXPhotoShow - UICollectionViewFlowLayout流水布局 是当下collectionView中常用且普通的布局方式。本代码也写了三种好看的布局，其中LineLayout和流水布局有很大的相同点就直接继承UICollectionViewFlowLayout，然后StackLayout，CircleLayout这两种都是直接继承自最原始的UICollectionViewLayout 布局方案。 PictureWatermark - 主要实现了给图片加文字以及图片水印的功能，已封装成了UIImage的类别，方便使用。 自定义宽高比的相册框 拍照 - 取出照片时 弹出自定义view。在这个自定义view上创建一个需要的相框大小的view层 把取出的图片赋值给UIImageView按缩放添加到这个层上。对uiimageView添加捏合、移动 手势。添加按钮 选取，最后根据位移和缩放比例 裁剪image。 LGPhotoBrowser - LGPhotoBrowser:相册选择/浏览器/照相机（仿微信）,包含三个模块：照片浏览器，相册选择器，照相机。 PhotoBrowser - 一个简单的好用的的图片浏览器。 BeautyHour - 完整应用，功能与“美图秀秀”雷同。 MPParallaxView - 是用 Swift 写的类似 Apple TV Parallax 效果的视图。 StitchingImage - 仿微信群组封面拼接控件, 直接拖进项目就可使用，教程。 SDECollectionViewAlbumTransition - 用自定义的 push 和 pop 实现了有趣的 iOS 相册翻开动画效果。 SKPhotoBrowser.swift - swift中规中矩、实用的图片浏览类库。示例也很完整。 Nuke.swift - 完整、强大、实用的图片管理类库。主要功能包括可定制装载，缓存，滤镜及尺寸变换。 DNImagePicker - 类似wechat的图片选择。 CocoaPicker - 仿QQ图片选择器（OC）。 JFImagePickerController - vvebo作者：多选照片、预览已选照片、针对超大图片优化。 VIPhotoView - 图片浏览，用于展示图片的工具类，因为是个 View，所以你可以放在任何地方显示。支持旋转，双击指定位置放大等。 AGImagePickerController - 是一个图片选择器，支持图片多选，支持大图横滑预览，支持放大预览，支持横竖屏，支持所有的iOS设备。 YYImage - 功能强大的 iOS 图像框架，支持大部分动画图像、静态图像的播放/编码/解码。 PagingView.swift - 注重细节的自动布局分页视图组件。 TZImagePickerController - 一个支持多选、选原图和视频的图片选择器，同时有预览功能，适配了iOS6789系统。教程. 更换头像 - 用户选取从相机或者相册获取图片，并且显示在View上。 DouBanMeinv.swift - 抓取豆瓣美女图片，瀑布流显示。 ZZPhotoKit - 基于Photos和AVFoundation框架开源，相册多选与相机连拍。 SwViewCapture.swift - SwViewCapture.swift一个用起来还不错的iOS截图库.(支持截取所有内容, 适用于所有ScrollView组成的视图, 包括WebView)。 BeautifyFaceDemo - 一个基于 GPUImage 的实时直播磨皮滤镜的开源实现,主要功能脸部去斑磨皮！ YUCIHighPassSkinSmoothing - 磨皮滤镜！ Filterpedia.swift - 强大的图片滤镜库演示。 YUGPUImageHighPassSkinSmoothing - 一个基于 GPUImage 的磨皮滤镜！ preview-transition.swift - 通过向导式代码实现步骤，实现完整、自然流畅的图片预览及转场功能。 CartoonEyes.swift - 前置摄像头捕获图像后，采用 Core Image 脸部识别 CIDetector 和漫画效果滤镜复合出卡通效果眼睛。 YLFaceuDemo - 在直播应用中添加Faceu贴纸效果。Faceu贴纸效果其实就是在人脸上贴一些图片，同时这些图片是跟随着人脸的位置改变的。说明 ======== 摄像照相视频音频处理 SCRecorder - SCRecorder 短视频录制。 VideoPushDemo - 视频剪辑 视频特效制作1 视频特效制作2。 LLSimpleCamera - A simple, customizable camera control for iOS， 摄像头。 EZAudio - EZAudio 是一个 iOS 和 OSX 上简单易用的音频框架，根据音量实时显示波形图，基于Core Audio，适合实时低延迟音频处理，非常直观。中文介绍,官网。 ffmpeg - ffmpeg官网，FFmpeg在iOS上完美编译。 VLC - VCL官网,VLC for iOS 2.7.2 source code。 kxmovie - 使用ffmpeg的影片播放器，修改说明， 修改代码，基于FFmpeg的kxMoive艰难的编译运行。 ijkplayer - B站开源的视频播放器，支持Android和iOS。 iOS中集成ijkplayer视频直播框架。 StreamingKit - StreamingKit流媒体音乐播放器。 FreeStreamer - FreeStreamer流媒体音乐播放器，cpu占用非常小。 DOUAudioStreamer - DOUAudioStreamer豆瓣的音乐流媒体播放器。 fmpro - 电台播放器，支持锁屏歌词，支持基本播放流程，歌词展示，后台锁屏播放和控制以及锁屏后封面+歌词，fmpro_R 。 IPDFCameraViewController - 支持相机定焦拍摄、滤镜、闪光、实时边框检测以及透视矫正功能，并有简单易用的API。 SCRecorder - 酷似 Instagram/Vine 的音频/视频摄像记录器，以 Objective-C 为基础的过滤器框架。 你可以做很多如下的操作：记录多个视频录像片段。删除任何你不想要的记录段。可以使用任何视频播放器播放片段。保存的记录可以在序列化的 NSDictionary 中使用。（在 NSUserDefaults 的中操作）添加使用 Core Image 的视频滤波器。可自由选择你需要的 parameters 合并和导出视频。 Cool-iOS-Camera - Cool-iOS-Camera。 FastttCamera - FastttCamera 快速照相。 ICGVideoTrimmer - ICGVideoTrimmer提供提供视频剪切的视图（类似系统相册中浏览视频时顶部那个条状视图）。左右两个边界选择器还能够自定义。 IOS录音和播放功能demo - 比较完整的ios录音和播放功能的实现。 CameraManager - 相机管理封装类库。看着极好用的样子—-swift。 MCAudioInputQueue - 简易录音类，基于AudioQueue的。 DraggableYoutubeFloatingVideo - 展示像类似Youtube移动应用的那种浏览视频的效果，当点击某视频时能够从右下方弹出一个界面，并且该界面能够通过手势，再次收缩在右下方并继续播放。这是通过AutoLayout设计实现。 amr - 做即时通讯的音频处理，录音文件是m4a，便于web端的音频播放。 边录音边转码 - 一边录音，一边将录制成的 wav 格式音频文件转码成 amr 音频格式。只支持真机运行调试。 FSVoiceBubble - 一个轻量级播放录音音频的气泡：1.支持短时间的音频播放（支持网络音频）；2.播放时的声波动画；3.自定义包括声波的颜色，气泡的背景等。 KRVideoPlayer - 类似Weico的播放器，支持竖屏模式下全屏播放。 自定义视频播放器AVPlayer - 利用系统类AVPlayer实现完全自定义视频播放器，显示播放时间，缓存等功能。代码清晰，注释详细。 VideoBeautify - 功能酷似美拍,秒拍等应用的源码：对视频进行各种美化处理，采用主题形式进行分类，内含各种滤镜，动画特效和音效等。 HTY360Player - 是一款提供在 iOS 中使用 360 度无死角拖拽视频进行不同角度播放的视频播放器。 ALCameraViewController - ALCameraViewController 摄像头视图控制器（含可定制照片选择器，图片简单裁切功能）及演示。 recordDemo.swift - 一个Swift语言实现直接可以用的录音Demo，实现说明。 Swift-Radio-Pro - 集成 LastFM 的专业电台应用（基于 Swift 2.0）。 Eleven - Eleven Player - 一个使用 FFmpeg 实现的简单强大的 iOS 开源播放器。 mobileplayer-ios.swift - 很不错的高度可定制播放器项目。 iFrameExtractor - 开源视频播放器， ffmpeg在iOS的使用-iFrameExtractor源码解析，文章。 Periscope-VideoViewController.swift - 简洁实用的视频快进、倒带控制视图类库。 AudioKit.swift - 音频合成、加工及分析平台（支持 iOS、OS X、tvOS）框架库。无论其易用性，还是功能性及专业性。 MusicPlayert - MusicPlayert本地音乐播放+音乐信息显示+在线歌词搜索显示（千千静听服务器）。 MusicPlayert - MusicPlayert音乐播放器，用reveal可以查看层次关系，主要实现了歌词的同步显示。 音乐播放器 - 音乐播放器：显示歌词。 TBPlayer - 视频变下变播，把播放器播放过的数据流缓存到本地，支持拖动。采用avplayer。实现说明 WMPlayer - WMPlayer视频播放器，AVPlayer的封装，继承UIView，想怎么玩就怎么玩。支持播放mp4、m3u8、3gp、mov，网络和本地视频同时支持。全屏和小屏播放同时支持。 cell中播放视频，全屏小屏切换自如。 IWatch - 一个视频日报类的app 播放器用到了AVFoudation。 SkfSwiftCammer - 一个相机demo，在oc里面调用了swift。 ZFPlayer - 基于AVPlayer，支持横屏、竖屏（全屏播放还可锁定屏幕方向），上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。 BMPlayer.swift - 基于 AVPlayer 使用 Swift 封装的视频播放器，方便快速集成,支持横屏、竖屏，上下滑动调节音量、屏幕亮度，左右滑动调节播放进度。 ======== 响应式框架 ReactiveCocoa - ReactiveCocoa 受函数响应式编程激发。不同于使用可变的变量替换和就地修改，RAC提供Signals来捕获当前值和将来值（ 使用介绍 ），不错的例子,入门好教程：ReactiveCocoa入门教程：第一部分 。Reactive Cocoa 3.0 在 MVVM 中的应用 ,小码哥：快速让你上手ReactiveCocoa之基础篇。 LoginWithReactiveCocoa - ReactiveCocoa - 登录交互效果的实现。 RxSwift - RxSwift:函数响应式编程框架。 RxPermission.swift - 通过绑定 RxSwift 实现的 RxPermission。 Permission.swift - 统一的 API 请求 iOS 本地设备及资源权限类库。 ReactiveAnimation - ReactiveCocoa 推出了一个叫 ReactiveAnimation 的子项目，直接用完全用 Swift 来实现了。 BeeFramework - 与ReactiveCocoa类似，BeeFramework用户指南 v1.0。 Objective-Chain - Objective-Chain是一个面向对象的响应式框架，作者表示该框架吸收了 ReactiveCocoa 的思想，并且想做得更面向对象一些。 Swiftest - BDD 全称 Behavior Driven Development，行为驱动开发。各种 DD 数不胜数，孰优孰劣争论不休，其实归根结底还是要根据使用场景进行选择。 MVVMFramework - (OC版)总结整理下一个快速开发框架，分离控制器中创建tableView和collectionView的代码，已加入cell自适应高度，降低代码耦合，提高开发效率。MVVMFramework-Swift - swift版本。 ======== 消息相关消息推送客户端 SGPushDemo - 消息推送客户端 Orbiter - 消息推送客户端:Push Notification Registration for iOS. PushDemo - 客户端消息接收消息代码，IOS开发之 —- IOS8推送消息注册 ， 分分钟搞定IOS远程消息推送。 消息推送服务端 javapns源代码 - 消息推送的java服务端代码，注意：DeviceToken中间不能有空格。 pushMeBaby - Mac端消息推送端代码，注意：DeviceToken中间要有空格。 通知相关 JSQNotificationObserverKit - 一款轻量、易用的通知发送及响应框架类库。作者是知名开源项目 JSQMessagesViewController（Objective-C 版即时聊天）的作者 Jesse Squires. GLPubSub - 一个简短实用的 NSNotificationCenter 的封装。 Homeoff - 用swift写了一个模仿Launcher通知中心快捷方式的应用。支持20个应用，并增加了一个返回到桌面来解放Home键的功能。 JDStatusBarNotification - 在状态栏顶部显示通知。可以自定义颜色字体以及动画。支持进度显示以及显示状态指示器。 SwiftNotificationCenter - 一个面向协议的类型安全、线程安全、内存安全的通知中心。 ======== 版本新API的Demo appleSample - iOS 苹果官方Demo合集， 官方demo. iOS7-Sampler - 整合了iOS7.0的一些十分有用的特性，比如：Dynamic Behaviors、碰撞检测、语音合成、视图切换、图像滤镜、三维地图、Sprite Kit（动画精灵）、Motion Effect（Parallax）、附近蓝牙或者wifi搜索连接、AirDrop、运动物体追踪（iPhone 5S以上，需要M7处理器）等等。对于日常的应用开发十分实用。 iOS8-Sampler - 日本的shuさん制作的 iOS8 参考代码集。01.Audio Effects ；02.New Image Filters；03.Custom Filters；04.Metal Basic；05.Metal Uniform Streaming；06.SceneKit；07.HealthKit；08.TouchID；09.Visual Effects；10.WebKit；11.UIAlertController；12.User Notification；13.Pedometer；14.AVKit；15.Histogram；16.Code Generator；17.New Fonts；18.Popover；19.Accordion Fold Transition iOS-9-Sampler - 通过实例介绍了iOS 9 SDK中重要新特性的使用。 MTSwift-Learning - 通过一些简单项目实战演练开始学习 Swift 。 iOS8-day-by-day - swift。 iOS9-day-by-day - swfit iOS9 Day-by-Day :: Day 2 :: UI Testing。 iOS 9 分屏多任务 - iOS 9 分屏多任务：Slide Over &amp; Split View快速入门（中文版）。 uistackview-sample.swift - iOS 9 引进了 UIStackViews，提供 auto-layout 特性。如果你开发过 Android 应用，会发现它和 LinearLayouts 概念上很类似，它是增强版。你可以手动创建，也可以使用 IB 自动创建，本文用的是代码实现。 Search-APIs - iOS 9 学习系列: SearchAPIs。教程 ======== 代码安全与密码 ios-class-guard - 一个用于混淆iOS的类名、方法名以及变量名的开源库–有人反映编译出来的app运行不了。 《Protecting iOS Applications》：文章系统地介绍了如何保护iOS程序的代码安全，防止反汇编分析。 fishhook - fishhook是Facebook开源的一个可以hook系统方法的工具。 GesturePassword - 一个iOS手势密码功能实现，iPad/iPhone 都可以用，没有使用图片，里面可以通过view自己添加。keychain做的数据持久化，利用苹果官方KeychainItemWrapper类。操作部分都在controller了。删除直接用一下clear。 JMPasswordView - 简单实用的手势密码，效果可自行调控。 仿密码锁-九宫格 - 仿密码锁-九宫格，主要是使用UIButton 手势事件 UIBezierPath画图，解锁失败弹出“密码错误”。 CoreLock - 本框架是高仿支付宝，并集成了所有功能，并非一个简单的解锁界面展示。个人制作用时1周多，打造解锁终结者框架。 LikeAlipayLockCodeView - 高仿支付宝手势解锁（超级版）。 Smile-Lock.swfit - 一个类似于iOS的解锁界面。 PCGestureUnlock - 目前最全面最高仿支付宝的手势解锁，而且提供方法进行参数修改，能解决项目开发中所有手势解锁的开发。 ICPayPassWordDemo - CPayPassWordDemo，一个模仿支付宝支付密码输入对话框小demo。 RSAESCryptor - 加密 RSA+AES Encryption/Decryption library for iOS. This library uses 2048-bit RSA and 256-bit key with 128-bit block size AES for encryption/decryption。 WJTouchID - 用法简单的TouchID验证框架：两行代码搞定。 OAuthSwift - OAuthSwift国外主流网站OAuth授权类库。 CryptoSwift - swift加密库, 支持md5,sha1,sha224,sha256…。 ======== 测试及调试 HeapInspector - HeapInspector是一个用于检测应用中的内存泄漏的开源调试工具。 Crashlytics - Crashlytics 崩溃报告 崩溃日志 使用说明 。 UIViewController-Swizzled - 把你进入的每一个controller的类名打出来,如果看一些特别复杂的项目的时候直接运行demo就可以知道执行次序了。 snoop-it - snoop-it比UIViewController-Swizzled好用，代码托管在google上。 Versions - 版本比较小工具。 MobileWebPageTest - MobileWebPageTest是用来测试移动网页性能的软件，它可以对页面的加载和渲染过程进行截屏，协助开发者分析出页面性能瓶颈。 KKLog - 一个日志管理系统。 CleanroomLogger - 相当于 CocoaLumberjack 或 Log4j 的 Swift 版本，功能上甚至更强大。另外，源代码中已经内含了完整的 API 文档，使用非常方便。 Buildasaur - 自动测试框架 Buildasaur。 使用Quick框架和Nimble来测试ViewControler - Quick是一个用于创建BDD测试的框架。配合Nimbl，可以为你创建更符合预期目标的测试。 fastlane - 一套iOS开发和持续集成的命令行工具fastlane，可以用来快速搭建CI甚至自动提交的开发环境。这套工具中包括了上传ipa文件，自动截取多语言截屏，生成推送证书，管理产品证书等一系列实用工具。 KIF - 是一个开源的用户界面UI测试框架. 使用 KIF, 并利用 iOS中的辅助功能 API, 你将能够编写模拟用户输入，诸如点击，触摸和文本输入，自动化的UI测试. Quick - 用于Swift中的单元测试（也可用于Objective-C），与Xcode整合在一起。如果你是Objective-C的粉丝，我建议用Specta代替这个，但是对Swift使用者来说，Quick是最佳选择。 Sleipnir - Swift的测试框架。 kiwi-bdd - TDD或BDD，objective-c语言的测试框架，最流行的BDD测试框架了，Kiwi最受欢迎（根据github上的star数来推断，行为描述和期望写起来也比较易懂，至少我是这么认为的） iOS开发中的测试框架。 specta - TDD或BDD，objective-c语言的测试框架，用的人多。 cedar - TDD或BDD，objective-c语言的测试框架，用的人少。 ViewMonitor - 能够帮助 iOS 开发者们精确的测量视图, 可直接在调试应用中查看具体某个视图的坐标, 宽高等参数。 MMPlaceHolder - 一行代码显示UIView的位置及相关参数。 XXPlaceHolder.swift - MMPlaceHolder的swift版本。 KMCGeigerCounter - KMCGeigerCounter通过复杂和简单的视图演示了类似盖革计数器的帧速计算功能。掉帧通常是可见的，但是很难区分55fps和60fps之间的不同，而KMCGeigerCounter可以让你观测到掉落5帧的情况。 SwiftyBeaver - 一个完善的日志工具，支持彩色输出、输出内容到文件、重要性分级、多输出目标。工具执行在后台，不影响性能，可以极大提高开发效率。 swiftlog - 为Swift 应用提供快捷添加日志信息的方法，Swift 包管理支持（SPM）、 使用惊艳的 Rainbow 包输出彩色日志、支持写入文件。使用 swiftlog Log.swift - 灵活、易用、可定制输出格式和主题风格的日志类（Swift）,支持控制台彩色输出。 Cuckoo.swift - Cuckoo.swift一款用法更接近于传统单元测试 Mock 框架库（区别之处在于需要用脚本预先生成 Mock 类）。 XCGLogger.swift - XCGLogger.swift功能完整的日志管理类库。 MSLeakHunter - 自动检测 UIViewController 和 UIView 对象的内存泄露。MLeaksFinder 的使用参照 CocoaLumberjack - 是一个快速、简单，但很强大的日志框架。 CocoaLumberjack - 是一个快速、简单，但很强大的日志框架。 ipapy - iOS项目自动打包脚本，并且上传到fir.im，然后发送邮件给测试人员。 fbretaincycledetector - Facebook出品,通过Runtime监测循环引用。 FBMemoryProfiler - Facebook出品,内存检测库。FBMemoryProfiler 基础教程。 FBAllocationTracker - Facebook出品,跟踪oc对象的分配情况。 xctool - Facebook出的自动化打包工具，它规范了输出的log日志，而且一些错误信息也更为清晰一些。 Peek.swift - 更友好、手势方式检查界面内组件布局信息（相当于浏览器元素检查功能），界面调试利器。 ======== 动态更新 waxPatch - 大众点评的屠毅敏同学在基于wax的基础上写了waxPatch，这个工具的主要原理是通过lua来针对objc的方法进行替换，由于lua本身是解释型语言，可以通过动态下载得到，因此具备了一定的动态部署能力。 JSPatch - JSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。官网。(JSPatchX)[https://github.com/bang590/JSPatchX] JSPatch的XCode 代码补全插件。 CTJSBridge - JCTJSBridge：a javascript bridge for iOS app to interact with h5 web view。 ======== AppleWatch Tesla汽车AppleWatch app demo演示 - 通过AppleWatch控制特斯拉汽车，同时可以看到汽车的相关信息，比如剩余电量、可续行里程等，以及解锁/上锁车门、调节司机和乘客的四区域空调温度、开启车辆大灯、定位汽车等。源码推荐说明。 WatchKit-Apps - WatchKit 开源小项目示例集锦。是不可多得地学习 WatchKit 的示例式教程（1.如何创建一个简单的交互式计数器；2.如何从手表上控制iOS app；3.如何在WatchKit app和iOS app之间共享数据；4.如何创建一个拥有不同背景色的数字时钟；5.展示不同的UI层；6.如何创建支持滑动手势的应用程序。）。 KYVoiceCurve - 类似Apple Watch中语音的声音曲线动画。 IGInterfaceDataTable - IGInterfaceDataTable是WKInterfaceTable对象的一个类别，可以让开发者更简单地配置多维数据。该项目使用类似UITableViewDataSource的数据源模式配置Apple Watch表格，而不是将数据结构扁平化成为数组。 Apple Watch开发教程资料汇总 - Apple Watch开发教程资料汇总。 Stargate - 通过 iPhone 桥接实现 Mac 与 Watch 的即时通讯。Stargate 通过封装两个优秀的基础类库 MMWormhole 和 PeerKit 实现高效的通讯应用。–swift soon - 一款倒计时 WatchKit 示例应用。作者从架构的角度，思考如何设计一款完整、通讯高效且性能又好的 WatchKit 扩展应用。该示例学习性非常强。–swift watchOS-2-Sampler - 基于 watchOS 2 若干新特性，写了相应的示例代码供大家学习、参考。 HMWatch - HMWatch是个有待完善的watchOS 2.0 HomeKit 应用示例。 CocoaMultipeer - CocoaMultipeer这个开源框架支持OS X, iOS和watchOS设备间的点对点通信，解决watchOS和Mac之间通信的方案还是很有用的。 HighstreetWatchApp - 是电商平台Highstreet针对App Watch的一款应用，该demo中加载的是虚拟数据。 NKWatchChart - NKWatchChart是一个基于PNChart专门为Apple Watch 开发的图表库,目前支持 line, bar, pie, circle 和 radar 等 图表形式。 BeijingAirWatch - 国人的开源项目代码 ！WatchOS 2.0 Complication of Real-time Air Quality for Major Chinese Cities 苹果表盘实时刷新北上广沈蓉空气质量。 MMWormhole.swift - MMWormhole.swift:iOS或OS X扩展与宿主应用的通讯框架。 ======== VPN vpnon - swift的VPN On 的源码和本地化内容都是开放的: 官方网站。 Hydro.network - Hydro.network 的开发旅程, gitcafe。 ======== 完整项目 v2ex - v2ex 的客户端，新闻、论坛。 V2ex-Swift - 用 Swift 写的 V2EX 客户端。 iBBS-Swift - “新手开源一个用Swift（2.0）写的论坛客户端”。BBS 服务端。 apps-ios-wikipedia - apps-ios-wikipedia 客户端。 jetstream-ios - 一款 Uber 的 MVC 框架。它同时提供了多用户实时通讯支持，一旦启动 JetStream 后端服务，通过 WebSocket 协议可以分分钟建立多用户实时通讯应用。 DeckRocket - 在相同 WiFi 网络环境内，通过iPhone 控制并播放 Mac 中的 PDF 文档。 ScanBook - 扫扫图书:可以扫描条形码查询图书，也可以关键字搜索，遇到合乎你口味的书，还可以看看别人的读书笔记，不同角度去体会。 DesignerNewsApp - Swift 开发的 DesignerNews 客户端，看着美美的！ KYWeibo - 调用新浪API自己写的第三方微博客户端。 DouQu_IOS - 逗趣IOS手机端（一款笑话软件）,拥有完整的功能的手机应用app 。 IT江湖iOS客户端 - IT江湖iOS客户端。 Eidolon - 艺术品拍卖的投标亭平台，用swift与反应式编程框架 ReactiveCocoa。 CrazyPuzzle - 模仿“看图猜成语”App，功能齐全，配有音效，效果很不错。游戏使用cocoa框架完成，没有使用cocos2d的框架。 WhoCall - 谁CALL我，iOS来电信息语音提醒，无需越狱。（需要iOS 7.0及以上版本。)骚扰电话预警、来电归属地提醒、联系人姓名播报，这些有中国特色人性化的电话功能，iOS上也应该有。电话提醒、私有API。 仿iOS猎豹垃圾清理(实现原理+源码) - 仿iOS猎豹垃圾清理(实现原理+源码),用到私有API。 DSLolita - 模仿新浪微博做的一款app，有发送博文，评论，点赞，私聊功能。 STPhotoBrowser - 高仿新浪微博的图片浏览器，极佳的编写方式，易扩展，低耦合。 GSD_ZHIFUBAO - 支付宝高仿版。 Tropos - Tropos, 由 thoughtbot 推出的一款用 Objective-C 写的开源天气类应用, 截至今天, thoughtbot 已在 GitHub 上贡献了 174 个开源项目, 实在令人敬佩。 SmileWeather -开源天气类应用,天气图标很完整。 MVVMReactiveCocoa - GitBucket 2.0 通过审核啦，她是我在公司实践了一年多 MVVM 和 RAC 的基础上，利用业余时间开发的第三方 GitHub 客户端，旨在能够对想实践 MVVM 和 RAC 的 iOS 开发者有所帮助。AppStore地址，欢迎下载使用GitBucket和收藏MVVMReactiveCocoa。 Tomate - 这个圆盘式计时器让你更专注于工作或学习。P.S. App Store 上架收费应用（0.99 欧）。 StoveFireiOSMenu - 炉火餐饮系统iPad点餐端。 BaiduFM-Swift - 百度FM, swift语言实现，基于最新xcode6.3+swift1.2,初步只是为了实现功能，代码比较粗燥，后面有时间会整理，支持Apple Watch。 WNXHuntForCity - iOS高仿城觅项目（开发思路和代码）。 ZYChat - 关于聊天界面的可消息类型扩展，响应绑定设计。 NiceAppDemo - 仿最美应用-每日最美的钢琴律动效果。 meituan - 美团5.7iOS版（高仿），功能包括，团购首页，高德地图搜索附近美食并显示在地图上，上门服务，商家，友盟分享。 MeituanDemo - 造美团应用界面构建的 iOS 应用, 第一个是 @叶孤城___ 的 MeituanDemo。 JFMeiTuan - 造美团应用界面构建的 iOS 应用, 第二个是 @tubiebutu 的 JFMeiTuan。 chuanke - 高仿百度传课iOS版。 Tuan - 模仿MJ老师iPad版美团（swift版），偶有bug 见谅。 SXNews - 模仿网易新闻做的新闻软件，完成了主导航页，新闻详情页，图片浏览页，评论页。效果不错，比网上流传的各种和网易新闻UI架构有关的代码都要完整，都要好。 Monkey - Monkey for GitHub是一个GitHub开发者和仓库排名的开源App。这次主要增加了登录GitHub的功能，随手follow和star，并且增加发现模块，包括GitHub的trending，动态，showcases等。 Uther - 跟蠢萌的外星人聊天，还能帮你记事”。itunes下载 。 CocoaChinaPlus - CocoaChina+是一款开源的第三方CocoaChina移动端。整个App都用Swift2.0编写(除部分第三方OC代码外，比如JPush和友盟)。 高仿斗鱼TV - 高仿斗鱼TV，点击头部滚动视图可以播放视频。 LXZEALER - 模仿着做了zealer客户端,App里几乎所有请求都是Post,所以内容都是固定的URL加载的,登录功能只做了微博的第三方登录。 ShiXiSeng_ios - 完整app的UI框架。 Coding-iPad - Coding-iPad 是@Coding的官方 iPad 客户端, 又是一个完整的开源应用。 SimpleMemo - 易便签已经转到Swift2.0，全面适配iOS9和Watch OS2，并支持iPhone6s和iPhone6sPlus的3D Touch功能，包括图标快捷键和内容预览。 XXYAudioEngine.swift - 基于NSURLSession 和 AVAudoPlayer的在线音乐的工具，可以把音乐保存在本地，也可以支持后台播放，后台下载，最低支持iOS7，swift版本1.2。 furni-ios.swift - furni-ios.swift是由 Twitter 开发团队出品的一款用 Swift 写的 iOS 家居商城应用, 其主要目的在于让开发者从这款 Demo 应用中看出 Fabric 的强大。 SelectionOfZhihu.swift - 『看知乎』iOS 客户端, 项目说明。 WFZhiHu - WFZhiHu仿知乎日报客户端app。 NirZhihuDaily2.0_swift - 精仿了知乎日报iOS端练手，Swift2.0，注释相当详细。 Yep.swift - Yep 一个由天才开发给天才们使用的社交软件。 LoveFreshBeen.swift - 高仿爱鲜蜂 - Swift2.0 trySwiftApp.swift - trySwiftApp一款较为完整的会议原型应用。有需求的同学可以做为开发参考。 PinGo.swift - PinGo.swift：纯Swift编写的仿“随遇”App。 UmbrellaWeather.swift - UmbrellaWeather.swift使用 Swift 编写的一款天气应用,现已上架 AppStore。 SwiftWeather - SwiftWeather清新淡雅持续改进天气预报项目。 Phonetic.swift - Phonetic一个 iOS 版的 Phonetic Contacts，功能很多，其中昵称功能非常实用，已在 GitHub 开源并上架 App Store。 edhita.swift - edhita.swift支持Markdown, HTML预览的文本编辑器。 PilesSugar.swift - PilesSugar.swift:Swift高仿项目,堆糖。 react-native-gitfeed - 目前最实用简洁的github客户端了。 phphub-ios - PHPHub的iOS客户端，同时兼容iPhone和iPad。 SoundCloudSwift - SoundCloud的Swift版本，采用Swift2.0，Reactive API with ReactiveCocoa 4.0。 LeagueofLegends - 一个关于英雄联盟的完整iOS开源项目，接口均来自多玩，腾讯各大游戏平台。 Coderpursue.swift - 一款 Github 第三方客户端，使用最新 Swift 语言编写。 BTApp - BTApp 仿半糖 iOS App 的 Demo 应用。 iOS完整App资源收集 - iOS开发学习者都希望得到实战训练，但是很多资料都是只有一小部分代码，并不能形成完成的App，笔者在此处收集了很多开源的完整的App，都有源代码哦！–标哥的技术博客 XCFApp-1 - 高仿下厨房App，Objective-C，Xcode7.2，数据通过Charles抓的，有接口也有本地数据。说明：关于代码被清空，会用git的你肯定明白，教程 XCFApp-2 - 高仿下厨房APP。 YoCelsius - 已经上线的一款天气预报的应用,几乎所有的交互动画效果，想学习动画的开发人员可以作为参考。 XiMaLaYa-by-HansRove- - 仿喜马拉雅FM, 对AVFoundation框架的一次尝试，采用MVVM模式，教程。 ======== 好的文章 自定义转场动画 - 3 种方法～ 关于自定义转场动画。 iOS提高效率的方法和工具 - iOS提高效率的方法和工具。 用 JSON 构建 API 的标准指南 - 用 JSON 构建 API 的标准指南。 RxSwift入坑手册 - RxSwift入坑手册。 iOS创建半透明ViewController - iOS创建半透明ViewController。 Xcode使用技巧 - SwiftGG 交流分享：Xcode使用技巧。 iOS蓝牙开发（四）：BabyBluetooth蓝牙库介绍 - iOS蓝牙开发（一）蓝牙相关基础知识,iOS蓝牙开发（二）：iOS连接外设的代码实现,iOS蓝牙开发（三）：App作为外设被连接的实现。 统计项目中图片使用情况 - 统计项目中图片使用情况;工具：Unused:找出项目中未使用的图片, Unused 的基础上改了一下的LSUnusedResources;工具：ImageOptim 图片保真压缩。【iOS图片压缩工具】效率最高的是tiny-png:在线压缩，前500张免费。 iOS推送之远程推送 、iOS推送之本地推送。 动态部署方案 - iOS应用架构谈动态部署方案。 awesome-github - awesome-github:收集这个列表，只是为了更好地使用亲爱的GitHub。 ReactiveCocoa 4 文档翻译目录 - ReactiveCocoa 4 文档翻译目录。 Swift编程的15个技巧 - Swift编程的15个技巧。 每个Xcode开发者应该知道的七个使用技巧 - 每个Xcode开发者应该知道的七个使用技巧。 腾讯力作！超实用的iOS 9人机界面指南 - 腾讯力作！超实用的iOS 9人机界面指南。 iOS开发-超链接富文本案 - iOS开发-超链接富文本。 UIView+RedPoint实现底部UITabBarItem和控件的右上角显示和隐藏红点/数字的需求 - 使用GCD实现和封装分组并发网络请求 - 使用GCD实现和封装分组并发网络请求。 微信语音连播的实现思路 - 微信语音连播的实现思路。 UITableView 手势延迟导致subview无法完成两次绘制 - UITableView 手势延迟导致subview无法完成两次绘制。 ======== Xcode插件 iOS开发进阶，从Xcode开始 - 学习使用Xcode构建出色的应用程序！ 在Xcode启动的时候，Xcode将会寻找位于~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中的后缀名为.xcplugin的bundle作为插件进行加载（运行其中的可执行文件）。Xcode5 Plugins 开发简介 写个自己的Xcode4插件 Xcode 4 插件制作入门 - Xcode 4 插件制作入门:Xcode所使用的所有库都包含在Xcode.app/Contents/的Frameworks，SharedFrameworks和OtherFrameworks三个文件夹下。其中和Xcode关系最为直接以及最为重要的是Frameworks中的IDEKit和IDEFoundation，以及SharedFrameworks中的DVTKit和DVTFoundation四个。 RTImageAssets - 一个 Xcode 插件，用来生成 @3x 的图片资源对应的 @2x 和 @1x 版本。Asset Catalog Creator 功能强大，能自动生成全部尺寸：包括App Icons、Image Sets、Launch Screens Generator。 VVDocumenter-Xcode - 一个Xcode插件，build后，随手打开一个你之前的项目，然后在任意一个方法上面连按三下”/“键盘，就ok了。 Swimat - Swimat，是一款Xcode 插件，帮你一键格式化 swift 代码。 Reveal-Plugin-for-XCode - 一个Reveal插件，可以使工程不作任何修改的情况下使用Reveal，该插件已在Alcatraz上架。Reveal：分析iOS UI的利器 。 java2Objective-c - Google公司出得java转Obje-C转换工具，转换逻辑，不转换UI。 RegX - 专治代码强迫症的 Xcode 插件，使用 Swift 和 Objective-C 编写。其用竖向对齐特定源代码的元素，使得代码更易读和易理解。说明 ； 菜单：xcode——》Edit-》Regx 。 KSImageNamed - 自动完成，特别是如果你正在写Objective-C，如果Xcode能自动完成文件名难道不会很伟大吗？比如图像文件的名称。 FuzzyAutocomplete - Xcode的实现自动完成还不完美，此插件能给出你所期望或想要的建议，设置：xcode-》Editor-》FuzzyAutocomplete-》plugin settings。 GitDiff - Xcode的代码编辑器的一个微妙的补强，加上了足够的可见信息以了解上次git提交以来发生了什么变化，设置：xcode-》Edit-》GitDiff。 XToDo - 这个插件不仅凸显TODO，FIXME，???，以及！！！注释，也在便利列表呈现他们。 菜单：xcode-》view-》snippets; 调出列表显示: xcode-》view-》ToDo List ： ctrl + T 。 Backlight - 突出显示当前正在编辑的行。菜单：xcode-》view-》Backlight 。 CocoaPods - 该CocoaPods的插件增加了一个CocoaPods菜单到Xcode的产品菜单。如果你不喜欢命令行，那么你一定会喜欢这个插件。 用CocoaPods做iOS程序的依赖管理 。 Peckham - 添加import语句比较麻烦，此插件 按Command-Control-P，给出的选项列表中选择要的头文件。先要安装Alcatraz ,在终端输入： curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh ； 重启xcode-》window-》Package Manager：搜索 Peckham 安装，打开Peckham.xcodeproj，编译 Peckham target，重启Xcode 。 Auto-Importer - Auto-Importer是一个自动导入类对应的头文件的Xcode插件。 Alcatraz -使用Alcatraz来管理Xcode插件 使用说明 。 KSHObjcUML -KSHObjcUML 是一个 Objective-C 类引用关系图的 Xcode 插件。 ColorSense-for-Xcode - 颜色插件，安装之后，就不用根据RGB选择颜色，直接从取色板中取颜色，会自动补齐RGB代码。 10款提高iOS开发效率的XCode插件 - 10款提高iOS开发效率的XCode插件：1. XcodeColors；5. ACCodeSnippetRepository；10. Dash for Xcode。 ZLGotoSandboxPlugin - 支持Xcode快捷键了跳转当前应用沙盒了！快捷键是 Shift+Common+w。 XcodeSwiftSnippets - XcodeSwiftSnippets, 提供了很多可在 Xcode 上使用的 Swift 代码片段, 通过自动补全的方式极大的提高了开发效率， 另外还有 Objective-C 版的。 CoPilot - 通过此插件， Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。 ESJsonFormat-Xcode - 将Json格式化输出为模型的属性。 SCXcodeMiniMap - Xcode迷你小地图-SCXcodeMiniMap。 xTransCodelation - XCODE中英文翻译插件，提供API查询模式和网页模式，都是利用的百度翻译。另外集成了一个可以一键关闭其他所有APP的实用功能，方便开发者！ SuggestedColors - Xcode 插件SuggestedColors，用于 IB颜色设置 辅助插件，非常好用。 Colors - 打印彩色字符串，可以修改 Swift 中终端输出的字符串颜色，有趣的小工具。 Crayons - Xcode调色板增强插件。 injectionforxcode - Injection for Xcode：成吨的提高开发效率,使用说明。 IconMaker - 只需要一步，自动生成不同尺寸的App icon。超级方便。 BuildTimeAnalyzer-for-Xcode - 实用的编译时间分析 Xcode 插件。 FastStub-Xcode - 一只快速生成代码的Xcode插件，说明。 ESTranslate-Xcode - 一个快速翻译Xcode代码里面单词(我主要用于翻译句子～)的插件，快捷键：Ctrl+Shift+T。 ======== 美工资源 TWG_Retina_Icons - 一套支持 Retina 高清屏的 iPhone 免费图标集。 ASCIImage - 使用 NSString 创建 image，说明。 my-sketch-colors - 配色。 Font Awesome - Font Awesome：一套绝佳的图标字体库和CSS框架，详细的安装方法请参考官方网站中文网站,GitHub地址 。 DynamicColor - 强大的颜色操作扩展类。通过该类，你可以通过扩展方法基于某个颜色得到不同深浅、饱和度、灰度、色相，以及反转后的新颜色。是不可多得的好类库。 Chameleon - Chameleon是一个iOS的色彩框架。它运用现代化flat color将UIColor扩展地非常美观。我们还可以通过它运用自定义颜色创建调色板。它还有很多功用，请浏览readme。 FontBlaster - 载入定制字体时更简单。 其他资源 githuber - 最好用的GitHub人才搜索工具。 codatlas - 源代码搜索利器。 searchcode - 源代码搜索利器：来自悉尼的代码搜索引擎汇聚了 Github, Bitbucket, Sourceforge…等多家开源站点超20万个项目、180亿行源代码，能以特殊字符、语言、仓库和源方式从90多种语言找到函数、API的真实代码。 kitematic - Mac 上使用 Docker 最简单的方案。 ======== 开发资源开发资料 豆瓣iOS开源库列表 - 豆瓣iOS开源库列表，很多开源项目。 iOS-Core-Animation-Advanced-Techniques - 中文版iOS 高级动画技术。 iOS开发的一些奇巧淫技1 - TableView不显示没内容的Cell怎么办; 键盘事件：IQKeyboardManager; app不流畅:KMCGeigerCounter; CoreData用起来好烦:MagicalRecord; CollectionView实现悬停的header:CSStickyHeaderFlowLayout。 iOS开发的一些奇巧淫技2 - 用一个pan手势来代替UISwipegesture的各个方向、拉伸图片、播放GIF、上拉刷新、把tableview里cell的小对勾的颜色改变、navigationbar弄成透明的而不是带模糊的效果、改变uitextfield placeholder的颜色和位置。 cocoapods安装指南 - cocoapods安装指南。 RemoteControl - Control your iPhone from inside Xcode for end-to-end testing 。 MVVM 介绍 - 替换MVC的开发模式。 第三方接口 - 基本所有第三方接口都在这，再也不用那么麻烦去找了。 提高iOS开发效率的方法和工具 - 提高iOS开发效率的方法和工具。 禅与 Objective-C 编程艺术 - 禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译）。 Objective-C编码规范：26个方面解决iOS开发问题 - 【Objective-C编码规范：26个方面解决iOS开发问题：“我们制定Objective-C编码规范的原因是我们能够在我们的书，教程和初学者工具包的代码保持优雅和一致。”今天分享的规范来自raywenderlich.com团队成员共同完成的，希望对学习OC的朋友们有所指导和帮助。 swift Swift 开源项目精选－v1.0 - Swift 开源项目精选－v1.0。 Swift开源项目精选 - Swift开源项目精选–推荐，每周都有更新。 Swift中文指南 - 中文版Apple官方Swift教程《The Swift Programming Language》，老码版本 历史版本更新说明。 The Swift Programming Language 中文版 - The Swift Programming Language 中文版。 swifttoolbox - swifttoolbox swift开发的开源库汇总。 SwiftGuide - 这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排– 非常不错，值得推荐。 Awesome Swift - 一个收集了很多 Swift 开发资源的网站。 Developing_iOS_8_Apps_With_Swift - Developing iOS 8 Apps with Swift 字幕简体中文翻译项目（斯坦福白胡子老头swift教学视频）。 Swift-On-iOS - JohnLui 的 Swift On iOS 代码仓库。 30DaysofSwift - 30DaysofSwift 自学 iOS - 三十天三十个 Swift 项目。 他人开源总结 awesome-osx - Awesome OS X。 code4app - 最多国人用的代码库。 cocoachina - 国内最热门的iOS社区的代码库。 awesome-ios - 一个老外整理的，中文版。 awesome-ios-ui - 收集了不少 iOS UI/UX 库, 包含了很多酷炫的动画效果。 ios-cosmos - The iOS Cosmos：收录了iOS绝大部分的开源框架和工具。 Awesome Haskell资料大全 - Awesome Haskell 资料大全：框架，库和软件。 Cosmos - The iOS Cosmos：收录了IOS绝大部分的开源框架和工具。 cocoacontrols - 收集了很多UI控件效果代码，缺点是需要翻墙，而且代码分类不够好。 lexrus - lexrus国内出名的iOS开源coder，非常酷的label动画、textfield动画。 open-source-ios-apps - iOS App集合，分：swift与Objective-C–国外人整理。 适合iOS开发者的15大网站推荐 - 适合 iOS 开发者的 15 大网站推荐 — 英文网站。 Objective-C GitHub 排名前 100 项目简介 - 主要对当前 GitHub 排名前 100 的项目做一个简单的简介, 方便初学者快速了解到当前 Objective-C 在 GitHub 的情况。 Github-iOS备忘 -整理了比较常用的iOS第三方组件，以及github上的统计。 超全！整理常用的iOS第三方资源 - 超全！整理常用的iOS第三方资源。 MyGithubMark - Github上的iOS资料-个人记录（持续更新）。 Github 上的 iOS 开源项目 - Github 上的 iOS 开源项目总结。 iOS资源大全中文版 - iOS资源大全中文版。 iOSCookies.swift - 外国开发者弄了个Swift开源库、开源Apps等超全资源整合网站！不得不说真用心啊！ 开发博客列表 唐巧整理 - 猿题库唐巧整理。 11个超棒的iOS开发学习国外网站 - 11个超棒的iOS开发学习网站:objc.io ;subjc.com ;NSHipster ;Peter Steinberger ;Ole Begemann ;Florian Kugler ;NSBlog ;Cocoa ;iOS Dev Weekly ;iOS Developer Tips ;iOS Goodies ;AppCoda 香港人创建;Krzysztof Zab?ocki ;iOS Development tips ; 博客地址 RSS地址 南峰子的技术博客 南峰子的技术博客。 唐巧的技术博客 http://blog.devtang.com/atom.xml OneV’s Den http://onevcat.com/atom.xml objc 中国 为中国 Objective-C 社区带来最佳实践和先进技术。 破船之家 http://beyondvincent.com/atom.xml NSHipster http://nshipster.cn/feed.xml Limboy 无网不剩 http://feeds.feedburner.com/lzyy Lex iOS notes http://ios.lextang.com/rss 念茜的博客 http://nianxi.net/feed.xml Xcode Dev http://blog.xcodev.com/atom.xml Ted’s Homepage http://wufawei.com/feed txx’s blog http://blog.t-xx.me/atom.xml KEVIN BLOG http://imkevin.me/rss 阿毛的蛋疼地 http://www.xiangwangfeng.com/atom.xml 亚庆的 Blog http://billwang1990.github.io/atom.xml Nonomori http://nonomori.farbox.com/feed 言无不尽 http://tang3w.com/atom.xml Wonderffee’s Blog http://wonderffee.github.io/atom.xml I’m TualatriX http://imtx.me/feed/latest/ vclwei http://vclwei.com/posts.rss Cocoabit http://blog.cocoabit.com/atom.xml nixzhu on scriptogr.am http://nixzhu.me/feed 不会开机的男孩 http://studentdeng.github.io/atom.xml Nico http://www.taofengping.com/rss.xml 阿峰的技术窝窝 http://hufeng825.github.io/atom.xml answer_huang http://answerhuang.duapp.com/index.php/feed/ webfrogs http://webfrogs.me/feed/ 代码手工艺人 http://joeyio.com/atom.xml Lancy’s Blog http://gracelancy.com/atom.xml I’m Allen http://www.imallen.com/atom.xml Travis’ Blog http://imi.im/feed 王中周的技术博客 http://wangzz.github.io/atom.xml 会写代码的猪 http://gaosboy.com/feed/atom/ 克伟的博客 http://feed.cnblogs.com/blog/u/23857/rss 摇滚诗人 http://feed.cnblogs.com/blog/u/35410/rss Luke’s Homepage http://geeklu.com/feed/ 萧宸宇 http://iiiyu.com/atom.xml Yuan博客 http://www.heyuan110.com/?feed=rss2 Shining IO http://shiningio.com/atom.xml YIFEIYANG–易飞扬的博客 http://www.yifeiyang.net/feed KooFrank’s Blog http://koofrank.com/rss hello it works http://helloitworks.com/feed 码农人生 http://msching.github.io/atom.xml 玉令天下的Blog http://yulingtianxia.com/atom.xml 不掏蜂窝的熊 http://www.hotobear.com/?feed=rss2 猫·仁波切 https://andelf.github.io/atom.xml 煲仔饭 http://ivoryxiong.org/feed.xml 里脊串的开发随笔 http://adad184.com/atom.xml ibireme伽蓝之堂 http://blog.ibireme.com/feed/ 物联网 awesome-iot - 这份物联网学习参考大全太给力。从物联网协议、嵌入式系统、相关开源库、相关书籍、博客、学习笔记、标准应有尽有。","categories":[],"tags":[]},{"title":"Swift:获取命名空间namespace,动态加载类","slug":"Swift-获取命名空间namespace-动态加载类","date":"2016-05-28T16:36:01.000Z","updated":"2016-05-28T17:40:44.000Z","comments":true,"path":"2016/05/29/Swift-获取命名空间namespace-动态加载类/","link":"","permalink":"http://pro.stonepark.fun/2016/05/29/Swift-获取命名空间namespace-动态加载类/","excerpt":"1. tips1.1在swift中,类名的组成格式是 namespace.类名.比如我们在任意一个控制器的viewDidLoad()方法中打印self,打印结果是: 这儿的Test就是namespace,默认的就是项目名.","text":"1. tips1.1在swift中,类名的组成格式是 namespace.类名.比如我们在任意一个控制器的viewDidLoad()方法中打印self,打印结果是: 这儿的Test就是namespace,默认的就是项目名. 2.怎么查看namespacenamespace在info.plist 对应的是 CFBundleExecutable,我们可以在info.plist中任意右击一行,选中Show Raw Keys/Values查看真实的key,如图 3.如何修改namespace如果新建项目时，项目名称中包含有中文，可以进入是Build Settings中选中”All”, 搜索product name,即可修改,如图: 这儿一定要记住:新改的名字不能含有中文,不能以数字开头,不能有- 4.如何代码获取命名空间名称,并创建相应的类1234567// 从info.plist读取namespacelet namespace = NSBundle.mainBundle().infoDictionary![\"CFBundleExecutable\"] as! String// 拼接类名的完整格式,即namespace.类名,vcName即控制器的类名let clsName = namespace + \".\" + vcNamelet cls: AnyClass = NSClassFromString(clsName)!// 得到相应的控制器let vc = cls.alloc() as! UITableViewController","categories":[],"tags":[]},{"title":"元组","slug":"元组","date":"2016-05-28T13:29:36.000Z","updated":"2016-05-28T17:48:26.000Z","comments":true,"path":"2016/05/28/元组/","link":"","permalink":"http://pro.stonepark.fun/2016/05/28/元组/","excerpt":"元组元组(tuples) 把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 下面这个例子中，(404, &quot;Not Found&quot;)是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个404 Not Found状态码。 12let http404Error = (404, \"Not Found\")// http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") (404, “Not Found”)元组把一个Int值和一个String值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为(Int, String)的元组”。 你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为(Int, Int, Int)或者(String, Bool)或者其他任何你想要的组合的元组。","text":"元组元组(tuples) 把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。 下面这个例子中，(404, &quot;Not Found&quot;)是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个404 Not Found状态码。 12let http404Error = (404, \"Not Found\")// http404Error 的类型是 (Int, String)，值是 (404, \"Not Found\") (404, “Not Found”)元组把一个Int值和一个String值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为(Int, String)的元组”。 你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为(Int, Int, Int)或者(String, Bool)或者其他任何你想要的组合的元组。 你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：12345let (statusCode, statusMessage) = http404Errorprint(\"The status code is \\(statusCode)\")// 输出 \"The status code is 404\"print(\"The status message is \\(statusMessage)\")// 输出 \"The status message is Not Found\" 如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：123let (justTheStatusCode, _) = http404Errorprint(\"The status code is \\(justTheStatusCode)\")// 输出 \"The status code is 404\" 此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：1234print(\"The status code is \\(http404Error.0)\")// 输出 \"The status code is 404\"print(\"The status message is \\(http404Error.1)\")// 输出 \"The status message is Not Found\" 你可以在定义元组的时候给单个元素命名：1let http200Status = (statusCode: 200, description: \"OK\") 给元组中的元素命名后，你可以通过名字来获取这些元素的值：1234print(\"The status code is \\(http200Status.statusCode)\")// 输出 \"The status code is 200\"print(\"The status message is \\(http200Status.description)\")// 输出 \"The status message is OK\" 作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个(Int, String)元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。请参考函数参数与返回值。 注意：元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。如果你的数据结构并不是临时使用，请使用类或者结构体而不是元组。请参考类和结构体。","categories":[],"tags":[]},{"title":"输入输出参数","slug":"输入输出参数","date":"2016-05-28T13:29:00.000Z","updated":"2016-05-28T17:48:29.000Z","comments":true,"path":"2016/05/28/输入输出参数/","link":"","permalink":"http://pro.stonepark.fun/2016/05/28/输入输出参数/","excerpt":"输入输出参数输入输出参数（In-Out Parameters） 函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。 定义一个输入输出参数时，在参数定义前加 inout 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看输入输出参数一节。 你只能传递变量给输入输出参数。你不能传入常量或者字面量（literal value），因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加&amp;符，表示这个值可以被函数修改。 注意输入输出参数不能有默认值，而且可变参数不能用 inout 标记。下面是例子，swapTwoInts(_:_:) 函数，有两个分别叫做 a 和 b 的输入输出参数：","text":"输入输出参数输入输出参数（In-Out Parameters） 函数参数默认是常量。试图在函数体中更改参数值将会导致编译错误。这意味着你不能错误地更改参数值。如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）。 定义一个输入输出参数时，在参数定义前加 inout 关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。想获取更多的关于输入输出参数的细节和相关的编译器优化，请查看输入输出参数一节。 你只能传递变量给输入输出参数。你不能传入常量或者字面量（literal value），因为这些量是不能被修改的。当传入的参数作为输入输出参数时，需要在参数名前加&amp;符，表示这个值可以被函数修改。 注意输入输出参数不能有默认值，而且可变参数不能用 inout 标记。下面是例子，swapTwoInts(_:_:) 函数，有两个分别叫做 a 和 b 的输入输出参数： 12345func swapTwoInts(inout a: Int, inout _ b: Int) &#123; let temporaryA = a a = b b = temporaryA&#125; 这个 swapTwoInts(_:_:) 函数简单地交换 a 与 b 的值。该函数先将 a 的值存到一个临时常量 temporaryA 中，然后将 b 的值赋给 a，最后将 temporaryA 赋值给 b。 你可以用两个 Int 型的变量来调用 swapTwoInts(_:_:)。需要注意的是，someInt 和 anotherInt 在传入 swapTwoInts(_:_:) 函数前，都加了 &amp; 的前缀：12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")// prints \"someInt is now 107, and anotherInt is now 3\" 从上面这个例子中，我们可以看到 someInt 和 anotherInt 的原始值在 swapTwoInts(_:_:) 函数中被修改，尽管它们的定义在函数体外。 注意输入输出参数和返回值是不一样的。上面的 swapTwoInts 函数并没有定义任何返回值，但仍然修改了 someInt 和 anotherInt 的值。输入输出参数是函数对函数体外产生影响的另一种方式。 应用场景, 两个变量交换值12345func swapTwoInts(inout a: Int, inout _ b: Int) &#123; let temporaryA = a a = b b = temporaryA&#125; 泛型所解决的问题下面是一个标准的非泛型函数 swapTwoInts(_:_:)，用来交换两个 Int 值：12345func swapTwoInts(inout a: Int, inout _ b: Int) &#123; let temporaryA = a a = b b = temporaryA&#125; 这个函数使用输入输出参数（inout）来交换 a 和 b 的值，请参考输入输出参数。 swapTwoInts(_:_:) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值：12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")// 打印 “someInt is now 107, and anotherInt is now 3” 诚然，swapTwoInts(_:_:) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:)，如下所示：1234567891011func swapTwoStrings(inout a: String, inout _ b: String) &#123; let temporaryA = a a = b b = temporaryA&#125;func swapTwoDoubles(inout a: Double, inout _ b: Double) &#123; let temporaryA = a a = b b = temporaryA&#125; 你可能注意到 swapTwoInts(_:_:)、swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。 在实际应用中，通常需要一个更实用更灵活的函数来交换两个任意类型的值，幸运的是，泛型代码帮你解决了这种问题。（这些函数的泛型版本已经在下面定义好了。） 注意在上面三个函数中，a 和 b 类型相同。如果 a 和 b 类型不同，那它们俩就不能互换值。Swift 是类型安全的语言，所以它不允许一个 String 类型的变量和一个 Double 类型的变量互换值。试图这样做将导致编译错误。 泛型函数泛型函数可以适用于任何类型，下面的 swapTwoValues(_:_:) 函数是上面三个函数的泛型版本：12345func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoValues(_:_:) 的函数主体和 swapTwoInts(_:_:) 函数是一样的，它们只在第一行有点不同，如下所示：12func swapTwoInts(inout a: Int, inout _ b: Int)func swapTwoValues&lt;T&gt;(inout a: T, inout _ b: T) 这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(_:_:) 函数在调用时，才能根据所传入的实际类型决定 T 所代表的类型。 另外一个不同之处在于这个泛型函数名（swapTwoValues(_:_:)）后面跟着占位类型名（T），并用尖括号括起来（&lt;T&gt;）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(_:_:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。 swapTwoValues(_:_:) 函数现在可以像 swapTwoInts(_:_:) 那样调用，不同的是它能接受两个任意类型的值，条件是这两个值有着相同的类型。swapTwoValues(_:_:) 函数被调用时，T 所代表的类型都会由传入的值的类型推断出来。 在下面的两个例子中，T 分别代表 Int 和 String：123456789var someInt = 3var anotherInt = 107swapTwoValues(&amp;someInt, &amp;anotherInt)// someInt is now 107, and anotherInt is now 3var someString = \"hello\"var anotherString = \"world\"swapTwoValues(&amp;someString, &amp;anotherString)// someString is now \"world\", and anotherString is now \"hello\" 注意上面定义的 swapTwoValues(_:_:) 函数是受 swap(_:_:) 函数启发而实现的。后者存在于 Swift 标准库，你可以在你的应用程序中使用它。如果你在代码中需要类似 swapTwoValues(_:_:) 函数的功能，你可以使用已存在的 swap(_:_:) 函数。","categories":[],"tags":[]},{"title":"在Swift中检查API的可用性","slug":"在Swift中检查API的可用性","date":"2016-05-27T18:27:52.000Z","updated":"2016-05-28T17:48:23.000Z","comments":true,"path":"2016/05/28/在Swift中检查API的可用性/","link":"","permalink":"http://pro.stonepark.fun/2016/05/28/在Swift中检查API的可用性/","excerpt":"Swift 2改进了检查API可用性的方法，使其更加容易、安全。 回顾Objective-C的方法 在看Swift之前，让我们简要回顾一下我们之前用Objective-C检查SDK可用性的方法。 检查类和框架的可用性 iOS 9作为一个重要的版本，引进了许多新的框架。但如果你部署版本低于iOS 9，你需要弱连接（weak link）这些新框架，然后在运行时检查其类的可用性。例如：如果我们想在iOS 9中使用新的联系人框架（Contacts framework），而在iOS 8中使用旧的通讯录框架（AddressBook framework）：","text":"Swift 2改进了检查API可用性的方法，使其更加容易、安全。 回顾Objective-C的方法 在看Swift之前，让我们简要回顾一下我们之前用Objective-C检查SDK可用性的方法。 检查类和框架的可用性 iOS 9作为一个重要的版本，引进了许多新的框架。但如果你部署版本低于iOS 9，你需要弱连接（weak link）这些新框架，然后在运行时检查其类的可用性。例如：如果我们想在iOS 9中使用新的联系人框架（Contacts framework），而在iOS 8中使用旧的通讯录框架（AddressBook framework）： 123456if ([CNContactStore class]) &#123; CNContactStore *store = [CNContactStore new]; //...&#125; else &#123; // 使用旧框架&#125; 检查方法的可用性 用respondsToSelector检查框架内是否含有此方法。例如：iOS 9在Core Location框架中新增了allowsBackgroundLocationUpdates属性：12345CLLocationManager *manager = [CLLocationManager new];if ([manager respondsToSelector:@selector(setAllowsBackgroundLocationUpdates:)]) &#123; // 在iOS 8中不可用 manager.allowsBackgroundLocationUpdates = YES;&#125; 陷阱 这些方法既难以维护，又没有看上去那么安全。也许某个API现在是公有的，但在早期的版本中却有可能是私有的。例如：iOS 9中新增了几个文本样式，如UIFontTextStyleCallout。如果只想在iOS 9中使用这种样式，你可以检查其是否存在，因为它在iOS 8中应该是null的： 123if (UIFontTextStyleCallout) &#123; textLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleCallout];&#125; 不幸的是结果并非如此。原来这个标志在iOS 8中是存在的，只是没有宣布公有。使用一个私有的方法或值有可能出现难以预料的结果，况且这也和我们的想法不同。 Swift 2的方法 Swift 2内置了可用性检查，而且是在编译时进行检查。这意味着当我们使用当前部署版本不可用的API时，Xcode能够通知我们。例如：如果我在部署版本为iOS 8的情况下使用CNContactStore，Xcode将提出以下改进： 12345if #available(iOS 9.0, *) &#123; let store = CNContactStore()&#125; else &#123; // 旧版本的情况&#125; 同样这可以取代我们之前使用的respondsToSelector： 1234let manager = CLLocationManager()if #available(iOS 9.0, *) &#123; manager.allowsBackgroundLocationUpdates = true&#125; 可用性检查的使用情形 #available条件适用于一系列平台(iOS, OSX, watchOS) 和版本号。例如：对于只在iOS 9或OS X 10.10上运行的代码： 123if #available(iOS 9, OSX 10.10, *) &#123; // 将在iOS 9或OS X 10.10上执行的代码&#125; 即使你的App并没有部署在其他平台，最后也需要用*通配符来包括它们。 如果某块代码只在特定的平台版本下执行，你可以用guard声明配合#available来提前return，这样可以增强可读性： 12345678private func somethingNew() &#123; guard #available(iOS 9, *) else &#123; return &#125; // 在iOS 9中执行的代码 let store = CNContactStore() let predicate = CNContact.predicateForContactsMatchingName(\"Zakroff\") let keys = [CNContactGivenNameKey, CNContactFamilyNameKey] ...&#125; 如果整个方法或类只在特定的平台版本下存在，用@available： 12345@available(iOS 9.0, *)private func checkContact() &#123; let store = CNContactStore() // ...&#125; 编译时的安全性检查 结束前，让我们再看看那个常量在iOS 9中公有却在iOS 8中私有的问题。如果部署版本为iOS 8，我们却把字体设置为一个只有iOS 9才能用的样式，这将产生一个编译错误： 12label.font = UIFont.preferredFontForTextStyle(UIFontTextStyleCallout)&gt; 'UIFontTextStyleCallout' is only available on iOS 9.0 or newer Swift使其便于调试，同时能够根据平台版本赋一个合理的值： if #available(iOS 9.0, *) { label.font = UIFont.preferredFontForTextStyle(UIFontTextStyleCallout) } else { label.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody) }","categories":[],"tags":[]},{"title":"解析JSON并且字典转模型以及如何在项目内用","slug":"解析JSON并且字典转模型以及如何在项目内用","date":"2016-05-27T08:55:07.000Z","updated":"2016-05-28T17:48:32.000Z","comments":true,"path":"2016/05/27/解析JSON并且字典转模型以及如何在项目内用/","link":"","permalink":"http://pro.stonepark.fun/2016/05/27/解析JSON并且字典转模型以及如何在项目内用/","excerpt":"1、SwiftyJSON+Alam导入到项目内 2、由于Alam发送POST请求是异步的不能及时返回数据，要把Alam简单封装下,让他能够及时返回数据1234567891011121314func httpsPost(success:((json:AnyObject)-&gt;Void)?,failure:((error:NSError)-&gt;Void)?)&#123; Alamofire.request(.POST).responseJSON(options: NSJSONReadingOptions.MutableContainers) &#123; (request, response, json, error) -&gt; Void in if error == nil &#123; if success != nil &#123; println(json) success!(json: json!) &#125; &#125; else &#123; if failure != nil &#123; failure!(error: error!) &#125; &#125; &#125;&#125; 第一个参数url为网络地址，后面success为请求成功的闭包，第二个failure为请求失败的闭包 第一行为Alam自带的request封装好的发送网络请求的方法，POST请求以及url。后面的responesJSON这个并不是Alam自带的，而是依靠SwiftyJSON的一个解析返回数据的JSON方法，options那个没太注意是干嘛的而且我也没用到过，后面request,response,json,error，前两个对数据来说没啥用，json就是咱要取的发送post请求以后后台返回的数据，如果返回失败（譬如url请求错误、或者参数不对又或者哪里有错误）error为一个错误信息。","text":"1、SwiftyJSON+Alam导入到项目内 2、由于Alam发送POST请求是异步的不能及时返回数据，要把Alam简单封装下,让他能够及时返回数据1234567891011121314func httpsPost(success:((json:AnyObject)-&gt;Void)?,failure:((error:NSError)-&gt;Void)?)&#123; Alamofire.request(.POST).responseJSON(options: NSJSONReadingOptions.MutableContainers) &#123; (request, response, json, error) -&gt; Void in if error == nil &#123; if success != nil &#123; println(json) success!(json: json!) &#125; &#125; else &#123; if failure != nil &#123; failure!(error: error!) &#125; &#125; &#125;&#125; 第一个参数url为网络地址，后面success为请求成功的闭包，第二个failure为请求失败的闭包 第一行为Alam自带的request封装好的发送网络请求的方法，POST请求以及url。后面的responesJSON这个并不是Alam自带的，而是依靠SwiftyJSON的一个解析返回数据的JSON方法，options那个没太注意是干嘛的而且我也没用到过，后面request,response,json,error，前两个对数据来说没啥用，json就是咱要取的发送post请求以后后台返回的数据，如果返回失败（譬如url请求错误、或者参数不对又或者哪里有错误）error为一个错误信息。 Void in后面为咱们要处理的 ①首先判断error是不是为nil 注：如果发送POST请求返回数据OK的话 error是为nil的 ②其次判断success是否为nil 这个就是一个闭包的保险写法 我也有点蒙为啥那么写，但是我感觉会比较保险点 ③正题来了json就是咱们要的东东，success要加! ，json:json !为返回的闭包参数son:AnyObject （具体代码怎么用后面会说） ④else 就是肯定error非nil了，非nil得话肯定报错，那么failure闭包就有作用了，返回erro错误信息 注：这个的封装不加任何参数，如果加参数可以这样 1func requestMethod3(method:Alamofire.Method,url:String,model:String,params:[NSObject:AnyObject],success:((Json:[String:AnyObject]?)-&gt;Void)?,failure:((error:NSError)-&gt;Void)?) 参数 Alamofire.Method.POST or Alamofire.Method.GET、url可以传地址，model也是一个String参数，params为一个字典 下面介绍如何去运用自己封装好的网络请求12345678var easyRequest = EasyRequest()func easyRequestNormalAndProduct()&#123; EasyRequest.httpsPost(Alamofire.Method.POST, url: FAVORITE_FAVORITE_FAVCOUNT_URL, model: FAVORITE_MODEL, params: parameters, success: &#123; (Json) -&gt; Void in println(Json) &#125;, failure: &#123; (error) -&gt; Void in println(error) &#125;)&#125; 在第五行输出的Json就可以提取数据了（参数按照自己的需求自己拼接去） OK 如果这个时候Json可以println 那么恭喜你 你已经会Alam发送网络请求以及接收到Alam返回的数据了 那么next咱得把数据解析出来~ 我这边输出的Json如下1Optional([&quot;code&quot;: 0, &quot;list&quot;: &lt;4,6,0x7f9b13263db0&gt;,[0x7f9b1322e1d0--8] [0x7f9b132447b0--8] [0x7f9b13230ff0--8] [0x7f9b10d71710--8] [0x7f9b13260a20--8] [0x7f9b13222960--8] ]) 是的 你TMD在逗我？后面那一坨一坨是个蛋蛋啊？ 聪明又帅气的二挠哥告诉你正常，只要返回数据了就正常~表急 下面来个一行代码轻松搞定 var channel = JSON(Json!) 那么再输出下就是如下信息了1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; \"code\" : 0, \"list\" : [ &#123; \"normal_video_play_count\" : 1, \"normal_video_id\" : \"1284\", \"publish_date\" : \"1435218376\", \"fav_date\" : \"1435634888\", \"type\" : 2, \"normal_video_title\" : \"9999 ooooo i\", \"normal_video\" : \"http:\\/\\/testqiniu.xiudou.net\\/VvPiEDnTp1FVcfW6FrWJX-nJnbU=\\/Fm8IAWT2B9MrFTqrnEn_ZABLagIJ?pm3u8\\/0\\/expires\\/86400&amp;e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:-Yy2m0OyxN4NVux7xUuiqV6h5nc=\", \"normal_video_head_image\" : \"http:\\/\\/testqiniu.xiudou.net\\/videos\\/shop\\/1429777564_1435218364.jpg?e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:ufP9NHZy-9ChMkpzFNN_8Jfdt6s=\" &#125;, &#123; \"normal_video_play_count\" : 1, \"normal_video_id\" : \"1285\", \"publish_date\" : \"1435219543\", \"fav_date\" : \"1435634831\", \"type\" : 2, \"normal_video_title\" : \"sdfasdfdsaf\", \"normal_video\" : \"http:\\/\\/testqiniu.xiudou.net\\/VvPiEDnTp1FVcfW6FrWJX-nJnbU=\\/Fm8IAWT2B9MrFTqrnEn_ZABLagIJ?pm3u8\\/0\\/expires\\/86400&amp;e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:-Yy2m0OyxN4NVux7xUuiqV6h5nc=\", \"normal_video_head_image\" : \"http:\\/\\/testqiniu.xiudou.net\\/videos\\/shop\\/1429777564_1435219536.jpg?e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:XPCR5XTwQ8oeDGLuNFdtwrucsGQ=\" &#125;, &#123; \"normal_video_play_count\" : 4, \"normal_video_id\" : \"1282\", \"publish_date\" : \"1435218102\", \"fav_date\" : \"1435634819\", \"type\" : 2, \"normal_video_title\" : \"呵呵\", \"normal_video\" : \"http:\\/\\/testqiniu.xiudou.net\\/VvPiEDnTp1FVcfW6FrWJX-nJnbU=\\/FiHtlkir3PNQbVK8JD5w5U96EpU4?pm3u8\\/0\\/expires\\/86400&amp;e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:OgSLxsJIbcTNSZMl40HXJKd5zO4=\", \"normal_video_head_image\" : \"http:\\/\\/7xjo8a.com2.z0.glb.qiniucdn.com\\/normal\\/1434427831_1435218100.jpg?e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:9TkEBtRvF2DHaGyDKDtHv7ryqu8=\" &#125;, &#123; \"normal_video_play_count\" : 4, \"normal_video_id\" : \"1224\", \"publish_date\" : \"1434020670\", \"fav_date\" : \"1435564145\", \"type\" : 2, \"normal_video_title\" : \"\", \"normal_video\" : \"http:\\/\\/testqiniu.xiudou.net\\/PjhrU4kwRDaU1YNTE_8kapZMa4o=\\/Fm8IAWT2B9MrFTqrnEn_ZABLagIJ?pm3u8\\/0\\/expires\\/86400&amp;e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:rQ8KIr5og7apuD4LGNtFvb30Ooo=\", \"normal_video_head_image\" : \"http:\\/\\/testqiniu.xiudou.net\\/shop_videos\\/shop\\/1429777564_1434020650.jpg?e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:e004eIn52ZY68IFmN9ZvhNMHptM=\" &#125;, &#123; \"normal_video_play_count\" : 7, \"normal_video_id\" : \"1263\", \"publish_date\" : \"1434443695\", \"fav_date\" : \"1434542812\", \"type\" : 2, \"normal_video_title\" : \"也要好好和\", \"normal_video\" : \"http:\\/\\/testqiniu.xiudou.net\\/VvPiEDnTp1FVcfW6FrWJX-nJnbU=\\/FrvIsJaH3xCJQ8a7TlMwRvVyCph8?pm3u8\\/0\\/expires\\/86400&amp;e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:_FQOC8YioYREAuRG1oPJOfGmu4U=\", \"normal_video_head_image\" : \"http:\\/\\/7xjo8a.com2.z0.glb.qiniucdn.com\\/normal\\/1433837202_1434443640125.jpg?e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:CngLb_rPEYvuAouMbP0iJbKbqUI=\" &#125;, &#123; \"normal_video_play_count\" : 14, \"normal_video_id\" : \"1254\", \"publish_date\" : \"1434438070\", \"fav_date\" : \"1434542808\", \"type\" : 2, \"normal_video_title\" : \"vbjj\", \"normal_video\" : \"http:\\/\\/testqiniu.xiudou.net\\/VvPiEDnTp1FVcfW6FrWJX-nJnbU=\\/FtfIY7z-FAShdNiuBnmG0kpwefjk?pm3u8\\/0\\/expires\\/86400&amp;e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:hcVZdnu1riz88z_AWlAqIRFIzns=\", \"normal_video_head_image\" : \"http:\\/\\/7xjo8a.com2.z0.glb.qiniucdn.com\\/normal\\/1428903622_1434438045781.jpg?e=1435769541&amp;token=TS8CH53g7f8gjytpyRGRwG4MFOua4FSwZ5g1O_L7:uVk6IxqL0ARWzIIEzphhN4LKORY=\" &#125; ]&#125; OK看到这里你就算是认识了把，简单的JSON，你理解为键值对也行~！反正我总是理解成键值对~！。。。。。 OK那么下一步取出具体的数据 首先提取 提取的话其实SwiftyJSON都给大家封装的很好了直接调用即可 如上图我如果想取code和list 那么直接1234var code = channel[\"code\"].int //此时输出code 为0 因为返回的数据就为0var array = channel[\"list\"].array //此时的list是包含了list：后面那些很多数据的数组 到此OK了JSON数据提取OK了，能正常的println了 那么这里咱先做点别的~！什么呢？建立Model（不懂model得自己百度MVC去） 首先建立对应返回数组也就是上面的array。我的对应的如下123456789101112131415161718192021222324252627282930313233//// NormalModel.swift////// Created by 二挠 on 15/6/26.// Copyright (c) 2015年 . All rights reserved.//import Foundationclass NormalModel&#123; var publish_date:String! var normal_video_id:Int! var normal_video_title:String! var normal_video:String! var normal_video_head_image:String! var video_play_count:Int! var fav_date: String! var fav_type:Int! func initModel(dict:NSDictionary)-&gt;AnyObject&#123; publish_date = dict.valueForKey(\"publish_date\") as! String normal_video_id = dict.valueForKey(\"normal_video_id\") as! Int normal_video_title = dict.valueForKey(\"normal_video_title\") as! String normal_video = dict.valueForKey(\"normal_video\") as! String normal_video_head_image = dict.valueForKey(\"normal_video_head_image\") as! String video_play_count = dict.valueForKey(\"normal_video_play_count\") as! Int fav_date = dict.valueForKey(\"fav_date\") as! String fav_type = dict.valueForKey(\"type\") as! Int return self &#125;&#125; 那么对应返回JSON的实体类就建立好了。 解释下 很简单一个名字为NormalModel的实体类，里面一个方法名字为initModel的带NSDictionary参数的方法，方法内部去把接收的字典取Key对应的value然后赋值给属性。 对象建完了那么下面就该是如何给对象赋值了，还记得上面已经获取到array了么？what？你TMD忘了 么事 二挠哥带你装逼带你飞 再来复习下12345678910println(Json) //Json为闭包返回的json变量，JSON为SwiftyJSON自带的var channel = JSON(Json!)println(channel)var code = channel[\"code\"].int //此时输出code 为0 因为返回的数据就为0var array = channel[\"list\"].array //此时的list是包含了list：后面那些很多数据的数组 //新建一个可变数组来添加数据var tempArray = NSMutableArray() 然后去循环array给这个类传一个NSDictionary即可。具体做法1234for e in array! &#123; var cc = NormalModel().initModel(NSDictionary(dictionary:e.dictionaryObject!) as [NSObject : AnyObject]) tempArray.addObject(cc)&#125; 貌似到这里就完了 其实还有一个尾巴~~~啥？闭包有两个，一个success就是咱们要处理这个、还一个failure木有处理直接如下123failure: &#123; (error) -&gt; Void in println(error)&#125; 那么现在基本就完成 90%了到此为止了？NONO 下面介绍如何运用，既然都存到Model里了总得用吧？ 拿UICollectionView来说吧在 cellForItemAtIndexPath方法内1234func collectionView(collectionView: UICollectionView, cellForItemAtIndexPath indexPath: NSIndexPath) -&gt; UICollectionViewCell &#123; var nor = NormalModel() nor = swiftMultiPage.dataArray[indexPath.row] as! NormalModel&#125; 这时候的nor就已经存了第一条数据了 不信你po nor.favDate来爽爽？","categories":[],"tags":[]},{"title":"MVVM","slug":"MVVM-0","date":"2016-05-27T08:51:41.000Z","updated":"2016-05-28T17:48:20.000Z","comments":true,"path":"2016/05/27/MVVM-0/","link":"","permalink":"http://pro.stonepark.fun/2016/05/27/MVVM-0/","excerpt":"MVVMMVVM 是 Model-View-ViewModel 的简写，MVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model） MVC 回顾 MVC 结构图 MVC 存在的问题 模型的代码很少 控制器的代码一不小心就越来越多 不好测试","text":"MVVMMVVM 是 Model-View-ViewModel 的简写，MVVM 模式和 MVC 模式一样，主要目的是分离视图（View）和模型（Model） MVC 回顾 MVC 结构图 MVC 存在的问题 模型的代码很少 控制器的代码一不小心就越来越多 不好测试 MVVM MVVM 结构图 MVVM 概念 在 MVVM 中，view 和 view controller 正式联系在一起，我们把它们视为一个组件 view 和 view controller 都不能直接引用 model，而是引用视图模型 view model 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码 MVVM 使用注意事项 view 引用 view model，但反过来不行 view model 引用了 model，但反过来不行 如果我们破坏了这些规则，便无法正确地使用 MVVM MVVM 的优点 低耦合：View 可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上 可重用性：可以把一些视图逻辑放在一个 ViewModel 里面，让很多 view 重用这段视图逻辑 独立开发：开发人员可以专注于业务逻辑和数据的开发 ViewModel，设计人员可以专注于页面设计 可测试：通常界面是比较难于测试的，而 MVVM 模式可以针对 ViewModel 来进行测试","categories":[],"tags":[]},{"title":"Swift/Objc的Runtime运行时机制","slug":"Swift-Objc的Runtime运行时机制","date":"2016-05-27T08:46:10.000Z","updated":"2016-05-28T17:48:16.000Z","comments":true,"path":"2016/05/27/Swift-Objc的Runtime运行时机制/","link":"","permalink":"http://pro.stonepark.fun/2016/05/27/Swift-Objc的Runtime运行时机制/","excerpt":"引言相信很多同学都听过运行时，但是我相信还是有很多同学不了解什么是运行时，到底在项目开发中怎么用？什么时候适合使用？想想我们的项目中，到底在哪里使用过运行时呢？还能想起来吗？另外，在面试的时候，是否经常有笔试中要求运用运行时或者在面试时面试官会问是否使用过运行时，又是如何使用的？ 回想自己，曾经在面试中被面试官拿运行时刁难过，也在笔试中遇到过。因此，后来就深入地学习了Runtime机制，学习里面的API。所以才有了后来的组件封装中使用运行时。 相信我们都遇到过这样一个问题：我想在扩展（category）中添加一个属性，如果iOS是不允许给扩展类扩展属性的，那怎么办呢？答案就是使用运行时机制","text":"引言相信很多同学都听过运行时，但是我相信还是有很多同学不了解什么是运行时，到底在项目开发中怎么用？什么时候适合使用？想想我们的项目中，到底在哪里使用过运行时呢？还能想起来吗？另外，在面试的时候，是否经常有笔试中要求运用运行时或者在面试时面试官会问是否使用过运行时，又是如何使用的？ 回想自己，曾经在面试中被面试官拿运行时刁难过，也在笔试中遇到过。因此，后来就深入地学习了Runtime机制，学习里面的API。所以才有了后来的组件封装中使用运行时。 相信我们都遇到过这样一个问题：我想在扩展（category）中添加一个属性，如果iOS是不允许给扩展类扩展属性的，那怎么办呢？答案就是使用运行时机制 运行时机制Runtime是一套比较底层的纯C语言的API, 属于C语言库, 包含了很多底层的C语言API。在我们平时编写的iOS代码中, 最终都是转成了runtime的C语言代码。 所谓运行时，也就是在编译时是不存在的，只是在运行过程中才去确定对象的类型、方法等。利用Runtime机制可以在程序运行时动态修改类、对象中的所有属性、方法等。 还记得我们在网络请求数据处理时，调用了-setValuesForKeysWithDictionary:方法来设置模型的值。这里什么原理呢？为什么能这么做？其实就是通过Runtime机制来完成的，内部会遍历模型类的所有属性名，然后设置与key对应的属性名的值。 我们在使用运行时的地方，都需要包含头文件：#import &lt;objc/runtime.h&gt;。如果是Swift就不需要包含头文件，就可以直接使用了。 获取对象所有属性名利用运行时获取对象的所有属性名是可以的，但是变量名获取就得用另外的方法了。我们可以通过class_copyPropertyList方法获取所有的属性名称。 下面我们通过一个Person类来学习，这里的方法没有写成扩展，只是为了简化，将获取属性名的方法直接作为类的实例方法： Objective-C版1234567891011121314@interface Person : NSObject &#123; NSString *_variableString;&#125;// 默认会是什么呢？@property (nonatomic, copy) NSString *name;// 默认是strong类型@property (nonatomic, strong) NSMutableArray *array;// 获取所有的属性名- (NSArray *)allProperties;@end 下面主要是写如何获取类的所有属性名的方法。注意，这里的objc_property_t是一个结构体指针objc_property *，因此我们声明的properties就是二维指针。在使用完成后，我们一定要记得释放内存，否则会造成内存泄露。这里是使用的是C语言的API，因此我们也需要使用C语言的释放内存的方法free。12/// An opaque type that represents an Objective-C declared property.typedef struct objc_property *objc_property_t; 12345678910111213141516171819202122- (NSArray *)allProperties &#123; unsigned int count; // 获取类的所有属性 // 如果没有属性，则count为0，properties为nil objc_property_t *properties = class_copyPropertyList([self class], &amp;count); NSMutableArray *propertiesArray = [NSMutableArray arrayWithCapacity:count]; for (NSUInteger i = 0; i &lt; count; i++) &#123; // 获取属性名称 const char *propertyName = property_getName(properties[i]); NSString *name = [NSString stringWithUTF8String:propertyName]; [propertiesArray addObject:name]; &#125; // 注意，这里properties是一个数组指针，是C的语法， // 我们需要使用free函数来释放内存，否则会造成内存泄露 free(properties); return propertiesArray;&#125; 现在，我们来测试一下，我们的方法是否正确获取到了呢？看下面的打印结果就明白了吧！123456789101112131415Person *p = [[Person alloc] init];p.name = @\"Lili\";size_t size = class_getInstanceSize(p.class);NSLog(@\"size=%ld\", size);for (NSString *propertyName in p.allProperties) &#123; NSLog(@\"%@\", propertyName);&#125;// 打印结果：// 2015-10-23 17:28:38.098 PropertiesDemo[1120:361130] size=48// 2015-10-23 17:28:38.098 PropertiesDemo[1120:361130] copiedString// 2015-10-23 17:28:38.098 PropertiesDemo[1120:361130] name// 2015-10-23 17:28:38.098 PropertiesDemo[1120:361130] unsafeName// 2015-10-23 17:28:38.099 PropertiesDemo[1120:361130] array Swift版 对于Swift版，使用C语言的指针就不容易了，因为Swift希望尽可能减少C语言的指针的直接使用，因此在Swift中已经提供了相应的结构体封装了C语言的指针。但是看起来好复杂，使用起来好麻烦。看看Swift版的获取类的属性名称如何做：1234567891011121314151617181920212223242526272829303132333435class Person: NSObject &#123; var name: String = \"\" var hasBMW = false override init() &#123; super.init() &#125; func allProperties() -&gt;[String] &#123; // 这个类型可以使用CUnsignedInt,对应Swift中的UInt32 var count: UInt32 = 0 let properties = class_copyPropertyList(Person.self, &amp;count) var propertyNames: [String] = [] // Swift中类型是严格检查的，必须转换成同一类型 for var i = 0; i &lt; Int(count); ++i &#123; // UnsafeMutablePointer&lt;objc_property_t&gt;是 // 可变指针，因此properties就是类似数组一样，可以 // 通过下标获取 let property = properties[i] let name = property_getName(property) // 这里还得转换成字符串 let strName = String.fromCString(name); propertyNames.append(strName!); &#125; // 不要忘记释放内存，否则C语言的指针很容易成野指针的 free(properties) return propertyNames; &#125;&#125; 关于Swift中如何C语言的指针问题，这里不细说，如果需要了解，请查阅相关文章。测试一下是否获取正确：12345let p = Person()p.name = \"Lili\"// 打印结果：[\"name\", \"hasBMW\"]，说明成功p.allProperties() 获取对象的所有属性名和属性值对于获取对象的所有属性名，在上面的-allProperties方法已经可以拿到了，但是并没有处理获取属性值，下面的方法就是可以获取属性名和属性值，将属性名作为key，属性值作为value。 Objective-C版1234567891011121314151617181920212223242526- (NSDictionary *)allPropertyNamesAndValues &#123; NSMutableDictionary *resultDict = [NSMutableDictionary dictionary]; unsigned int outCount; objc_property_t *properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i++) &#123; objc_property_t property = properties[i]; const char *name = property_getName(property); // 得到属性名 NSString *propertyName = [NSString stringWithUTF8String:name]; // 获取属性值 id propertyValue = [self valueForKey:propertyName]; if (propertyValue &amp;&amp; propertyValue != nil) &#123; [resultDict setObject:propertyValue forKey:propertyName]; &#125; &#125; // 记得释放 free(properties); return resultDict;&#125; 测试一下：1234567// 此方法返回的只有属性值不为空的属性NSDictionary *dict = p.allPropertyNamesAndValues;for (NSString *propertyName in dict.allKeys) &#123; NSLog(@\"propertyName: %@ propertyValue: %@\", propertyName, dict[propertyName]);&#125; 看下打印结果，属性值为空的属性并没有打印出来，因此字典的key对应的value不能为nil：1propertyName: name propertyValue: Lili Swift版1234567891011121314151617181920func allPropertyNamesAndValues() -&gt;[String: AnyObject] &#123; var count: UInt32 = 0 let properties = class_copyPropertyList(Person.self, &amp;count) var resultDict: [String: AnyObject] = [:] for var i = 0; i &lt; Int(count); ++i &#123; let property = properties[i] // 取得属性名 let name = property_getName(property) if let propertyName = String.fromCString(name) &#123; // 取得属性值 if let propertyValue = self.valueForKey(propertyName) &#123; resultDict[propertyName] = propertyValue &#125; &#125; &#125; return resultDict&#125; 测试一下：1234let dict = p.allPropertyNamesAndValues()for (propertyName, propertyValue) in dict.enumerate() &#123; print(\"propertyName: (propertyName), propertyValue: (propertyValue)\")&#125; 打印结果与上面的一样，由于array属性的值为nil，因此不会处理。1propertyName: 0, propertyValue: (&quot;name&quot;, Lili) 获取对象的所有方法名通过class_copyMethodList方法就可以获取所有的方法。 Objective-C版12345678910111213141516171819202122- (void)allMethods &#123; unsigned int outCount = 0; Method *methods = class_copyMethodList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; ++i) &#123; Method method = methods[i]; // 获取方法名称，但是类型是一个SEL选择器类型 SEL methodSEL = method_getName(method); // 需要获取C字符串 const char *name = sel_getName(methodSEL); // 将方法名转换成OC字符串 NSString *methodName = [NSString stringWithUTF8String:name]; // 获取方法的参数列表 int arguments = method_getNumberOfArguments(method); NSLog(@\"方法名：%@, 参数个数：%d\", methodName, arguments); &#125; // 记得释放 free(methods);&#125; 测试一下：1[p allMethods]; 调用打印结果如下，为什么参数个数看起来不匹配呢？比如-allProperties方法，其参数个数为0才对，但是打印结果为2。根据打印结果可知，无参数时，值就已经是2了。：12345678方法名：allProperties, 参数个数：2方法名：allPropertyNamesAndValues, 参数个数：2方法名：allMethods, 参数个数：2方法名：setArray:, 参数个数：3方法名：.cxx_destruct, 参数个数：2方法名：name, 参数个数：2方法名：array, 参数个数：2方法名：setName:, 参数个数：3 Swift版12345678910111213func allMethods() &#123; var count: UInt32 = 0 let methods = class_copyMethodList(Person.self, &amp;count) for var i = 0; i &lt; Int(count); ++i &#123; let method = methods[i] let sel = method_getName(method) let methodName = sel_getName(sel) let argument = method_getNumberOfArguments(method) print(\"name: (methodName), arguemtns: (argument)\") &#125;&#125; 测试一下调用：1p.allMethods() 打印结果与上面的Objective-C版的一样。 获取对象的成员变量名称要获取对象的成员变量，可以通过class_copyIvarList方法来获取，通过ivar_getName来获取成员变量的名称。对于属性，会自动生成一个成员变量。 Objective-C版12345678910111213141516- (NSArray *)allMemberVariables &#123; unsigned int count = 0; Ivar *ivars = class_copyIvarList([self class], &amp;count); NSMutableArray *results = [[NSMutableArray alloc] init]; for (NSUInteger i = 0; i &lt; count; ++i) &#123; Ivar variable = ivars[i]; const char *name = ivar_getName(variable); NSString *varName = [NSString stringWithUTF8String:name]; [results addObject:varName]; &#125; return results;&#125; 测试一下：123for (NSString *varName in p.allMemberVariables) &#123; NSLog(@\"%@\", varName);&#125; 打印结果说明属性也会自动生成一个成员变量：1232015-10-23 23:54:00.896 PropertiesDemo[46966:3856655] _variableString2015-10-23 23:54:00.897 PropertiesDemo[46966:3856655] _name2015-10-23 23:54:00.897 PropertiesDemo[46966:3856655] _array Swift版 Swift的成员变量名与属性名是一样的，不会生成下划线的成员变量名，这一点与Oc是有区别的。1234567891011121314151617func allMemberVariables() -&gt;[String] &#123; var count:UInt32 = 0 let ivars = class_copyIvarList(Person.self, &amp;count) var result: [String] = [] for var i = 0; i &lt; Int(count); ++i &#123; let ivar = ivars[i] let name = ivar_getName(ivar) if let varName = String.fromCString(name) &#123; result.append(varName) &#125; &#125; return result&#125; 测试一下：1234let array = p.allMemberVariables()for varName in array &#123; print(varName)&#125; 打印结果，说明Swift的属性不会自动加下划线，属性名就是变量名：12namearray 运行时发消息iOS中，可以在运行时发送消息，让接收消息者执行对应的动作。可以使用objc_msgSend方法，发送消息。 Objective-C版123Person *p = [[Person alloc] init];p.name = @\"Lili\";objc_msgSend(p, @selector(allMethods)); 这样就相当于手动调用[p allMethods];。但是编译器会抱错，问题提示期望的参数为0，但是实际上有两个参数。解决办法是，关闭严格检查： Swift版 很抱歉，似乎在Swift中已经没有这种写法了。如果有，请告诉我。 Category扩展”属性”iOS的category是不能扩展存储属性的，但是我们可以通过运行时关联来扩展“属性”。 Objective-C版 假设扩展下面的“属性”：123// 由于扩展不能扩展属性，因此我们这里在实现文件中需要利用运行时实现。typedef void(^HYBCallBack)();@property (nonatomic, copy) HYBCallBack callback; 在实现文件中，我们用一个静态变量作为key： 123456789const void *s_HYBCallbackKey = \"s_HYBCallbackKey\";- (void)setCallback:(HYBCallBack)callback &#123; objc_setAssociatedObject(self, s_HYBCallbackKey, callback, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (HYBCallBack)callback &#123; return objc_getAssociatedObject(self, s_HYBCallbackKey);&#125; 其实就是通过objc_getAssociatedObject取得关联的值，通过objc_setAssociatedObject设置关联。 Swift版 Swift版的要想扩展闭包，就比OC版的要复杂得多了。这里只是例子，写了一个简单的存储属性扩展。 12345678910let s_HYBFullnameKey = \"s_HYBFullnameKey\"extension Person &#123; var fullName: String? &#123; get &#123; return objc_getAssociatedObject(self, s_HYBFullnameKey) as? String &#125; set &#123; objc_setAssociatedObject(self, s_HYBFullnameKey, newValue, .OBJC_ASSOCIATION_COPY_NONATOMIC) &#125; &#125;&#125; 总结在开发中，我们比较常用的是使用关联属性的方式来扩展我们的“属性”，以便在开发中简单代码。我们在开发中使用关联属性扩展所有响应事件、将代理转换成block版等。比如，我们可以将所有继承于UIControl的控件，都拥有block版的点击响应，那么我们就可以给UIControl扩展一个TouchUp、TouchDown、TouchOut的block等。 对于动态获取属性的名称、属性值使用较多的地方一般是在使用第三方库中，比如MJExtension等。这些三方库都是通过这种方式将Model转换成字典，或者将字典转换成Model。","categories":[],"tags":[]},{"title":"Swift Runtime分析：还像OC Runtime一样吗？","slug":"Swift-Runtime分析：还像OC-Runtime一样吗？","date":"2016-05-07T17:24:38.000Z","updated":"2016-07-08T17:35:16.000Z","comments":true,"path":"2016/05/08/Swift-Runtime分析：还像OC-Runtime一样吗？/","link":"","permalink":"http://pro.stonepark.fun/2016/05/08/Swift-Runtime分析：还像OC-Runtime一样吗？/","excerpt":"Swift是苹果2014年发布的编程开发语言，可与Objective-C共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。Swift已经开源，目前最新版本为2.2。我们知道Objective-C是具有动态性的，能够通过runtime API调用和替换任意方法，那Swift也具有这些动态性吗？","text":"Swift是苹果2014年发布的编程开发语言，可与Objective-C共同运行于Mac OS和iOS平台，用于搭建基于苹果平台的应用程序。Swift已经开源，目前最新版本为2.2。我们知道Objective-C是具有动态性的，能够通过runtime API调用和替换任意方法，那Swift也具有这些动态性吗？ 分析用例我们拿一个纯Swift类和一个继承自NSObject的类的类来做分析，这两个类里包含尽量多的Swift的类型比如Character、String、AnyObject、Tuple。 代码如下： 方法、属性动态性比较重要的一点就是能够拿到某个类所有的方法、属性，我们使用如下代码来打印方法和属性列表。 调用showClsRuntime的代码如下： 看看我们得到什么结果？ 对于纯Swift的TestASwiftClass来说任何方法、属性都未获取到。 对于TestSwiftVC来说除testReturnTuple、testReturnVoidWithaCharacter两个方法外，其他的都获取成功了。 这是为什么？纯Swift类的函数调用已经不再是Objective-c的运行时发消息，而是类似C++的vtable，在编译时就确定了调用哪个函数，所以没法通过runtime获取方法、属性。 TestSwiftVC继承自UIViewController，基类NSObject，而Swift为了兼容Objective-C，凡是继承自NSObject的类都会保留其动态性，所以我们能通过runtime拿到他的方法。 但为什么testReturnTuple testReturnVoidWithaCharacter却又获取不到呢？ 从Objective-c的runtime 特性可以知道，所有运行时方法都依赖TypeEncoding，也就是method_getTypeEncoding返回的结果，他指定了方法的参数类型以及在函数调用时参数入栈所要的内存空间，没有这个标识就无法动态的压入参数（比如testReturnVoidWithaId: Optional(“v24@0:8@16”) Optional(“v”)，表示此方法参数共需24个字节，返回值为void，第一个参数为id，第二个为selector，第三个为id），而Character和Tuple是Swift特有的，无法映射到OC的类型，更无法用OC的typeEncoding表示，也就没法通过runtime获取了。 Method Swizzling动态性最常用的就是方法替换（Method Swizzling），将类的某个方法替换成自定义的方法，从而达到hook的作用。 对于纯Swift类（如TestASwiftClass）来说，无法通过objc runtime替换方法，因为由上面的测试可知拿不到这些方法、属性 对于继承自NSObject类（如TestSwiftVC）来说，无法通过runtime获取到的方法肯定没法替换了。那能通过runtime获取到的方法就都能被替换吗？我们测一把。 Method Swizzling的代码如下 我们替换两个可以被runtime获取到的方法：viewDidAppear和testReturnVoidWithaId 打印的日志为 F:testReturnVoidWithaId L:50 F:sz_viewDidAppear L:46 说明viewDidAppear已经被替换，但是testReturnVoidWithaId却没有被替换，这是为何? 我们在方法里打个断点看看，如图: 可以看到区别，调用sz_viewDidAppear栈的前一帧为@objc TestSwiftVC.sz_viewDidAppear(Bool) -&gt; ()有个@objc标识，而调用testReturnVoidWithaId则没有此标识。 @objc用来做什么的？与动态性有关吗？ @objc找到官方文档读读。 可以知道@objc是用来将Swift的API导出给Objective-C和Objective-C runtime使用的，如果你的类继承自Objective-c的类（如NSObject）将会自动被编译器插入@objc标识。 我们在把TestASwiftClass（纯Swift类）的方法、属性前都加个@objc 试试，如图： 查看日志可以发现加了@objc的方法、属性均可以被runtime获取到了。 dynamic文档里还有一句说明： 加了@objc标识的方法、属性无法保证都会被运行时调用，因为Swift会做静态优化。要想完全被动态调用，必须使用dynamic修饰。使用dynamic修饰将会隐式的加上@objc标识。 这也就解释了为什么testReturnVoidWithaId无法被替换，因为写在Swift里的代码直接被编译优化成静态调用了。 而viewDidAppear是继承Objective-C类获得的方法，本身就被修饰为dynamic，所以能被动态替换。 我们把TestSwiftVC方法前加上dynamic再测一把，如图： 从堆栈也可以看出，方法的调用前增加了@objc标识，testReturnVoidWithaId方法被替换成功了。 同样的做法，我们把TestASwiftClass的方法和属性也都加上dynamic修饰，做Method Swizzling，同样获得成功，如图 Objective-C获取Swift runtime信息在Objective-c代码里使用objc_getClass(“TestSwiftVC”);会发现返回值为空，这是为什么？Swift代码中的TestSwiftVC类，在OC中还是这个名字吗？ 我们初始化一个对象，并断点和打印看看，如下图： 可以看到Swift中的TestSwiftVC类在OC中的类名已经变成TestSwift.TestSwiftVC，即规则为SWIFT_MODULE_NAME.类名称，在普通源码项目里SWIFT_MODULE_NAME即为ProductName，在打好的Cocoa Touch Framework里为则为导出的包名。 所以要想从Objective-c中获取Swift类的runtime信息得这样写： Objective-C替换Swift函数给TestSwiftVC和TestASwiftClass的testReturnVoidWithaId函数加上dynamic修饰，然后我们在Objective-C代码里替换为testReturnVoidWithaIdImp函数： 运行之后我们得到结果 F:void testReturnVoidWithaIdImp(strong id, SEL, strong id) L:20 self=&lt;TestSwift.TestSwiftVC: 0x7fb4e1d148f0&gt; F:void testReturnVoidWithaIdImp(strong id, SEL, strong id) L:20 self=TestSwift.TestASwiftClass 说明两者的方法在加上dynamic修饰后，均能在Objective-c里被替换。(TestSwiftVC的testReturnVoidWithaId不加dynamic也会打印日志，为什么？留给读者思考) 总结纯Swift类没有动态性，但在方法、属性前添加dynamic修饰可以获得动态性。继承自NSObject的Swift类，其继承自父类的方法具有动态性，其他自定义方法、属性需要加dynamic修饰才可以获得动态性。 若方法的参数、属性类型为Swift特有、无法映射到Objective-C的类型(如Character、Tuple)，则此方法、属性无法添加dynamic修饰（会编译错误） Swift类在Objective-C中会有模块前缀 关于本文 本文作者尹峥伟（花名君展），手机淘宝技术团队的资深无线开发工程师，主要负责手机淘宝基础架构研发，Github开源库Wax的维护者，微博@君展。本文已投稿至InfoQ。","categories":[],"tags":[]},{"title":"调用objc_msgSend方法在64位下崩溃解决方法","slug":"调用objc-msgSend方法在64位下崩溃解决方法","date":"2015-09-05T23:20:27.000Z","updated":"2016-06-22T23:22:52.000Z","comments":true,"path":"2015/09/06/调用objc-msgSend方法在64位下崩溃解决方法/","link":"","permalink":"http://pro.stonepark.fun/2015/09/06/调用objc-msgSend方法在64位下崩溃解决方法/","excerpt":"","text":"之前一直在非64位机器下测试一切正常的程序，在iPhone5s下无缘无故崩溃。崩溃的位置是调用objc_msgSend时出现。经过一番辛苦搜索终于发现苹果官网上有一段这样的描述： Dispatch Objective-C Messages Using the Method Function’s Prototype An exception to the casting rule described above is when you are calling the objc_msgSend function or any other similar functions in the Objective-C runtime that send messages. Although the prototype for the message functions has a variadic form, the method function that is called by the Objective-C runtime does not share the same prototype. The Objective-C runtime directly dispatches to the function that implements the method, so the calling conventions are mismatched, as described previously. Therefore you must cast the objc_msgSend function to a prototype that matches the method function being called. Listing 2-14 shows the proper form for dispatching a message to an object using the low-level message functions. In this example, thedoSomething: method takes a single parameter and does not have a variadic form. It casts the objc_msgSend function using the prototype of the method function. Note that a method function always takes an id variable and a selector as its first two parameters. After the objc_msgSendfunction is cast to a function pointer, the call is dispatched through that same function pointer. Listing 2-14 Using a cast to call the Objective-C message sending functions 12345- (int) doSomething:(int) x &#123; ... &#125;- (void) doSomethingElse &#123; int (*action)(id, SEL, int) = (int (*)(id, SEL, int)) objc_msgSend; action(self, @selector(doSomething:), 0);&#125; 貌似是说不能直接使用objc_msgSend的原型方法来匿名调用，否则会出现异常。结果尝试了上面的方法强制转换成一定的方法后，再次运行没有崩溃了，Luck!! 原文来自：https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaTouch64BitGuide/ConvertingYourAppto64-Bit/ConvertingYourAppto64-Bit.html 对于返回结构体的方法，如果使用objc_msgSend进行调用是会抛出异常EXC_BAD_ACCESS： 12CGSize (*action)(id, SEL, int) = (CGSize (*)(id, SEL, int)) objc_msgSend;CGSize size = action(self, @selector(doSomething:), 0); 这样的做法是有可能会出现崩溃问题的（但是不一定每个程序都必然会出现），经过查看官方文档发现，objc_msgSend有一个扩展版本objc_msgSend_stret，是专门用于处理返回结构体的情况，因此把代码改为如下所示即可解决问题： 12CGSize (*action)(id, SEL, int) = (CGSize (*)(id, SEL, int)) objc_msgSend_stret;CGSize size = action(self, @selector(doSomething:), 0); 注：此调整只有在armv7架构下需要进行调整，如果包含arm64则不需要。","categories":[],"tags":[]},{"title":"ReactiveCocoa 和 MVVM 入门","slug":"ReactiveCocoa-和-MVVM-入门","date":"2015-06-26T13:04:05.000Z","updated":"2016-06-29T13:28:49.000Z","comments":true,"path":"2015/06/26/ReactiveCocoa-和-MVVM-入门/","link":"","permalink":"http://pro.stonepark.fun/2015/06/26/ReactiveCocoa-和-MVVM-入门/","excerpt":"MVC任何一个正经开发过一阵子软件的人都熟悉MVC，它意思是Model View Controller, 是一个在复杂应用设计中组织代码的公认模式. 它也被证实在 iOS 开发中有着第二种含义: Massive View Controller(重量级视图控制器)。它让许多程序员绞尽脑汁如何去使代码被解耦和组织地让人满意. 总的来说, iOS 开发者已经得出结论: 他们需要给视图控制器瘦身, 并进一步分离事物;但该怎么做呢? MVVM于是MVVM流行起来, 它代表Model View View-Model, 它在这帮助我们创建更易处理, 更佳设计的代码. 在有些情况违背苹果建议的编码方式不是很能讲得通。我不是说不赞成这样子, 我指的是可能会弊大于利。比如我不建议你去实现个自己的 view controller 基类并试着自己处理视图生命周期. 带着这种情绪, 我想提个问题: 使用除苹果推荐的 MVC 之外的应用设计模式是愚蠢的么? 不，有两个原因。 苹果没有为解决重量级试图控制器问题提供真正的指导. 他们留给我们来解决如何向代码添加更多清晰的思路. 用 MVVM 来实现这个目的想必是极好哒. (在今年 WWDC 的一些视频中, 苹果工程师在屏幕上的示例代码的确少许出现了 view-model, 不知道是否因为有它才成为了示例代码) MVVM, 至少是我将要在这里展示的 MVVM 的风格, 都跟 MVC 十分兼容. 仿佛我们将 MVC 进行到下一个逻辑步骤. 我不会提及 MVC/MVVM 的历史, 因为其他地方已经有所介绍, 并且我也不精通. 我将会关注如何用它进行 iOS/Mac 开发.","text":"MVC任何一个正经开发过一阵子软件的人都熟悉MVC，它意思是Model View Controller, 是一个在复杂应用设计中组织代码的公认模式. 它也被证实在 iOS 开发中有着第二种含义: Massive View Controller(重量级视图控制器)。它让许多程序员绞尽脑汁如何去使代码被解耦和组织地让人满意. 总的来说, iOS 开发者已经得出结论: 他们需要给视图控制器瘦身, 并进一步分离事物;但该怎么做呢? MVVM于是MVVM流行起来, 它代表Model View View-Model, 它在这帮助我们创建更易处理, 更佳设计的代码. 在有些情况违背苹果建议的编码方式不是很能讲得通。我不是说不赞成这样子, 我指的是可能会弊大于利。比如我不建议你去实现个自己的 view controller 基类并试着自己处理视图生命周期. 带着这种情绪, 我想提个问题: 使用除苹果推荐的 MVC 之外的应用设计模式是愚蠢的么? 不，有两个原因。 苹果没有为解决重量级试图控制器问题提供真正的指导. 他们留给我们来解决如何向代码添加更多清晰的思路. 用 MVVM 来实现这个目的想必是极好哒. (在今年 WWDC 的一些视频中, 苹果工程师在屏幕上的示例代码的确少许出现了 view-model, 不知道是否因为有它才成为了示例代码) MVVM, 至少是我将要在这里展示的 MVVM 的风格, 都跟 MVC 十分兼容. 仿佛我们将 MVC 进行到下一个逻辑步骤. 我不会提及 MVC/MVVM 的历史, 因为其他地方已经有所介绍, 并且我也不精通. 我将会关注如何用它进行 iOS/Mac 开发. 定义 MVVM Model - model 在 MVVM 中没有真正的变化. 取决于你的偏好, 你的 model 可能会或可能不会封装一些额外的业务逻辑工作. 我更倾向于把它当做一个容纳表现数据-模型对象信息的结构体, 并在一个单独的管理类中维护的创建/管理模型的统一逻辑。 View - view 包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作。 View-Model 这个术语本身会带来困惑, 因为它混搭了两个我们已知的术语, 但却是完全不同的东东. 它不是传统数据-模型结构中模型的意思(又来了, 只是我喜欢这个例子). 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据。 关于 view-model 的更多内容 view-model 一词的确不能充分表达我们的意图. 一个更好的术语可能是 “View Coordinator”(感谢Dave Lee提的这个 “View Coordinator” 术语, 真是个好点子)。你可以认为它就像是电视新闻主播背后的研究人员和作家团队。它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。 MVC 世界中的 MVVM我认为 MVVM 这个首字母缩写如同 view-model 术语一样, 对如何使用它们进行 iOS 开发体现得有点不太准确. 让我们再检查下这个首字母缩写, 了解下它是怎么与 MVC 融为一体的。 为了图解表示, 我们颠倒了 MVC 中的 V 和 C, 于是首字母缩写更能准确地反映出组件间的关系方位, 给我们带来 MCV. 我也会对 MVVM 这么干, 将 V(iew) 移到 VM 的右边最终成为了 MVMV. (我相信这些首字母缩写起初不排成这样更合理的顺序是有原因的。) 这是这两种模式如何在 iOS 中组装在一起的简单映射: 我试图遵循区块尺寸(非常)大致对应它们负责的工作量。 注意到视图控制器有多大? 你可以看到我们巨大的视图控制器和 view-model 之间有大块工作上的重合。 你也可以看看视图控制器在 MVVM 中的足迹有多大一部分是跟视图重合的。 你大可安心获知我们并没有真的去除视图控制器的概念或抛弃 “controller” 术语来匹配 MVVM。 (唷. )我们正要将重合的那块工作剥离到 view-model 中, 并让视图控制器的生活更加简单。 我们实际上最终以 MVMCV 告终. Model View-Model Controller View. 我确信我无拘无束的应用设计模式骇客行为会让人大吃一惊。 我们的结果: 现在视图控制器仅关注于用 view-model 的数据配置和管理各种各样的视图, 并在先关用户输入时让 view-model 获知并需要向上游修改数据. 视图控制器不需要了解关于网络服务调用, Core Data, 模型对象等. (事实上有时通过 view-model 头文件而不是复制一大堆属性来暴漏 model 是很务实的, 后面还会有) view-model 会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离. 帮助你理解我们如何把组件组装在一起还有组件对应职责的另一种方式, 就是着眼于我们新的应用构建模块层级图. View-Model 和 View Controller, 在一起，但独立我们来看个简单的 view-model 头文件来对我们新构件的长相有个更好地概念. 为了情节简单, 我们构建按了一个伪造的推特客户端来查看任何推特用户的最新回复, 通过输入他们的姓名并点击 “Go”. 我们的样例界面将会是这样: 有一个让用户输入他们姓名的 UITextField , 和一个写着 “Go” 的 UIButton 有显示被查看的当前用户头像和姓名的 UIImageView 和 UILabel 各一个 下面放着一个显示最新回复推文的 UITableView 允许无限滚动 View-Model 实例我们的 view-model 头文件应该长这样: 12345678910111213//MYTwitterLookupViewModel.h@interface MYTwitterLookupViewModel: NSObject @property (nonatomic, assign, readonly, getter=isUsernameValid) BOOL usernameValid;@property (nonatomic, strong, readonly) NSString *userFullName;@property (nonatomic, strong, readonly) UIImage *userAvatarImage;@property (nonatomic, strong, readonly) NSArray *tweets;@property (nonatomic, assign, readonly) BOOL allTweetsLoaded; @property (nonatomic, strong, readwrite) NSString *username; - (void) getTweetsForCurrentUsername;- (void) loadMoreTweets; 相当直截了当的填充. 注意到这些壮丽的 readonly 属性了么?这个 view-model 暴漏了视图控制器所必需的最小量信息, 视图控制器实际上并不在乎 view-model 是如何获得这些信息的. 现在我们两者都不在乎. 仅仅假定你习惯于标准的网络服务请求, 校验, 数据操作和存储. view-model 不做的事儿 对视图控制器以任何形式直接起作用或直接通告其变化 View Controller(视图控制器) 视图控制器从 view-model 获取的数据将用来: 当 usernameValid 的值发生变化时触发 “Go” 按钮的 enabled 属性 当 usernameValid 等于 NO 时调整按钮的 alpha 值为0. 5(等于 YES 时设为1. 0) 更新 UILable 的 text 属性为字符串 userFullName 的值 更新 UIImageView 的 image 属性为 userAvatarImage 的值 用 tweets 数组中的对象设置表格视图中的 cell (后面会提到) 当滑到表格视图底部时如果 allTweetsLoaded 为 NO, 提供一个 显示 “loading” 的 cell 视图控制器将对 view-model 起如下作用: 每当 UITextField 中的文本发生变化, 更新 view-model 上仅有的 readwrite 属性 username 当 “Go” 按钮被按下时调用 view-model 上的 getTweetsForCurrentUsername 方法 当到达表格中的 “loading” cell 时调用 view-model 上的 loadMoreTweets 方法 视图控制器不做的事儿: 发起网络服务调用 管理 tweets 数组 判定 username 内容是否有效 将用户的姓和名格式化为全名 下载用户头像并转成 UIImage(如果你习惯在 UIImageView 上使用类别从网络加载图片, 你可以暴漏 URL 而不是图片. 这样没有让 view-model 和 UIKit 更完全摆脱, 但我视 UIImage 为数据而非数据的确切显示. 这些东西不是固定死的. ) 流汗 请再次注意视图控制器总的责任是处理 view-model 中的变化. 子 View-Model我提到过使用 view-model 上的 tweets 数组中的对象配置表格视图的 cell. 通常你会期待展现 tweets 的是数据-模型对象. 你可能已经对其感到奇怪, 因为我们试图通过 MVVM 模式不暴漏数据-模型对象. (前面提到过的) view-model 不必在屏幕上显示所有东西. 你可用子 view-model 来代表屏幕上更小, 更潜在被封装的部分. 如果一个视图上的一小块儿(比如表格的 cell)在 app 中可以被重用以及(或)表现多个数据-模型对象, 子 view-model 会格外有利. 你不总是需要子 view-model. 比如, 我可能用表格 header 视图来渲染我们“tweetboat plus”应用的顶部. 它不是个可重用的组件, 所以我可能仅是将我们已经给视图控制器用过的相同的 view-model 传给那个自定义的 header 视图. 它会用到 view-model 中它需要的信息, 而无视余下的部分. 这对于保持子视图同步是极好的方式, 因为它们可以有效地与信息中相同确切的上下文作用, 并观察确切相同属性的更新. 在我们的例子中, tweets 数组将会被下面这样的子 view-model 充满: 123456//MyTweetCellViewModel.h@interface MYTweetCellViewModel: NSObject @property (nonatomic, strong, readonly) NSString *tweetAuthorFullName;@property (nonatomic, strong, readonly) UIImage *tweetAuthorAvatarImage;@property (nonatomic, strong, readonly) NSString *tweetContent; 你可能认为这也太像普通”推特”里的数据-模型对象了吧. 为啥要干将其转化成 view-model 的工作?即使类似, view-model 让我们限制信息只暴露给我们需要的地方, 提供额外数据转换的属性, 或为特定的视图计算数据. (此外, 当可以不暴露可变数据-模型对象时也是极好的, 因为我们希望 view-model 自己承担起更新它们的任务, 而不是靠视图或视图控制器. ) View-Model 从哪来?那么 view-model 是何时何处被创建的呢?视图控制器创建它们自己的 view-model 么? View-Model 产生 View-Model严格来说, 你应该为 app delegate 中的顶级视图控制器创建一个 view-model. 当展示一个新的视图控制器时, 或很小的视图被 view-model 表现时, 你应要求当前的 view-model 为你创建一个子 view-model. 加入我们想要在用户轻拍应用顶部的头像时添加一个资料视图控制器. 我们可以为一级 view-model 添加类似如下方法: 1- (MYTwitterUserProfileViewModel *) viewModelForCurrentUser; 然后在我们的一级视图控制器中这么用它: 123456789//MYMainViewController.m - (IBAction) didTapPrimaryUserAvatar&#123; MYTwitterUserProfileViewModel *userProfileViewModel = [self.viewModel viewModelForCurrentUser]; MYTwitterUserProfileViewController *profileViewController = [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; [self.navigationController pushViewController: profileViewController animated:YES];&#125; 在这个例子中我将会展现当前用户的资料视图控制器, 但是我的资料视图控制器需要一个 view-model. 我这的主视图控制器不知道(也不该知道)用于创建关联相关用户 view-model 的全部必要数据, 所以它请求它自己的 view-model 来干这种创建新 view-model 的苦差事. View-Model 列表 至于我们的推特 cell, 当数据驱动屏幕(在这个例子中或许是通过网络服务调用)聚到一起时, 我将会代表性地提前为对应的 cell 创建所有的 view-model. 所以在我们这个方案中, tweets 将会是一个 MYTweetCellViewModel 对象数组. 在我的表格视图中的 cellForRowAtIndexPath 方法中, 我将会在正确的索引上简单地抓取 view-model, 并把它赋值给我的 cell 上的 view-model 属性 Functional Core, Imperative Shellview-model 这种通往应用设计的方法是一块应用设计之路上的垫脚石, 这种被称作“Functional Core, Imperative Shell”的应用设计由Gary Bernhardt创造. (我最近十分有幸去听Andy Matuschak关于这方面的演讲, 他为”胖的数值层, 瘦的对象层”提出充分理由. 虽然观点相似, 但关注于我们怎样移除对象和它们状态的边界影响性质, 并用 Swift 中的新数据结构构建更加函数式, 可测试的数值层. ) Functional Core view-model 就是 “functional core”, 尽管实际上在 iOS/Objective-C 中达到纯函数水平是很棘手的(Swift 提供了一些附加的函数性, 这会让我们更接近). 大意是让我们的 view-model 尽可能少的对剩余的”应用世界”的依赖和影响. 那意味着什么?想起你第一次学编程时可能学到的简单函数吧. 它们可能接受一两个参数并输出一个结果. 数据输入, 数据输出.这个函数可能是做一些数学运算或是将姓和名结合到一起. 无论应用的其他地方发生啥, 这个函数总是对相同的输入产生相同的输出. 这就是函数式方面. 这就是我们为 view-model 谋求的东西. 他们富有逻辑和转换数据并将结果存到属性的功能. 理想上相同的输入(比如网络服务响应)将会导出相同的输出(属性的值). 这意味着尽可能多地消除由”应用世界”剩余部分带来的可能影响输出的因素, 比如使用一堆状态. 一个好的第一步就是不要再 view-model 头文件中引入 UIKit.h.(这是个重大原则, 但也有些灰色区域. 比如, 你可能认为 UIImage 是数据而不是展示信息. PS: 我爱这么干. 既然这样的话就得引入 UIKit. h 以便使用 UIImage 类)UIKit 其性质就是将要影响许多应用世界. 它包含很多”副作用”, 凭借改变一个值或调用一个函数将触发很多间接(甚至未知)的改变. 更新: 刚刚看了 Andy 在函数式 Swift 会议上给出的另一个超赞的演讲, 于是又想到了一些. 要清楚你的 view-model 仍然只是一个对象, 而不用维护一些状态(否则它将不会是你视图中非常好用的模型了. )但你仍该努力将尽可能多的逻辑移到无状态的函数”值”中. 再重复一次, Swift在这方面比 Objective-C 更加可行. Imperative (Declarative?) Shell 命令式外壳 (Imperative Shell) 是我们需要做所有的状态转换, 应用世界改变的苦差事的地方, 为的是将 view-model 数据转成给用户在屏幕上看到的东西. 这是我们的视图(控制器), 实际上我们在这分离 UIKit 的工作. 我仍将特别注意尽可能消除状态并用 ReactiveCocoa 这种陈述性质的东西做这方面工作, 而 iOS 和 UIKit 在设计上是命令式的. (表格的 data source 就是个很好的例子, 因为它的委托模式强制将状态应用到委托中, 为了当请求发生时能够为表格视图提供信息. 实际上委托模式通常强制一大堆状态的使用) 可测试的核心 iOS 的单元测试是个脏, 苦, 乱的活儿. 至少我去做的时候得出的是这么个结论. 就这方面我还出读过一两本书, 但当开始做视图控制器的 mocking 和 swizzling 使其一些逻辑可测试时, 我目光呆滞. 我最终把单元测试归入模型和任何同类别模型管理类中. (译者注: mock 是测试常用的手段, 而 method swizzling 是基于 Objective-C Runtime 交换方法实现的黑魔法) 这个函数式核心一样的 view-model 的最大优点, 除了 bug 数量随着状态数递减之外, 就是变得非常能够进行单元测试. 如果你有那种每次输入相同而产生的输出也相同的方法, 那就非常适合单元测试的世界. 我们现在将我们的数据用获取/逻辑/转换提取出, 避免了视图控制器的复杂性. 那意味着构建棒棒哒测试时不需要用疯狂的 mock 对象, method swizzling, 或其他疯癫的变通方法(希望能有). 连接一切那么当 view-model 的共有属性发生变化时我们如何更新我们的视图呢? 绝大部分时间我们用对应的 view-model 来初始化视图控制器, 有点类似我们刚刚在上文见到的: 12MYTwitterUserProfileViewController *profileViewController = [[MYTwitterUserProfileViewController alloc] initWithViewModel: userProfileViewModel]; 有时你无法在初始化时将 view-model 传入, 比如在 storyboard segue 或 cell dequeuing 的情况下. 这时你应该在讨论中的视图(控制器)中暴露一个公有可写的 view-model 属性. 1234MYTwitterUserCell *cell = [self. tableView dequeueReusableCellWithIdentifier: @\"MYTwitterUserCell\" forIndexPath: indexPath];// grab the cell view-model from the vc view-model and assign itcell. viewModel = self. viewModel. tweets[indexPath. row]; 有时我们可以在钩子程序调用前传入 view-model, 比如 init 和 viewDidLoad, 我们可以从view-model 的属性初始化所有 UI 元素的状态. 12345678910111213//dontDoThis1.m - (id) initWithViewModel:(MYTwitterLookupViewModel *) viewModel &#123; self = [super init]; if (!self) return nil; _viewModel = viewModel; return self;&#125;- (void) viewDidLoad &#123; [super viewDidLoad]; _goButton.enabled = viewModel.isUsernameValid; _goButton.alpha = viewModel.isUsernameValid ? 1 : 0.5; // etc&#125; 好棒!我们已经配置好了初始值. 当 view-model 上的数据改变时怎么办? 当”go” 按钮在什么时候可用了怎么办?当用户标签和头像在什么时候从网络上下载并填充了怎么办? 我们可以将视图控制器暴露给 view-model, 以便于当相关数据变化或类似事件发送时它可以调用一个 “updateUI” 方法. (别这么干. )在 view-model 上将视图控制器作为一个委托?当 view-model 内容有变化时发个通知?(不不不不. ) 我们的视图控制器会感知一些变化的发生. 我们可以使用从 UITextfield 得来的委托方法在每当有字符变化时通过检查 view-model 来更新按钮的状态. 12345678//dontDoThisEither.m- (void)textFieldDidChange:(UITextField *)sender &#123; // update the view-model self.viewModel.username = sender.text; // check if things are now valid self.goButton.enabled = self.viewModel.isUsernameValid; self.goButton.alpha = self.viewModel.isUsernameValid ? 1.0 : 0.5;&#125; 这种方法解决的场景是在只有再文本框发生变化时才会影响 view-model 中的 isUsernameValid 值. 假使还有其他变量/动作改变 isUsernameValid 的状态将会怎么样?对于 view-model 中的网络调用会怎么样?或许我们该为 view-model 上的方法加一个完成后回调处理, 这样我们此时就可以更新 UI 的一切东西了?使用珍贵而笨重的 KVO 方法怎么样? 我们或许最终使用多种多样我们熟悉的机制将 view-model 和视图控制器所有的接触点都连起来, 但你已经知道了标题上不是这么写的. 这样在代码中创建了大量的入口点, 仅仅为了简单的更新 UI 就要在代码中完全重新创建应用状态上下文. 进入 ReactiveCocoaReactiveCocoa(RAC) 是来拯救我们的, 并恰好返回给我们一点理智. 让我们看看如何做到. 思考在一个新的用户页面上控制信息的流动, 当表单合法时更新提交按钮的状态. 你现在可能会照下面这么做: 你最后通过使用状态, 小心翼翼地代码中许多不同且零碎无关的内容穿到简单的逻辑上. 看看你信息流中所有不同的入口点?(这还只是一个 UI 元素中的一条逻辑线. )我们程序中现在用的抽象概念还不够厉害, 不能为我们追踪所有事物的关系, 所以我们停止自己去干这蛋疼事儿. 让我们看看陈述版本: 这看起来可能像是为我们应用流程文档中的一张老旧的计算机科学图解. 通过陈述式的编程, 我们使用了更高层次的抽象, 来让我们实际编程更靠近我们在脑海中设计流程的方式. 我们让电脑为我们做更多工作. 实际的代码更加像这幅图了. RACSignal RACSignal (信号)就 RAC 来说是构造单元. 它代表我们最终将要收到的信息. 当你能将未来某时刻收到的消息具体表示出来时, 你可以开始预先(陈述性)运用逻辑并构建你的信息流,而不是必须等到事件发生(命令式). 信号会为了控制通过应用的信息流而获得所有这些异步方法(委托, 回调 block, 通知, KVO, target/action 事件观察, 等)并将它们统一到一个接口下.这只是直观理解. 不仅是这些, 因为信息会流过你的应用, 它还提供给你轻松转换/分解/合并/过滤信息的能力. 那么什么是信号呢?这是一个信号: 信号是一个发送一连串值的物体. 但是我们这儿的信号啥也不干, 因为它还没有订阅者. 如果有订阅者监听时(已订阅)信号才会发信息. 它将会向那个订阅者发送0或多个载有数值的”next”事件, 后面跟着一个”complete”事件或一个”error”事件. (信号类似于其他语言/工具包中的 “promise”, 但更强大, 因为它不仅限于向它的订阅者一次只传递一个返回值. ) 正如我之前提到的, 如果觉得需要的话你可以过滤, 转换, 分解和合并那些值. 不同的订阅者可能需要使用信号通过不同方式发送的值. 信号发送的值是从哪获得的? 信号是一些等待某事发生的异步代码, 然后把结果值发送给它们的订阅者. 你可以用 RACSignal 的类方法 createSignal: 手动创建信号: 123456789//networkSignal.mRACSignal *networkSignal = [RACSignal createSignal:^RACDisposable *(idsubscriber) &#123; NetworkOperation *operation = [NetworkOperation getJSONOperationForURL:@\"http://someurl\"]; [operation setCompletionBlockWithSuccess:^(NetworkOperation *theOperation, id *result) &#123; [subscriber sendNext:result]; [subscriber sendCompleted]; &#125; failure:^(NetworkOperation *theOperation, NSError *error) &#123; [subscriber sendError:error]; &#125;]; 我在这用一个具有成功和失败 block (伪造)的网络操作创建了一个信号. (如果我想让信号在被订阅时才让网络请求发生, 还可以用 RACSignal 的类方法 defer. )我在成功的 block 里使用提供的 subscriber 对象调用 sendNext: 和 sendCompleted: 方法, 或在失败的 block 中调用 sendError:. 现在我可以订阅这个信号并将在响应返回时接收到 json 值或是 error. 幸运的是, RAC 的创造者实际上使用它们自己的库来创建真的事物(捉摸一下), 所以对于我们在日常需要什么, 他们有很强烈的想法. 他们为我们提供了很多机制, 来从我们通常使用的现存的异步模式中拉取信号. 别忘了如果你有一个没有被某个内建信号覆盖到的异步任务, 你可以很容易地用 createSignal: 或类似方法来创建信号. 一个被提供的机制就是 RACObserve() 宏. (如果你不喜欢宏, 你可以简单地看看罩子下面并用稍微多些冗杂的描述. 这也非常好. 在我们得到 Swift 版本的替代之前, 这也有在 Swift 中使用 RAC 的解决方案. )这个宏是 RAC 中对 KVO 中那些悲惨的 API 的替代. 你只需要传入对象和你想观察的那个对象某属性的 keypath. 给出这些参数后, RACObserve 会创建一个信号, 一旦它有了订阅者, 它就立刻发送那个属性的当前值, 并在发送那个属性在这之后的任何变化. 1RACSignal *usernameValidSignal = RACObserve(self. viewModel, usernameIsValid); 这仅是提供用于创建信号的一个工具. 这里有几个立即可用的方式, 来从内置控制流机制中拉取信号: 12345678910111213141516171819//signals.mRACSignal *controlUpdate = [myButton rac_signalForControlEvents:UIControlEventTouchUpInside]; // signals for UIControl events send the control event value (UITextField, UIButton, UISlider, etc) // subscribeNext:^(UIButton *button) &#123; NSLog(@\"%@\", button); // UIButton instance &#125; RACSignal *textChange = [myTextField rac_textSignal]; // some special methods are provided for commonly needed control event values off certain controls // subscribeNext:^(UITextField *textfield) &#123; NSLog(@\"%@\", textfield.text); // \"Hello!\" &#125; RACSignal *alertButtonClicked = [myAlertView rac_buttonClickedSignal]; // signals for some delegate methods send the delegate params as the value // e.g. UIAlertView, UIActionSheet, UIImagePickerControl, etc // (limited to methods that return void) // subscribeNext:^(NSNumber *buttonIndex) &#123; NSLog(@\"%@\", buttonIndex); // \"1\" &#125; RACSignal *viewAppeared = [self rac_signalForSelector:@selector(viewDidAppear:)]; // signals for arbitrary selectors that return void, send the method params as the value // works for built in or your own methods // subscribeNext:^(NSNumber *animated) &#123; NSLog(@\"viewDidAppear %@\", animated); // \"viewDidAppear 1\" &#125; 记住你也能轻松创建自己的信号, 包括替代那些没有内建支持的其他委托. 我们现在能够从所有这些不连贯的异步/控制流工具中拉取出信号并将他们合并, 试想想这该多酷!这些会成为我们之前看到的陈述性图表中的节点. 真是兴奋. 什么是订阅者? 简言之, 订阅者就是一段代码, 它等待信号给它发送一些值, 然后订阅者就能处理这些值了. (它也可以作用于 “complete” 和 “error” 事件. ) 这有一个简单的订阅者, 是通过向信号的实例方法 subscribeNext 传入一个 block 来创建的. 我们在这通过 RACObserve() 宏创建信号来观察一个对象上属性的当前值, 并把它赋值给一个内部属性. 123456789- (void) viewDidLoad &#123; // . . . // create and get a reference to the signal RACSignal *usernameValidSignal = RACObserve(self. viewModel, isUsernameValid); // update the local property when this value changes [usernameValidSignal subscribeNext: ^(NSNumber *isValidNumber) &#123; self. usernameIsValid = isValidNumber. boolValue &#125;];&#125; 注意 ：RAC 只处理对象, 而不处理像 BOOL 这样的原始值. 不过不用担心, RAC 通常会帮你这些转换. 幸运的是 RAC 的创造者也意识到这种绑定行为的普遍必要性, 所以他们提供了另一个宏 RAC(). 与 RACObserve() 相同, 你提供想要与即将到来的值绑定的对象和参数, 在其内部它所做的是创建一个订阅者并更新其属性的值. 我们的例子现在看起来像这样: 1234- (void) viewDidLoad &#123; //. . . RAC(self, usernameIsValid) = RACObserve(self. viewModel, isUsernameValid);&#125; 考虑下我们的目标, 这么干有点傻啊. 我们不需要将信号发送的值存到属性中(这会创建状态), 我们真正要做的是用从那个值获取到信息来更新 UI. 转换数据流 现在我们进入 RAC 为我们提供的用于转换数值流的方法. 我们将会利用 RACSignal 的实例方法 map. 12345678910//transformingStreams.m- (void) viewDidLoad &#123; //... RACSignal *usernameIsValidSignal = RACObserve(self.viewModel, isUsernameValid); RAC(self.goButton, enabled) = usernameIsValidSignal; RAC(self.goButton, alpha) = [usernameIsValidSignal map:^id(NSNumber *usernameIsValid) &#123; return usernameIsValid.boolValue ? @1.0 : @0.5; &#125;];&#125; 这样现在我们将 view-model 上的 isUsernameValid 发生的变化直接绑定到 goButton 的 enabled 属性上. 酷吧?对 alpha 的绑定更酷, 因为我们正在使用 map 方法将值转换成与 alpha 属性相关的值. (注意在这里我们返回的是一个 NSNumber 对象而不是原始float值. 这基本上是唯一的污点: 你需要负责为 RAC 将原始值转化为对象, 因为它不能帮你导出来. 多个订阅者, 副作用, 昂贵的操作 订阅信号链时要明白重要的一件事是每当一个新值通过信号链被发送出去时, 实际上会给每个订阅者都发送一次. 直到意识到这就我们而言是有意义的, 信号发出的值不存储在任何地方(除了 RAC 在内部实现中). 当信号需要发送一个新的值时, 它会遍历所有的订阅者并给每个订阅者发送那个值. (这是对信号链实际工作的简化说明, 但基本想法是对的) 这为什么重要?这意味着信号链某处存在的任何副作用, 任何影响应用世界的转变, 将会发生多次. 这对新接触 RAC 的用户来说是意想不到的. (这也违反了函数式构建的理念-数据输入, 数据输出). 一个做作的例子可能是: 信号链某处的信号在每次按钮被按下时更新 self 中的一个计数器属性. 如果信号链有多个订阅者, 计数器的增长将会比你想的还要多. 你需要努力从信号链中尽可能剔除副作用. 当副作用不可避免时, 你可以使用一些恰当的预防机制. 我将会在另一篇文章中探索. 除副作用之外, 你需要注意带有昂贵操作和可变数据的信号链. 网络请求就是一个三者兼得的例子: 网络请求影响了应用的网络层(副作用). 网络请求为信号链引入了可变数据. (两个完全一样请求可能返回了不同的数据. ) 网络请求反应慢啊. 例如, 你可能有个信号在每次按钮按下时发送一个值, 而你想将这个值转换成网络请求的结果. 如果有多个订阅者要这个处理信号链上返回的这个值, 你将发起多个网络请求. 网络请求明显是经常需要的. 正如你所期望, RAC 提供这些情况的解决方案, 也就是 RACCommand 和多点广播. 我将会在下一篇文章中更深入地分析. Tweetboat Plus既然简短的介绍(嗯哼)扯远了, 让我们着眼于如何用 ReactiveCocoa 将 view-model 与视图控制器连接起来.// 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// View Controller// - (void) viewDidLoad &#123; [super viewDidLoad]; RAC(self. viewModel, username) = [myTextfield rac_textSignal]; RACSignal *usernameIsValidSignal = RACObserve(self. viewModel, usernameValid); RAC(self. goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) &#123; return valid. boolValue ? @1 : @0. 5; &#125;]; RAC(self. goButton, enabled) = usernameIsValidSignal; RAC(self. avatarImageView, image) = RACObserve(self. viewModel, userAvatarImage); RAC(self. userNameLabel, text) = RACObserve(self. viewModel, userFullName); @weakify(self); [[[RACSignal merge: @[RACObserve(self. viewModel, tweets), RACObserve(self. viewModel, allTweetsLoaded)]] bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]] subscribeNext: ^(id value) &#123; @strongify(self); [self. tableView reloadData]; &#125;]; [[self. goButton rac_signalForControlEvents: UIControlEventTouchUpInside] subscribeNext: ^(id value) &#123; @strongify(self); [self. viewModel getTweetsForCurrentUsername]; &#125;];&#125; -(UITableViewCell*)tableView: (UITableView *)tableView cellForRowAtIndexPath: (NSIndexPath *)indexPath &#123; // if table section is the tweets section if (indexPath. section == 0) &#123; MYTwitterUserCell *cell = [self. tableView dequeueReusableCellWithIdentifier: @\"MYTwitterUserCell\" forIndexPath: indexPath]; // grab the cell view model from the vc view model and assign it cell. viewModel = self. viewModel. tweets[indexPath. row]; return cell; &#125; else &#123; // else if the section is our loading cell MYLoadingCell *cell = [self. tableView dequeueReusableCellWithIdentifier: @\"MYLoadingCell\" forIndexPath: indexPath]; [self. viewModel loadMoreTweets]; return cell; &#125;&#125; //// MYTwitterUserCell// // this could also be in cell init- (void) awakeFromNib &#123; [super awakeFromNib]; RAC(self. avatarImageView, image) = RACObserve(self, viewModel. tweetAuthorAvatarImage); RAC(self. userNameLabel, text) = RACObserve(self, viewModel. tweetAuthorFullName); RAC(self. tweetTextLabel, text) = RACObserve(self, viewModel. tweetContent);&#125; 让我们过一遍这个例子. 1RAC(self. viewModel, username) = [myTextfield rac_textSignal]; 在这我们用 RAC 库中的方法从 UITextField 拉取一个信号. 这行代码将 view-model 上的可读写属性 username 绑定到文本框上的用户输入的任何更新. 123456RACSignal *usernameIsValidSignal = RACObserve(self. viewModel, usernameValid);RAC(self. goButton, alpha) = [usernameIsValidSignal map: ^(NSNumber *valid) &#123; return valid. boolValue ? @1 : @0. 5; &#125;];RAC(self. goButton, enabled) = usernameIsValidSignal; 在这我们用 RACObserve 方法在 view-model 的 usernameValid 属性上创建了一个信号 usernameIsValidSignal. 无论何时属性发生变化, 它将会沿着管道发送一个新的 @YES 或 @NO. 我们拿到那个值并将其绑定到 goButton 的两个属性上. 首先我们将 alpha 分别对应 YES 或 NO 更新到1或0. 5(记着在这必须返回 NSNumber). 然后我们直接将信号绑定到 enabled 属性, 因为 YES 和 NO 在这无需转换就能完美地运作. 12RAC(self. avatarImageView, image) = RACObserve(self. viewModel, userAvatarImage);RAC(self. userNameLabel, text) = RACObserve(self. viewModel, userFullName); 下面我们为表头的图像视图和用户标签创建绑定, 再次在 view-model 上对应的属性上用 RACObserve 宏创建信号. 12345678@weakify(self);[[[RACSignal merge: @[RACObserve(self. viewModel, tweets), RACObserve(self. viewModel, allTweetsLoaded)]] bufferWithTime: 0 onScheduler: [RACScheduler mainThreadScheduler]] subscribeNext: ^(id value) &#123; @strongify(self); [self. tableView reloadData]; &#125;]; 这货看上去有点诡异, 所以我们在这上多花点时间. 我们想在 view-model 上 tweets 数组或 allTweetsLoaded 属性发生变化时更新表格视图. (在这个例子中, 我们要用一个简单的方法来重新加载整张表. )所以我们将这两个属性被观察后创建的两个信号合并成一个更大的信号, 当两个属性中有一个发生变化, 这个信号就会发送值. (你一贯认为信号的值是同类型的, 不会像这个信号有一样混杂的值. 这很可能在 Swift 版本的 RAC 中强制要求, 但在这我们不关心发出的真实值, 我们只是用它来触发表格式图的重新加载. ) 那么这儿看起来最吓人的部分可能是信号链中的 bufferWithTime: onScheduler: 方法. 需要它来围绕 UIKit 中的一个问题进行变通. tweets 和 allTweetsLoaded 这两个属性我们都需要追踪, 万一 tweets 变化和 allTweetsLoaded 为否(不管怎样我们都得重新加载表格). 有时两个属性都将在同一准确的时间发生变化, 意味着合并后的大信号中的两个信号都会发送一个值, 那么 reloadData 方法将会在同一个运行循环中被调用两次. UIKit 不喜欢这样. bufferWithTime: 在给明的时间内抓取所有下一个到来的值, 当给定的时间过后将所有值合在一起发给订阅者. 通过传入0作为时间, bufferWithTime: 将会抓取那个合并信号在特定的运行循环中发出的全部值, 并将他们一起发送出去. (NSTimer 以同样的方式工作, 这不是巧合, 因为 bufferWithTime: 是用 NSTimer 构建的. )暂时不用担心 scheduler, 试把它想做指明这些值必须在主线程上被发送. 现在我们确保 reloadData 每次运行循环只被调用一次. 注意我在这用 @weakify/@strongify 宏切换 strong 和 weak. 这在创建所有这些 block 时非常重要. 在 RAC 的 block 中使用 self 时self 将会被捕获为强引用并得到保留环, 除非你尤其意识到要破除保留环 12345[[self. goButton rac_signalForControlEvents: UIControlEventTouchUpInside] subscribeNext: ^(id value) &#123; @strongify(self); [self. viewModel getTweetsForCurrentUsername]; &#125;]; 我将会在下一篇文章中在这里引入 RACCommand, 但目前我们只是当按钮被触碰时手动调用 view-model 的 getTweetsForCurrentUsername 方法. 我们已经搞定了 cellForRowAtIndexPath 的第一部分, 那么我在这将只说下 loading cell: 1234MYLoadingCell *cell = [self. tableView dequeueReusableCellWithIdentifier: @\"MYLoadingCell\" forIndexPath: indexPath];[self. viewModel loadMoreTweets];return cell; 这是另一块我们以后将利用到 RACCommand 的地方, 但目前我们只是调用 view-model 的 loadMoreTweets 方法. 我们将只是信任如果 cell 显示或隐藏多次的话 view-model 会避免多次内部调用. 123456- (void) awakeFromNib &#123; [super awakeFromNib]; RAC(self. avatarImageView, image) = RACObserve(self, viewModel. tweetAuthorAvatarImage); RAC(self. userNameLabel, text) = RACObserve(self, viewModel. tweetAuthorFullName); RAC(self. tweetTextLabel, text) = RACObserve(self, viewModel. tweetContent);&#125; 这段现在应该非常直接了, 除此之外我想指出一点. 我们正在将图片和文字绑定到 UI 上对应的属性, 但注意 viewModel 出现在 RACObserve 宏中逗号右边. 这些 cell 终将被重用, 新的 view-models 将会被赋值. 如果我们不将 viewModel 放在逗号右边, 那就会监听 viewModel 属性的变化然后每次都要重新设置绑定;如果放在逗号右边, RACObserve 将会为我们负责这些事儿. 因此我们只需要设定一次绑定并让 Reactive Cocoa 做剩余的部分. 这是在绑定表格 cell 时为了性能需要记住的好东西. 我在实践中即使是有很多表格 cell 依然没有出过问题. 福利-消除更多的状态 有时候你可以在 view-model 中暴露 RACSignal 对象来替代像字符串和图像这样的属性, 这能在 view-model 上消除更多的状态. 然后视图控制器就不需要自己用 RACObserve 创建信号了, 并只是直接影响这些信号. 要意识到如果你的信号在被 UI 订阅/绑定到 UI 之前发出过一个值, 那么你将不会收到那个”初始”的值. 结论本文篇幅略长, 但别被吓着. 这还有好多没讲的, 而且是干货儿, 是舒展你大脑的好方法. 这毫无疑问是不同的编程风格. 花一会儿功夫停止机械地试图用命令式方案去解决问题. 即使你一开始不是经常用这种编程风格, 我认为这有助于理解和提醒我们有截然不同的途径来解决我们程序员的困惑. 下一次我将稍微深入 view-model 内部中本文没提到的内容, 并介绍下 RACCommand(希望篇幅能短很多). 然后我们将投入到一个真实案例中, 那是我的一个叫做Three Cents的 app 中的一个相当复杂的页面, 它混合了网络调用, CoreData, 多重 UI 状态, 等等!","categories":[],"tags":[]},{"title":"如何写一个Pod，并发布到CocoaPods上，pod发布cocoapods","slug":"如何写一个Pod，并发布到CocoaPods上，pod发布cocoapods","date":"2015-06-24T23:33:14.000Z","updated":"2016-07-08T17:34:56.000Z","comments":true,"path":"2015/06/25/如何写一个Pod，并发布到CocoaPods上，pod发布cocoapods/","link":"","permalink":"http://pro.stonepark.fun/2015/06/25/如何写一个Pod，并发布到CocoaPods上，pod发布cocoapods/","excerpt":"cocoapods就不用介绍了，是iOS开发的一个第三方库管理工具。 本文主要介绍如何自己写一个pod，然后注册到CocoaPods上，并将代码放到Github上供别人下载。这基本上是任何一个pod的“标准”上架流程。当然你也可以将pod放到其他的git平台上。 大家可以先看一下我自己写的一个pod，gitub地址，如果你觉得本文对你有帮助，欢迎start和fork ^ ^ 前言一直以来想写一个pod来练练手，但是很多时候都是写到一半就不了了之了，这次写的这个pod，是从之前做过的一个项目中提炼出来的，代码量不大，实现也不是很复杂。主要还是想通过写一个pod来了解pod的发布流程。所以本文的重点不是在代码本身上。 准备工作本文是假设读者对pod和git有一定了解的基础上进行的。git，pod该安装的安装好，没安装的自己去Google吧。我这次使用的pod版本是v0.36，不过版本对本文的影响应该不大。","text":"cocoapods就不用介绍了，是iOS开发的一个第三方库管理工具。 本文主要介绍如何自己写一个pod，然后注册到CocoaPods上，并将代码放到Github上供别人下载。这基本上是任何一个pod的“标准”上架流程。当然你也可以将pod放到其他的git平台上。 大家可以先看一下我自己写的一个pod，gitub地址，如果你觉得本文对你有帮助，欢迎start和fork ^ ^ 前言一直以来想写一个pod来练练手，但是很多时候都是写到一半就不了了之了，这次写的这个pod，是从之前做过的一个项目中提炼出来的，代码量不大，实现也不是很复杂。主要还是想通过写一个pod来了解pod的发布流程。所以本文的重点不是在代码本身上。 准备工作本文是假设读者对pod和git有一定了解的基础上进行的。git，pod该安装的安装好，没安装的自己去Google吧。我这次使用的pod版本是v0.36，不过版本对本文的影响应该不大。 开始用xcode写pod的时候，应该将作为pod的代码和自己的example代码在目录上分开（物理和逻辑上），后面在配置podspec文件时要指定目录的。还有就是工程的命名最好加上特殊的前缀，否则在注册pod时，可能会出现重名冲突。 1.在Github上新建一个repo1234567以下操作都是在terminal下完成的。1) 如果本地代码没有被git管理，则cd到工程目录，执行git init。2) git add origin &apos;github_repo_url&apos; //将github上新建的repo url添加进来。3) git remote -v //检查以下是否添加成功4) git commit -am &quot;init commmit&quot;5) git pull origin6) git push origin 2.README.md这个文件对于推广自己的pod非常重要，要让别人了解你的pod的用法，作用，都是通过这个文件表现出来的。可以参照一下我的repo中README文件的格式写法。这个文件是用Markdown语法写的，如果对MD语法不熟悉，请Google。 大家可能看到在这个文件中有一个Gif的动画，这里推荐一个工具叫做LICEcap，很小巧的一款屏幕录制工具，录制完记得要保存成gif格式的，然后将保存好的git图片放到项目中，然后在README中将路径指向gif就行。 3.podspec终于到了这一步，这一步也是我遇到很多坑的地方，查阅的时候资料也不是特别的多，而且基本都是英文的。 先在自己的工程目录上建立一个podspec文件，文件的命名方式是：podName.podspec ,podName是你pod的名称，应该与工程名相同。后缀是podspec。 先把我自己的podspec文件贴上来： 123456789101112131415#CXLSlideList.podspecPod::Spec.new do |s| s.name = &quot;CXLSlideList&quot; s.version = &quot;1.0.0&quot; s.summary = &quot;a light weight and easy to use tableview slide effect.&quot; s.homepage = &quot;https://github.com/becomedragon/CXLSlideList&quot; s.license = &apos;MIT&apos; s.author = &#123; &quot;Becomedragon Cheng&quot; =&gt; &quot;becomedragonlong@gmail.com&quot; &#125; s.platform = :ios, &quot;7.0&quot; s.ios.deployment_target = &quot;7.0&quot; s.source = &#123; :git =&gt; &quot;https://github.com/becomedragon/CXLSlideList.git&quot;, :tag =&gt; s.version&#125; s.source_files = &apos;CXLSlideList/CXLSlideList/*.&#123;h,m&#125;&apos; s.requires_arc = trueend podspec文件中有很多参数，但并不是每一个都能用上，我写的这个podspec文件中的参数基本上够用了。这个文件使用ruby语言写的，所以如果有ruby语言的功底看这个代码应该很熟悉，当然没有也没关系，因为理解起来实在太简单了。 下面还是挨个对每个参数介绍下： name ：pod的名字，应该与你的工程名保持一致 version： 版本号，你以为是你工程的版本号，那你就大错特错了，我在这个地方坑了好久。后来才知道这个version是和你的branch名称保持一致的，如果你的branch名字叫做1.0.0，那这个version就可以要写成1.0.0，当更新版本的时候，要重新建立一个branch命名为1.0.1，然后version也要写成1.0.1。 summary：一句话介绍你的pod homepage：pod的url地址 license：你的pod所遵守的开源协议、 一般都是‘MIT’ author： 作者名，联系方式 platform：pod所支持平台和最小系统版本 ios.deployment_target：同上 source：pod的地址和tag source_files：pod在工程中的所在目录，如果有多个不同的目录，则写成这种形式 :’floder1…’,’floder2….’,’….’11.requires_arc：是否是ARC。 ok，认真填写podspec文件。已经成功了一大半了。这里还要注意一个问题，source_files中指定的.h .m文件一定不要引用source _files以外文件中的变量，头文件等，不然后面会出错。source _files中的文件应该是独立的模块。 4.CocoaPods注册，上传如果要让别人通过 pod ‘CXLSlideList’ 这种方式来引用你的pod，就要先将自己的pod在cocoapods上注册声明，当然，如果前面的步骤都正确的话，注册声明将是非常简单的一个过程。 在cocoapods中注册 12在terminal里输入：pod trunk register YOUR_EMAIL &apos;YOUR_NAME&apos; 然后你会收到一封邮件，点击确认一下。 验证podspec文件的合法性 12cd进你的工程目录,输入下面命令：pod spec lint 这个是验证podspec的合法性，并根据podspec文件对工程进行编译，在命令后面加上 –verbose 可以看到相信执行步骤。 这个步骤可以会经常往返，如果出错的话，会有提示，可能是编译出错，可能是其他错误，如果是编译出错就要看看你自己的代码了。当然，代码改好后要push到github上。 也许你会遇到一个错误叫做：Could not find remote branch x.x.x to clone你遇到这个问题说明还是没有看懂我之前写的对于version的解释。 x.x.x是你在podspec中写的版本号。假如这里是1.0.0，你要先看看自己有没有创建一个叫做1.0.0的分支，然后将1.0.0这个分支push到github上，然后切换到1.0.0这个分支上，在重复执行上面的命令即可。 上面的命令执行后，不能由任何的error和warning，否则下一步无法完成。 push podspec到了这一步，基本上可以说是大功告成了，执行下面的命令，将podspec push到cocoapods上，如果你不幸与某一个志气其他人podspec重名的话，则cocoapods会提示你，名字被占用，这个问题我是没有遇到过。估计只能改名了吧。1pod trunk push PodName.podspec OK，基本上就介绍到这里了。如果想继续研究可以通过 –help查看其它命令。good luck &amp; have fun ^^","categories":[],"tags":[]},{"title":"CAShapeLayer的strokeStart和strokeEnd属性","slug":"CAShapeLayer的strokeStart和strokeEnd属性","date":"2015-03-25T23:40:29.000Z","updated":"2016-06-22T23:43:33.000Z","comments":true,"path":"2015/03/26/CAShapeLayer的strokeStart和strokeEnd属性/","link":"","permalink":"http://pro.stonepark.fun/2015/03/26/CAShapeLayer的strokeStart和strokeEnd属性/","excerpt":"","text":"keyPath = strokeStart 动画的fromValue = 0，toValue = 1 表示从路径的0位置画到1 怎么画是按照清除开始的位置也就是清除0 一直清除到1 效果就是一条路径慢慢的消失 keyPath = strokeStart 动画的fromValue = 1，toValue = 0 表示从路径的1位置画到0 怎么画是按照清除开始的位置也就是1 这样开始的路径是空的（即都被清除掉了）一直清除到0 效果就是一条路径被反方向画出来 keyPath = strokeEnd 动画的fromValue = 0，toValue = 1 表示 这里我们分3个点说明动画的顺序 strokeEnd从结尾开始清除 首先整条路径先清除后2/3，接着清除1/3 效果就是正方向画出路径 keyPath = strokeEnd 动画的fromValue = 1，toValue = 0 效果就是反方向路径慢慢消失 注释：动画的0-1（fromValue = 0，toValue = 1） 或1-0 （fromValue = 1，toValue = 0） 表示执行的方向 和路径的范围。 12345678CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:@\"strokeEnd\"];pathAnimation.duration = 1.5;pathAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];pathAnimation.fromValue = [NSNumber numberWithFloat:0.0f];pathAnimation.toValue = [NSNumber numberWithFloat:1.0f];pathAnimation.autoreverses = NO;[_chartLine addAnimation:pathAnimation forKey:@\"strokeEndAnimation\"];_chartLine.strokeEnd = 2.0;","categories":[],"tags":[]},{"title":"XCode之外,更智能的 AppCode","slug":"XCode之外-更智能的-AppCode","date":"2014-12-29T23:48:23.000Z","updated":"2016-06-22T23:52:33.000Z","comments":true,"path":"2014/12/30/XCode之外-更智能的-AppCode/","link":"","permalink":"http://pro.stonepark.fun/2014/12/30/XCode之外-更智能的-AppCode/","excerpt":"","text":"1. AppCode是咋么回事?跨时代的iPhone石破天惊的火了之后, 其开发环境XCode也火了. 虽然XCode挺流行, 但是如果你用过eclipse写Java, 或者VS写C++,C#等, 会对比出XCode的一些弱点, 尤其是重构. 当然不否认XCode有自己的优点, 比如比Eclipse性能要好. 总之在写代码这一点上, 我认为XCode算不得顶好. 然后AppCode就出现了. 开发AppCode的牛x公司jetbrains, 是专业的开发收费的IDE的公司. AppCode在写代码方面, 比XCode更智能, 能够很大的提升程序员的开发效率. 有了它,一个程序员原来写100行代码的时间, 能写出150行来我觉得应该没问题. 2. 作为一个收费的IDE, AppCode有哪些卖点 ?详细的卖点你在AppCode的网站或者其帮助里面有 :Appcode Features, 你在这里看到的, 是我在使用过程中用过,然后觉得不错的特性. 2.1 写代码辅助 代码补完 所有高级的IDE都有代码补完功能. 你写个”i”, 它就能提示补完”int”. 但是Appcode的代码补完更强大, 比如你写个”n”, 它也能补出”int”来. 是的, 当你写出的字符不是想要的字符串的首字母, 而是包含在中间位置时, 它也能补完.这正是它智能的地方, 仿佛看透了人心. 各种类或者变量命名中, 比较容易让人记住的部分, 不见得在其字符串的头部. 比如你想写”UITableView”, 你脑子里第一个出现的字符, 应该是”table”, 打入”tab” 这几个字符才是符合逻辑的. 在Xcode里, 你恐怕得写”UIT”, 才会给出包含”UITableView”的一系列提示. 但是在AppCode和你的想法一致, 只要你输入”tab”, Appcode就会列出”UITableView” 等一系列你想要的类或者协议的名字了. 总结一下就是, 只要你写出了你想要的字符串中任何位置的几个字符, 甚至忽略大小写, 甚至是隔断的(比如写成tabview), AppCode都会给出你相应的代码提示. 有没有感觉到AppCode是你肚子里的蛔虫? 自动import 当你使用一个类, 但是在当前的源文件里又没有包含其头文件的时候, 系统会提示你导入, 然后你只要按下alt+回车, 就帮你写了#import “xxx.h”. 好吧, 它又猜到了, 我们写了这个代码后, 发现没导入头文件, 就兴冲冲的跑过去帮你把活儿干了. 像不像一个小秘书, 时刻盯着老板, 一看老板掏出一支烟, 啪的一声, 打火机已经过来给点火了. 2.2 代码生成 先使用再定义 &gt; 先使用一个变量、 属性、方法， 然后appCode会提示你这个变量没定义, 这时用alt+回车, 就会帮你创建变量; 先声明后实现 &gt; 先在接口文件中声明方法, 然后alt+回车，会自动帮你在实现文件里面创建方法。 先使用后声明实现协议如果将self传给一个方法作为参数， 这个参数要求是某种协议类型， 那么appCode会自动帮你在接口的生命中增加对协议的实现。 自动生成 &gt; 在代码文件里面, 按下cmd+n, 然后选择你要生成的代码, 省下很多力气. 2.3 重构appCode的重构功能很强大和完善,提供了20多项重构, 括 重命名, 将常量提升为局部变量, 属性, 抽取方法, 转换方法和函数, 上移下移等. 代码重构, 这也是我一只在寻找XCode之外的iDE的主要原因. 2.4 语法检查如果你写错了单词，appCode会提醒你写错了。我属于不喜欢写注释的人， 但是我喜欢将变量或者方法、类等使用很长的多个单词命名。代码的可读性会因此而增强，这也是oc的一大特点。所以语法（英语）检查功能在这里就变得很有用。写代码的同时再次学习了单词…… 3 其他最后说一下它的万能快捷键, alt+回车, 在相应的位置按下这个键, 它总能猜到你想要干什么, 然后列出菜单让你选择或者直接帮你办了. 我使用的时间也不久, 还在探索阶段, 后续再补充吧. 4 补充 目前我appCode和xcode都还在用，appCode用来写代码， xcode使用storyboad以及工程属性的设置， 调试等工作。 appCode存在的问题是： 性能没有xcode好， 当project比较大了之后，会有粘粘的感觉。","categories":[],"tags":[]}]}